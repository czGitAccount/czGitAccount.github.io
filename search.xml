<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>STL_Iterator</title>
    <url>/C++_Language/STL/Iterator/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="STL-Iterator"><a href="#STL-Iterator" class="headerlink" title="STL_Iterator"></a>STL_Iterator</h1><h2 id="1-文件结构"><a href="#1-文件结构" class="headerlink" title="1. 文件结构"></a>1. 文件结构</h2><p><img src="/C++_Language/STL/Iterator/文件结构.png" style="zoom:67%"></p><center><strong>图 1</strong> 文件结构</center><p><strong>Iterator</strong> 的文件结构如上图所示，有两个部分，一个是核心都文件 <code>stl_iterator.h</code>，里面包含了迭代器相关的数据结构，萃取机等关键代码；一个是 <code>typeTraits.h</code>，里面定义了 <code>_type_traits</code> 型别相关声明和定义。</p><hr><h2 id="2-关键代码"><a href="#2-关键代码" class="headerlink" title="2. 关键代码"></a>2. 关键代码</h2><h3 id="2-1-stl-iterator-h"><a href="#2-1-stl-iterator-h" class="headerlink" title="2.1 stl_iterator.h"></a>2.1 <code>stl_iterator.h</code></h3><h4 id="2-1-1-迭代器的型别"><a href="#2-1-1-迭代器的型别" class="headerlink" title="2.1.1 迭代器的型别"></a>2.1.1 迭代器的型别</h4><p>在算法中运用迭代器时，很可能会用到其相应型别。最常见的迭代器相应型别有<strong>五种</strong>：</p><ul><li><em>value_type</em></li><li><em>difference_type</em></li><li><em>reference_type</em></li><li><em>pointer_type</em></li><li><em>iterator_category</em></li></ul><p>以 <em>value_type</em> 为例，为了获取它，<strong>常用的手法</strong>是：利用<strong><font color="F08F00">函数模板的参数推导机制</font></strong>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">func_impl</span>(<span class="title">I</span> <span class="title">iter</span>, <span class="title">T</span> <span class="title">t</span>) &#123;</span></span><br><span class="line">    T tmp;  <span class="comment">// T 就是迭代器所指之物的型别</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">func</span>(<span class="title">I</span> <span class="title">iter</span>) &#123;</span></span><br><span class="line">    func_impl(iter, *iter); <span class="comment">// func 的工作全部移往 func_impl</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    func(&amp;i);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法以 <code>func()</code> 为对外接口，却把实际操作置于 <code>func_impl()</code> 之中，由于 <code>func_impl()</code> 是一个函数模板，一旦被调用，编译器会自动进行模板参数推导，于是推导出型别 T。</p><p>但是如之前描述所述，迭代器的相应型别不只<code>value_type</code> 一种，并非任何情况下都可以利用上述的模板参数推导来取得，所以 STL 引入了 <strong><font color="FF8888">Traits 编程技法</font></strong>。</p><blockquote><p>《STL源码剖析》 — P84 - P85</p></blockquote><hr><h4 id="2-1-2-Traits-编程技法"><a href="#2-1-2-Traits-编程技法" class="headerlink" title="2.1.2 Traits 编程技法"></a>2.1.2 Traits 编程技法</h4><p>上文所述的利用模板的形参推导来获得型别的手法，针对返回值就束手无策了，毕竟函数的模板参数推导机制推到的只是参数，无法推导函数的返回值。<strong><font color="F08F00">声明内嵌型别</font></strong>成为了解决方案！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">MyIter</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">// 内嵌型别的声明 （nested type）</span></span><br><span class="line">    MyIter(T* p = <span class="number">0</span>) : ptr(p) &#123;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">    <span class="comment">// .... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">I</span>:</span>:value_type <span class="comment">// 返回类型，必须要加 typename 告诉编译器这是内嵌型别</span></span><br><span class="line">func(I ite) &#123; <span class="keyword">return</span> *ite; &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function">MyIter&lt;<span class="keyword">int</span>&gt; <span class="title">ite</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>))</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; func(ite);  <span class="comment">// 输出：8</span></span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">注意</font></strong>：</p><p><code>行:10</code>，必须加关键词 <code>typename</code>，因为 T 是一个模板参数，在被编译器具现化之前，编译器不知道此时 <code>MyIter&lt;T&gt;::value_type</code> 是一个型别或是一个成员变量或者成员数据。而 <code>typename</code> 告诉编译器这是一个型别，才能顺利通过编译。 （嵌套从属名称）</p><blockquote><p>《Effective C++ 3rd》 — 条款42：了解 typename 的双重意义（P204- P207） 嵌套从属名称</p></blockquote><p>然而迭代器除了是一个智能指针类之外，还可以是一个原生的指针，而原生指针不是 class type，无法定义内嵌型别。所以除了上述的解决方案以为，还需要针对原生指针进行特殊化的处理：<strong><font color="F08F00">模板的偏特化</font></strong>。泛化和偏特化对比如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span>...&#125;; <span class="comment">// 这个泛化版本允许接受 T 为任何型别</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;T*&gt; &#123;</span>...&#125; <span class="comment">// 这个特化版本仅适用于“T为原生指针”的情况</span></span><br></pre></td></tr></table></figure><p>所以可以使用如下的特化版本来处理原生指针问题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以利用萃取机机制可以让外界方便的获取相应的型别。</p><p><img src="/C++_Language/STL/Iterator/萃取机.png" style="zoom:67%"></p><center><strong>图 2</strong> 萃取机功能</center><blockquote><p>偏特化的一些细节见：《STL源码剖析》 — P86 - P88</p></blockquote><hr><h4 id="2-1-3-五种型别"><a href="#2-1-3-五种型别" class="headerlink" title="2.1.3 五种型别"></a>2.1.3 五种型别</h4><h5 id="2-1-3-1-value-type"><a href="#2-1-3-1-value-type" class="headerlink" title="2.1.3.1 value_type"></a>2.1.3.1 <em>value_type</em></h5><p>所谓的 <em>value_type</em>，是指迭代器指向对象的型别。任何一个打算与 STL 算法有完美搭配的类，都应该定义自己的 <em>value_type</em> 内嵌型别，如上文所述。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原生指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">// 这里不用 const </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">注意</font></strong>：</p><p><code>行:12</code> 处不应该添加 <em>const</em>，因为我们利用这种机制来声明一个暂时的变量，使其型别和迭代器的 <em>value type</em> 相同，而现在，声明一个无法赋值（<em>const</em>）的暂时变量，没有什么用！因此，如果迭代器是个 <em>pointer-to-cons</em>t，我们应该设法取其 <em>value type</em> 的 <em>non-const</em> 版本。</p><blockquote><p>《STL源码剖析》 — P88</p></blockquote><hr><h5 id="2-1-3-2-difference-type"><a href="#2-1-3-2-difference-type" class="headerlink" title="2.1.3.2 difference_type"></a>2.1.3.2 <em>difference_type</em></h5><p><em>difference type</em> 用来表示两个迭代器之间的距离，因此也可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其容量的最大值。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原生指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const *T&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">注意</font></strong>：</p><p><code>行:9,13</code>：<strong>traits</strong> 的两个原生指针的特化版本，以 C++ 内建的 <em>ptrdiff_t</em>（定义于 <code>&lt;cstddef&gt;</code> 都文件） 作为原生指针的 <em>difference type</em>。</p><blockquote><p>《STL源码剖析》 — P90</p></blockquote><hr><h5 id="2-1-3-3-pointer-type-reference-type"><a href="#2-1-3-3-pointer-type-reference-type" class="headerlink" title="2.1.3.3 pointer_type, reference_type"></a>2.1.3.3 <em>pointer_type, reference_type</em></h5><p>这两个不常用。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原生指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const *T&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">注意</font></strong>：</p><p><code>行:15,16</code>：于 <em>value_type</em> 不同，此时需要加上 <em>const</em>，此时是指针与引用。</p><blockquote><p>《STL源码剖析》 — P91 - P92</p></blockquote><hr><h5 id="2-1-3-4-iterator-category"><a href="#2-1-3-4-iterator-category" class="headerlink" title="2.1.3.4 iterator_category"></a>2.1.3.4 <em>iterator_category</em></h5><p>根据移动特性与施行操作，迭代器被分为了<strong>五类</strong>：</p><ul><li><em>input Iterator</em>：这种迭代器所指的对象，不允许外界改变。只读（<em>read only</em>）。</li><li><em>Output Iterator</em>：唯写（<em>write only</em>）。</li><li><em>Forward Iterator</em>：允许”写入型“算法在此种迭代器所形成的区间上进行读写操作。</li><li><em>Bidirectional Iterator</em>：可双向移动。支持某些算法逆向走访迭代器区间。</li><li><em>Random Access Iterator</em>：前四种迭代器只供应一部分指针算数能力（前三种支持 <em>operator++</em>，第四种再加上 <em>operator—</em>），第五种则涵盖所有指针算数能力，包括 <em>p + n, p - n, p[n], p1 - p2, p1 &lt; p2</em>。</li></ul><p>这些迭代器的分类与从属关系如<strong>图3</strong>所示。</p><p><img src="/C++_Language/STL/Iterator/迭代器分类从属.png" style="zoom:80%"></p><center><strong>图 3</strong> 迭代器的分类与从属关系</center><blockquote><p>《STL源码剖析》 — P92 - P93</p></blockquote><p>根据迭代器的分类的不同，可以为算法提供不同选择。</p><p>以 <code>advance()</code> 为例，它可以使用 <em>Input Iterator，Bidirectional Iterator，Random Access Iterator</em> 三种版本。<em>Forward Iterator</em> 与 <em>Input Iterator</em> 完全相同，避免重复。</p><p>（迭代器移动代码如下，详细代码见参考资料）</p><blockquote><p>《STL源码剖析》 — P93 - P94</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Input Iterator           advance_II()</span></span><br><span class="line"><span class="keyword">while</span> (n--) ++i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bidirectional Iterator   advance_BI()</span></span><br><span class="line"><span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> (n--) ++i;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> (n++) --i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Random Access Iterator   advance_RAI()</span></span><br><span class="line">i += n;</span><br></pre></td></tr></table></figure><p>如果选择 <code>advance_II()</code> 则相对于 <code>advance_RAI()</code> 效率极差。如果选择 <code>advance_RAI()</code>，则他无法接受 <em>Input Interator</em>。 所以需要将三者合一，下面是一种做法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">advance</span>(<span class="title">InputIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (is_random_access_iterator(i)) </span><br><span class="line">        advance_RAI(i, n);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is_bidirectional_iterator(i)) </span><br><span class="line">        advance_BI(i, n);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is_input_iterator(i)) </span><br><span class="line">        advance_II(i, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法有一个<strong>缺陷</strong>：只有在<strong><font color="FF8888">运行期</font></strong>才能知道使用哪个版本，会影响效率。最好能够在<strong><font color="FF8888">编译期</font></strong>就选择正确的版本。重载函数机制可以达到这个目标。（模板元编程思想）</p><blockquote><p>《Effective C++ 3th》 — 条款48：认识 template 元编程 （P233 - P234）</p></blockquote><p>设计考虑如下：将”迭代器类型“相应型别作为 <code>advance()</code> 的第三参数，这个相应型别<strong><font color="F08F00">一定必须是 <em>class type</em></font></strong>，不能只是数值号码类的东西，因为编译器依赖它（一个型别）来进行<strong>重载决议</strong>。</p><blockquote><p><a href="https://blog.csdn.net/sinat_35261315/article/details/74907096" target="_blank" rel="noopener">C++函数调用时的决议：名字查找，重载决议，可访问性检测</a></p></blockquote><p>所以定义了以下结构体，他们只是个 <em>tag</em>，所以没有任何成员：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 五种迭代器类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure><p>所以<code>__advance()</code>的重载版本表示如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">input_iterator_tag</span>) &#123;</span></span><br><span class="line">    <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> </span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">bidirectional_iterator_tag</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span> (n++) --i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> </span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">random_access_iterator_tag</span>) &#123;</span></span><br><span class="line">    i += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现模板只提供了两个参数，还需要让 <code>__advance()</code>有能力从获得的迭代器中推导出其类型。这份工作自然而然就交给了 <strong>traits</strong>。所以上层接口函数可以如下编写。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">random_access_iterator_tag</span>) &#123;</span></span><br><span class="line">    __advance(i, n, iterator_traits&lt;InputIterator&gt;::iterator_category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iterator_traits&lt;InputIterator&gt;::iterator_category()</code> 将产生一个临时对象，其型别对于该隶属于前述五个迭代器类型之一。然后，根据这个型别，编译器才决定调用哪个 <code>__advance()</code> 重载函数。</p><p><strong><font color="FF8888">注意</font></strong>：</p><p>任何一个迭代器，<strong><font color="F08F00">其类型永远应该落在“该迭代器所隶属之各种类型中最强化的那个</font></strong>”。如上个例子，既是 <em>Random_Access_Iterator</em>，又是 <em>Bidirectional_Iterator</em>，同时也是 <em>Forward_Iterator</em>，而且也是 <em>Input_Iterator</em>，那么，其类型应该归属于 <em>random_access_iterator_tag</em>。</p><p>另外可以发现上面代码，模板参数名称取得并不是 <em>RandomAccessIterator</em>，而是 <em>InputIterator</em>，这是一个 STL 算法的<strong>命名规则</strong>：<strong><font color="F08F00">以算法能接受的最低阶迭代器类型，来为其迭代器型别参数命名</font></strong>。(方便代码阅读)</p><blockquote><p>《STL源码剖析》 — P97</p></blockquote><p>通过五种迭代器类型的结构体可以发现，它们不仅是以 class 定义的迭代器标签，还满足<strong>继承</strong>关系。</p><p><img src="/C++_Language/STL/Iterator/迭代器分类继承关系.png" style="zoom:50%"></p><center><strong>图 4</strong> 迭代器类型标签的继承关系</center><p><strong><font color="FF8888">注意</font></strong>：</p><p>首先以 <em>class</em> 来定义迭代器的各种分类标签，可以促成重载机制的成功运作（使编译器得以正确执行重载决议）；</p><p>其次通过继承，不必再写“单纯只做传递调用”的函数（例如前述的 <code>__advance()</code> 的 <em>ForwordIterator</em> 版本）。因为如果 <code>advance()</code> 传入的迭代器类型是 <em>ForwordIterator</em>，虽然 <code>__advance()</code> 重载版本中没有与之对应的版本，但是通过重载与继承的结合，<code>advance()</code> 会调用 <code>__advance()</code> 的 <em>InputIterator</em> 版本。</p><blockquote><p>《STL源码剖析》 — P97 - P99</p></blockquote><p>最后，为了符合规范，任何迭代器都应该提供这五个内嵌相应的型别，以便于 <strong>traits</strong> 萃取，STL 提供了一个 <em>iterator class</em> 如下，如果每个新设计的迭代器都<strong>继承</strong>自它，就可以保证符合 STL 所需之规范：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后三个提供了固定的默认值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Category</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span> = <span class="title">ptrdiff_t</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Pointer</span> = <span class="title">T</span> *, <span class="title">class</span> <span class="title">Reference</span> = <span class="title">T</span> &amp;&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> iterator_category = Category;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> difference_type = Distance;</span><br><span class="line">    <span class="keyword">using</span> pointer = Pointer;</span><br><span class="line">    <span class="keyword">using</span> reference = Reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>《STL源码剖析》 — P100</p></blockquote><hr><h4 id="2-1-4-Iterator-总结"><a href="#2-1-4-Iterator-总结" class="headerlink" title="2.1.4 Iterator 总结"></a>2.1.4 Iterator 总结</h4><h5 id="2-1-4-1-五种迭代器类型及其继承关系"><a href="#2-1-4-1-五种迭代器类型及其继承关系" class="headerlink" title="2.1.4.1 五种迭代器类型及其继承关系"></a>2.1.4.1 五种迭代器类型及其继承关系</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//五种迭代器类型 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>《STL源码剖析》 — P95</p></blockquote><hr><h5 id="2-1-4-2-STL-提供的-Iterator-class"><a href="#2-1-4-2-STL-提供的-Iterator-class" class="headerlink" title="2.1.4.2 STL 提供的 Iterator class"></a>2.1.4.2 STL 提供的 Iterator class</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后三个提供了固定的默认值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Category</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span> = <span class="title">ptrdiff_t</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Pointer</span> = <span class="title">T</span> *, <span class="title">class</span> <span class="title">Reference</span> = <span class="title">T</span> &amp;&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> iterator_category = Category;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> difference_type = Distance;</span><br><span class="line">    <span class="keyword">using</span> pointer = Pointer;</span><br><span class="line">    <span class="keyword">using</span> reference = Reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>《STL源码剖析》 — P100</p></blockquote><hr><h5 id="2-1-4-3-traits"><a href="#2-1-4-3-traits" class="headerlink" title="2.1.4.3 traits"></a>2.1.4.3 traits</h5><p><strong><font color="FF8888">注意</font></strong>以下 MiniSTL 代码使用 C++11/14 新特性：<strong><em>using</em></strong> 代替 <em>typedef</em></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> iterator_category = <span class="keyword">typename</span> Iterator::iterator_category;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Iterator::value_type;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> Iterator::difference_type;</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> Iterator::pointer;</span><br><span class="line">    <span class="keyword">using</span> reference = <span class="keyword">typename</span> Iterator::reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对raw pointer设计的偏特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T *&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> iterator_category = random_access_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> pointer = T *;</span><br><span class="line">    <span class="keyword">using</span> reference = T &amp;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对 pointer-to-const 设计的偏特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T *&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> iterator_category = random_access_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type = T; 				<span class="comment">// 没有 const</span></span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">const</span> T *;  		<span class="comment">// 有 const</span></span><br><span class="line">    <span class="keyword">using</span> reference = <span class="keyword">const</span> T &amp;;		<span class="comment">// 有 const</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为原生指针无法定义内嵌型别，也就因此无法使用 <em>class type</em> 的版本，但 STL 据对必须接受原生指针作为一种迭代器，解决思路是使用原生指针的偏特化版本，如上所示。</p><blockquote><p>《STL源码剖析》 — P86</p></blockquote><p><strong><font color="FF8888">注意</font></strong>以下 MiniSTL 代码同样使用了 C++11/14 新特性：<strong>别名模板</strong>，提供了一种更加高效的使用方法。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">iterator_category_t</span> =</span></span><br><span class="line"><span class="class">    <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:iterator_category;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">value_type_t</span> = <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:value_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">difference_type_t</span> = <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:difference_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">pointer_t</span> = <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:pointer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">reference_t</span> = <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;Iterator&gt;:</span>:reference;</span><br></pre></td></tr></table></figure><p>如果要用迭代器 $I$ 的 <em>value_type</em> 来声明变量 <em>val</em> 两个版本的差异如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">iterator_traits&lt;I&gt;::iterator_value val;</span><br><span class="line"><span class="keyword">value_type_t</span>&lt;I&gt; val;</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">注意</font></strong>：</p><p>可以发现这样更加方便代码的书写，其实并不仅仅只是书写简单的帮助，利用别名模板还能实现 <code>template template parameter</code>。</p><blockquote><p>MiniSTL / Iterator / stl_iterator.h</p><p><a href="https://www.bilibili.com/video/BV1RB4y1F7x4?p=10" target="_blank" rel="noopener">侯捷C++新标准-C++11/14_10 Alias Template</a></p><p><a href="https://www.bilibili.com/video/BV1RB4y1F7x4?p=11" target="_blank" rel="noopener">侯捷C++新标准-C++11/14_11 template template parameter</a></p></blockquote><hr><h5 id="2-1-4-4-advance-，distance"><a href="#2-1-4-4-advance-，distance" class="headerlink" title="2.1.4.4 advance()，distance()"></a>2.1.4.4 <code>advance()</code>，<code>distance()</code></h5><p>整组 <code>advance()</code> 函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">input_iterator_tag</span>) &#123;</span></span><br><span class="line">    <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>,<span class="title">bidirectional_iterator_tag</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span> (n++) --i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>,<span class="title">random_access_iterator_tag</span>) &#123;</span></span><br><span class="line">    i += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">advance</span>(<span class="title">InputIterator</span> &amp;<span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>) &#123;</span></span><br><span class="line">    __advance(i, n, <span class="keyword">iterator_category_t</span>&lt;InputIterator&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整组 <code>distance()</code> 函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">difference_type_t</span>&lt;InputIterator&gt; __<span class="title">distance</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                                   <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                                   <span class="title">input_iterator_tag</span>) &#123;</span></span><br><span class="line">    <span class="keyword">difference_type_t</span>&lt;InputIterator&gt; n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (first != last) ++first, ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">difference_type_t</span>&lt;InputIterator&gt; __<span class="title">distance</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                                   <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                                   <span class="title">random_access_iterator_tag</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">difference_type_t</span>&lt;InputIterator&gt; <span class="title">distance</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                                 <span class="title">InputIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> __distance(first, last, <span class="keyword">iterator_category_t</span>&lt;InputIterator&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>《STL源码剖析》 — P102 - P103</p></blockquote><hr><h5 id="2-1-4-5-迭代器适配器"><a href="#2-1-4-5-迭代器适配器" class="headerlink" title="2.1.4.5 迭代器适配器"></a>2.1.4.5 迭代器适配器</h5><p><em>insert, reverse, stream</em> 见 <strong>adapters</strong> 章节</p><h3 id="2-2-typeTraits-h"><a href="#2-2-typeTraits-h" class="headerlink" title="2.2 typeTraits.h"></a>2.2 <code>typeTraits.h</code></h3><p><strong>iterator_traits</strong> 负责萃取迭代器特性，<strong>__type_traits</strong> 负责萃取型别的特性。此处所关注的型别特性是指，这个型别是否具备 <em>non-trivial defalt ctor, non-trivial copy ctor, non-trivial assignment operator, non-trivial dtor</em>，如果答案是否定的我们在对这个型别进行构造、拷贝、赋值、析构等操作时，就可以采用最有效的措施（根本不用调用身居高位，不谋实事的那些 <code>constructor</code>，<code>destructor</code>），而采用内存直接处理操作，如 <code>malloc()</code>，<code>memcpy()</code> 等等，获得最高效率，这对于大规模而操作频繁的容器，有着显著的效率提升。</p><p><strong>__type_trait</strong> 提供了一种机制，允许针对不同的型别属性，在编译器完成函数派送决定。这对于撰写模板很有帮助。例如，当我们准备对一个“元素型别”未知的数组执行 <em>copy</em> 操作时，如果我们能实现知道其元素是否有一个 <code>trivial copy constructor</code>，便能帮助我们决定是否可以使用快速的 <code>memcpy()</code> 或 <code>memmove()</code>。</p><h4 id="2-2-1-部分-type-traits-定义"><a href="#2-2-1-部分-type-traits-定义" class="headerlink" title="2.2.1 部分 _type_traits 定义"></a>2.2.1 部分 _type_traits 定义</h4><p>默认自定义类型均为 non-POD 类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">type_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> has_trivial_default_constructor = _false_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_copy_constructor = _false_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_assignment_operator = _false_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_destructor = _false_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD_type = _false_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>针对 C++基本型别：<em>bool, char, signed char, unsigned char, short, unsigned short, int unsigned int, long, unsigned long, float, double, long double</em> 提供了特化版本，且每一个成员的值都是 <strong>__true_type</strong>，表示这些型别都可以采用最快速方式来进行拷贝赋值等操作。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">type_traits</span>&lt;bool&gt; &#123;</span>  <span class="comment">//  bool 可以替换为 char....</span></span><br><span class="line">    <span class="keyword">using</span> has_trivial_default_constructor = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_copy_constructor = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_assignment_operator = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_destructor = _true_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD_type = _true_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>针对原生指针设计 __type_traits 偏特化版本，原生指针亦可被视为一种标量型别</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">type_traits</span>&lt;const T *&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> has_trivial_default_constructor = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_copy_constructor = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_assignment_operator = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_destructor = _true_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD_type = _true_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>《STL源码剖析》 — P103 - P111</p><p><a href="https://blog.csdn.net/francisapp/article/details/77063819?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">C++ trivial、non-trivial及POD类型</a></p></blockquote><h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3.参考资料"></a>3.参考资料</h2><blockquote><p>《STL源码剖析》</p><p>《Effective C++ 3th》</p><p><a href="https://blog.csdn.net/sinat_35261315/article/details/74907096" target="_blank" rel="noopener">C++函数调用时的决议：名字查找，重载决议，可访问性检测</a></p><p><a href="https://blog.csdn.net/francisapp/article/details/77063819?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">C++ trivial、non-trivial及POD类型</a></p><p><a href="https://www.bilibili.com/video/BV1RB4y1F7x4?p=10" target="_blank" rel="noopener">侯捷C++新标准-C++11/14_10 Alias Template</a></p><p><a href="https://www.bilibili.com/video/BV1RB4y1F7x4?p=11" target="_blank" rel="noopener">侯捷C++新标准-C++11/14_11 template template parameter</a></p><p>MiniSTL / Iterator 部分</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>C++_Language</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_Allocator</title>
    <url>/C++_Language/STL/Allocator/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="STL-Allocator"><a href="#STL-Allocator" class="headerlink" title="STL_Allocator"></a>STL_Allocator</h1><h2 id="1-文件结构"><a href="#1-文件结构" class="headerlink" title="1. 文件结构"></a>1. 文件结构</h2><p><img src="/C++_Language/STL/Allocator/文件结构.png" style="zoom:67%"></p><center><strong>图 1</strong> Allocator 文件结构</center><p>Allocator 文件结构以及关键函数如上图所示，分为了两个部分，simpleAlloc，subAllocation。</p><h3 id="1-1-simpleAlloc"><a href="#1-1-simpleAlloc" class="headerlink" title="1.1 simpleAlloc"></a>1.1 simpleAlloc</h3><p>内部包含 1 个头文件：<code>simpleAlloc.h</code></p><h4 id="1-1-1-simpleAlloc-h"><a href="#1-1-1-simpleAlloc-h" class="headerlink" title="1.1.1 simpleAlloc.h"></a>1.1.1 simpleAlloc.h</h4><p><code>simpleAlloc.h</code> 这是一个简单的空间配置器的例子，实现了部分的接口和功能。</p><p>内部<strong>调用</strong> <strong><font color="FF8888">::operator new、 ::operator delete</font></strong></p><blockquote><p>《STL源码剖析》 — P44 - P47</p></blockquote><hr><h3 id="1-2-subAllocation"><a href="#1-2-subAllocation" class="headerlink" title="1.2 subAllocation"></a>1.2 subAllocation</h3><p>内部包含 5 个头文件：</p><ul><li><code>allocator.h</code></li><li><code>memory.h</code></li><li><code>alloc.h</code></li><li><code>construct.h</code></li><li><code>uninitialized.h</code></li></ul><hr><h4 id="1-2-1-allocator-h"><a href="#1-2-1-allocator-h" class="headerlink" title="1.2.1 allocator.h"></a>1.2.1 allocator.h</h4><p>与 <code>simpleAlloc.h</code> 相类似。它由 SGI 定义的一个符合部分标准，名为 allocator 的配置器，但是 SGI 从未使用过它，也不建议我们使用。主要的原因是效率不佳，只是把 C++ 的 <strong><font color="FF8888">::operator new</font></strong> 和 <strong><font color="FF8888">::operator delete</font></strong> 做一层薄薄的包装而已。</p><blockquote><p>《STL源码剖析》 — P48 - P49</p></blockquote><hr><h4 id="1-2-2-memory-h"><a href="#1-2-2-memory-h" class="headerlink" title="1.2.2 memory.h"></a>1.2.2 memory.h</h4><p>内部包含了 3 个头文件：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"alloc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"construct.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"uninitialized.h"</span></span></span><br></pre></td></tr></table></figure><p><strong><font color="F08F00">alloc.h</font></strong> 定义了一、二级配置器，彼此合作。配置器名为 <strong>alloc</strong>。利用 <code>allocate()</code> <strong>分配内存</strong>，利用 <code>deallocate()</code> <strong>释放内存</strong>。</p><p><strong><font color="F08F00">construct.h</font></strong> 定义了全局函数 <code>construct()</code> 和 <code>destroy()</code>，负责对象的<strong>构造</strong>和<strong>析构</strong>。</p><p><strong><font color="F08F00">uninitialized.h</font></strong> 定义了一些全局函数，用来<strong>填充</strong>或<strong>复制</strong>大块内存数据，这些函数虽然不属于配置器的范畴，但与对象初值设置有关。对于容器的大规模元素初值设置很有帮助。这些函数对于效率都有面面俱到的考虑，<strong>最差</strong>情况下会调用 <code>construct()</code>，<strong>最佳</strong>情况则会使用 C 标准函数 <code>memmove()</code> 直接进行内存数据的移动。</p><blockquote><p>《STL源码剖析》 — P50</p></blockquote><hr><h2 id="2-关键代码"><a href="#2-关键代码" class="headerlink" title="2. 关键代码"></a>2. 关键代码</h2><h3 id="2-1-construct-h"><a href="#2-1-construct-h" class="headerlink" title="2.1 construct.h"></a>2.1 construct.h</h3><h4 id="2-1-1-头文件"><a href="#2-1-1-头文件" class="headerlink" title="2.1.1 头文件"></a>2.1.1 头文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;  // placement new 所需的头文件       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"typeTraits.h"</span> <span class="comment">// 萃取机所需要的头文件</span></span></span><br></pre></td></tr></table></figure><blockquote><p>《STL源码剖析》 — P51</p></blockquote><hr><h4 id="2-1-2-构造"><a href="#2-1-2-构造" class="headerlink" title="2.1.2 构造"></a>2.1.2 构造</h4><p>构造函数只有一种，可以使用 <strong><font color="FF8888">placement new</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">construct</span>(<span class="title">T1</span> *<span class="title">p</span>, <span class="title">T2</span> <span class="title">value</span>) &#123;</span></span><br><span class="line">    <span class="keyword">new</span> (p) T1(value);  <span class="comment">// placement new, 调用 T1::T1(value)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>《STL源码剖析》 — P51</p></blockquote><hr><h4 id="2-1-3-析构"><a href="#2-1-3-析构" class="headerlink" title="2.1.3 析构"></a>2.1.3 析构</h4><p>析构函数有四个重载函数，<strong>版本一</strong>就是简单调用对象的析构函数，如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">T</span> *<span class="title">p</span>) &#123;</span></span><br><span class="line">    p-&gt;~T();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>版本二</strong>接受两个迭代器，并根据不同的元素型别选择调用不同的接口函数。<code>destroy()</code> 内部调用不同型别对应的接口函数 <code>_destroy_aux()</code>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设法利用traits批量析构对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">destroy</span>(<span class="title">ForwardIterator</span> <span class="title">beg</span>, <span class="title">ForwardIterator</span> <span class="title">end</span>) &#123;</span> </span><br><span class="line">    <span class="comment">/* typename 必须要使用,因为是模板的别名 */</span></span><br><span class="line">    <span class="keyword">using</span> is_POD_type = <span class="keyword">typename</span> _type_traits&lt;ForwardIterator&gt;::is_POD_type; </span><br><span class="line">    _destroy_aux(beg, <span class="built_in">end</span>, is_POD_type()); <span class="comment">// 根据元素型别调用适配的接口函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果元素的 value_type 存在non—trivial destructor，老老实实调用析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span> <span class="title">beg</span>, <span class="title">ForwardIterator</span> <span class="title">end</span>, _<span class="title">false_type</span>) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; beg != <span class="built_in">end</span>; ++beg) destroy(&amp;*beg);  <span class="comment">// 毕竟迭代器不是真正的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在trivial destructor</span></span><br><span class="line"><span class="comment">// 如果对象的析构函数无关痛痒，那么反复调用它是一种效率上的巨大浪费</span></span><br><span class="line"><span class="comment">/* 因此，若是_true_type 的话就什么也不做就结束*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> _<span class="title">destroy_aux</span>(<span class="title">ForwardIterator</span>, <span class="title">ForwardIterator</span>, _<span class="title">true_type</span>) &#123;</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>版本三、四</strong>是对应 <strong>char*</strong> 和 <strong>wchar_t*</strong> 的特化版本。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为 char* 和 wchar_t* 归于 POD 类型，属于 trivial 类型，--&gt; _true_type</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">char</span> *)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">wchar_t</span> *, <span class="keyword">wchar_t</span> *)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以参考 <a href="https://blog.csdn.net/francisapp/article/details/77063819?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">C++ trivial、non-trivial及POD类型</a></p><p>“typeTraits.h” 头文件中有详细的分类</p><p>《STL源码剖析》 — P51</p></blockquote><hr><h3 id="2-2-alloc-h"><a href="#2-2-alloc-h" class="headerlink" title="2.2 alloc.h"></a>2.2 alloc.h</h3><p><code>alloc.h</code> 为 <strong>sub-Allocation</strong> 的主要实现，<strong>sub-Allocation</strong> 理解为具有次配置的空间配置器，分为两级配置。</p><ul><li>一级配置器 <strong>_malloc_alloc</strong>，分配内存 $&gt; 128\ bytes$</li><li>二级配置器 <strong>_default_alloc</strong>，分配内存 $\leq 128\ bytes$</li></ul><blockquote><p>《STL源码剖析》 — P53 - P56</p></blockquote><hr><h4 id="2-2-1-头文件"><a href="#2-2-1-头文件" class="headerlink" title="2.2.1 头文件"></a>2.2.1 头文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;   // malloc free realloc</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;		 // bad_alloc </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  // memcpy</span></span></span><br></pre></td></tr></table></figure><blockquote><p>《STL源码剖析》 — P56</p></blockquote><hr><h4 id="2-2-2-一级配置器"><a href="#2-2-2-一级配置器" class="headerlink" title="2.2.2 一级配置器"></a>2.2.2 一级配置器</h4><p>一级配置器，主要有两个主要功能：</p><ul><li>分配和释放内存</li><li>处理内存不足的状况</li></ul><h5 id="2-2-2-1-分配和释放内存"><a href="#2-2-2-1-分配和释放内存" class="headerlink" title="2.2.2.1 分配和释放内存"></a>2.2.2.1 分配和释放内存</h5><p><code>allocate()</code> 直接使用 <code>malloc()</code> ；</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 使用 malloc 分配内存</span></span><br><span class="line">	<span class="keyword">void</span> *result = <span class="built_in">malloc</span>(n);</span><br><span class="line">	<span class="comment">// 如果分配内存失败，调用 oom_malloc 处理， 类似于 new_handler</span></span><br><span class="line">	<span class="keyword">if</span> (result == <span class="literal">nullptr</span>) result = oom_malloc(n);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>deallocate()</code> 直接使用 <code>free()</code> ；</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// deallocate 释放内存，内部调用 free</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> <span class="comment">/*n*/</span>)</span> </span>&#123; <span class="built_in">free</span>(p); &#125;</span><br></pre></td></tr></table></figure><p><code>reallocate()</code> 直接使用 <code>reallocate()</code> ；</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reallocate 修改分配内存，内部调用 realloc</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> <span class="comment">/*old_sz*/</span>, <span class="keyword">size_t</span> new_sz)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 使用 realloc 重新分配内存， 如果 new_sz = nullptr  realloc 等价于 malloc</span></span><br><span class="line">	<span class="keyword">void</span> *result = <span class="built_in">realloc</span>(p, new_sz);</span><br><span class="line">	<span class="comment">// 如果分配内存失败，调用 oom_realloc 处理， 类似于 new_handler</span></span><br><span class="line">	<span class="keyword">if</span> (result == <span class="literal">nullptr</span>) oom_realloc(p, new_sz);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，三个函数皆是直接使用库函数来实现，但是进行了内存分配失败的处理 <code>oom_malloc(n)</code>，<code>oom_realloc(n)</code>。</p><blockquote><p>《STL源码剖析》 — P57</p></blockquote><hr><h5 id="2-2-2-2-处理内存不足的状况"><a href="#2-2-2-2-处理内存不足的状况" class="headerlink" title="2.2.2.2 处理内存不足的状况"></a>2.2.2.2 处理内存不足的状况</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> malloc_handler = <span class="keyword">void</span> (*)();</span><br><span class="line"><span class="comment">//以下函数指针用以处理内存不足的情况 (两个静态函数，一个静态成员变量(函数指针))</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;  <span class="comment">// 处理 allocate 失败</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>; <span class="comment">// 处理 realloc 失败</span></span><br><span class="line"><span class="keyword">static</span> malloc_handler __malloc_alloc_oom_handler; <span class="comment">// 类似 new_handler 用户处理函数</span></span><br></pre></td></tr></table></figure><hr><p>为了模拟 <strong><font color="FF8888">set_new_handler</font></strong> 行为，需要写一个类似标准版的<code>set_malloc_handler()</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟 C++ 的 set_new_handler(), 可以通过它来指定自己的 out-of-memory handler</span></span><br><span class="line"><span class="comment">// Effective c++ 条款 49</span></span><br><span class="line"><span class="comment">// set_malloc_handler 会将它获得的指针存储起来，然后返回先前（在此调用之前）存储的指针</span></span><br><span class="line"><span class="comment">// 用来管理静态成员变量 __malloc_alloc_oom_handler</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> malloc_handler <span class="title">set_malloc_handler</span><span class="params">(malloc_handler f)</span> </span>&#123;</span><br><span class="line">	malloc_handler old = __malloc_alloc_oom_handler;</span><br><span class="line">	__malloc_alloc_oom_handler = f;</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125; <span class="comment">// 类内成员函数 ↑ 共用户调用装配自己的 处理函数</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __malloc_alloc_oom_handler的类外定义，函数指针为 nullptr</span></span><br><span class="line"><span class="keyword">typename</span> __malloc_alloc::malloc_handler</span><br><span class="line">    __malloc_alloc::__malloc_alloc_oom_handler = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><blockquote><p>《Effective C++ 3th》 — 条款49：了解 new-handler 的行为 （P243）</p><p>《STL源码剖析》 — P57</p></blockquote><hr><p><code>oom_malloc()</code> 用来自定义处理 <strong>malloc</strong> 分配失败的情况。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">__malloc_alloc::oom_malloc</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// void(*new_alloc_handler)();</span></span><br><span class="line">    malloc_handler new_alloc_handler;  <span class="comment">// 定义 new_handler</span></span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">//不断尝试释放、配置</span></span><br><span class="line">		<span class="comment">// 分配失败：找到目前的 new_handing 函数，之前由用户调用 set_malloc_handler 创建</span></span><br><span class="line">        new_alloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="comment">// 只有当 malloc-handling 函数的指针是 null, 才会抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (!new_alloc_handler) <span class="keyword">throw</span> <span class="built_in">std</span>::bad_alloc(); </span><br><span class="line">        (*new_alloc_handler)();    <span class="comment">// 调用 handler，试图释放内存</span></span><br><span class="line"></span><br><span class="line">        result = <span class="built_in">malloc</span>(n);        <span class="comment">// 再次分配内存</span></span><br><span class="line">        <span class="keyword">if</span> (result) <span class="keyword">return</span> result; <span class="comment">// 如果成功，返回一个指向分配得来的内存的一个指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>oom_realloc()</code> 用来自定义处理 <strong>remalloc</strong> 分配失败的情况。与上文代码相同，仅仅 <code>行: 8</code> 不同。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">__malloc_alloc::oom_realloc</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    malloc_handler new_alloc_handler; <span class="comment">// 定义 new_handler</span></span><br><span class="line">    <span class="keyword">void</span> *result; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        new_alloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (!new_alloc_handler) <span class="keyword">throw</span> <span class="built_in">std</span>::bad_alloc();</span><br><span class="line">        (*new_alloc_handler)();</span><br><span class="line">        result = <span class="built_in">realloc</span>(p, n); </span><br><span class="line">        <span class="keyword">if</span> (result) <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的处理函数步骤如下：</p><ul><li><p>用户调用 <code>set_malloc_handler()</code> 自定义自己的处理函数，如果未定义，<strong>_malloc_alloc_oom_handler</strong> 被默认定义为 <strong>nullptr</strong>，是一个空指针。</p></li><li><p>如果出现内存分配失败情况，进入相应的处理函数，<code>oom_malloc()</code> 或者 <code>oom_realloc()</code></p><ul><li>首先定义处理函数 <strong>new_alloc_handler</strong> 并将 <strong>_malloc_alloc_oom_handler</strong> 赋给它；</li><li>如果用户<strong>未定义</strong>相应的处理函数，直接抛出异常即可；否则调用用户定义的处理函数，试图解决内存不足的情况；</li><li>再次重新调用 <code>malloc()</code> 分配内存；</li></ul></li></ul><p><strong><font color="FF8888">注意</font></strong>：</p><ul><li><p>设计和设定“内存不足处理函数”是客端的责任。</p></li><li><p>其中 <code>for (;;)</code> 的使用可以使得处理函数<strong>不断尝试</strong>处理内存不足情况。</p></li></ul><blockquote><p>《STL源码剖析》 — P58 - P59</p><p>《Effective C++ 3th》 — 条款51：编写 new 和 delete 时需固守的常规 （P253）</p></blockquote><hr><h4 id="2-2-3-二级配置器"><a href="#2-2-3-二级配置器" class="headerlink" title="2.2.3 二级配置器"></a>2.2.3 二级配置器</h4><p>二级配置器多了一些机制，避免太多小额外区块造成内存的碎片。小额区块带来的其实不仅时内存碎片，配置时的额外负担也是一个大问题。额外负担永远无法避免，毕竟系统要靠这多出来的空间来管理内存，如下图所示。但是块区越小，额外负担所占的比例就越大，越显得浪费。</p><p><img src="/C++_Language/STL/Allocator/内存管理.png" style="zoom:50%"></p><center><strong>图 2</strong> 所求任何一块内存，都得有一些“税”要缴给系统</center><p>SGI 第二级配置器的做法是，如果区块够大，超过 128 $bytes$ 时，就移交给第一级配置器处理。当区块小于 128 $bytes$ 时，则以内存池（<strong>memory pool</strong>）管理，此法又称为次层配置（<strong>sub-allocation</strong>)：每次配置一大块内存，并维护对应之自由链表（<em>free​-list​</em>），下次若再有相同大小的内存需求，就直接从 ​<em>free-list​</em> 中拔出。如果客端释放小额区块，就由配置器收回到 <em>free-list​</em> 中。</p><h5 id="2-2-3-1-自由链表"><a href="#2-2-3-1-自由链表" class="headerlink" title="2.2.3.1 自由链表"></a>2.2.3.1 自由链表</h5><p><em>free​-list​</em> 节点<strong>结构</strong>如下，实现技巧如下图 3 所示。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// free_list节点</span></span><br><span class="line">    <span class="comment">// 由于union特性，并不需要占用额外的内存</span></span><br><span class="line">	<span class="comment">// obj 可以被视为一个指针，指向相同形式的另一个obj</span></span><br><span class="line">	<span class="comment">// obj 也可被视为一个指针，指向实际块区</span></span><br><span class="line"><span class="keyword">union</span> obj &#123;</span><br><span class="line">	<span class="keyword">union</span> obj *free_list_link;  <span class="comment">//指向下一节点</span></span><br><span class="line">	<span class="keyword">char</span> client_data[<span class="number">1</span>];        <span class="comment">//指向资源</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/C++_Language/STL/Allocator/自由链表的实现技巧.png" style="zoom:50%"></p><center><strong>图 3</strong> 自由链表的实现技巧</center><p>为了方便管理，SGI 二级配置器会主动使用 <code>ROUND_UP()</code>函数将任何小额区块的内存需求量上调至 8 的倍数，并维护 16 个 <em>free-list</em> 。从 $\{8,16,….128\}$。使用 <code>FREELIST_INDEX()</code> 函数确定区块编号。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// freelist参数设定</span></span><br><span class="line"><span class="comment">// 区块上调边界，区块上限，freelist个数</span></span><br><span class="line"><span class="comment">// Effective C++ 所述 enum 惯用法,条款 2</span></span><br><span class="line"><span class="keyword">enum</span> __freelist_setting &#123;</span><br><span class="line">    __ALIGN = <span class="number">8</span>, </span><br><span class="line">    __MAX_BYTES = <span class="number">128</span>,</span><br><span class="line">    __NFREELISTS = __MAX_BYTES / __ALIGN  <span class="comment">// 16</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于 <strong>_freelist_setting</strong> 的相关操作</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将bytes上调至8的倍数</span></span><br><span class="line"><span class="comment">// 例子：(bytes + 7) &amp; ~7  --- &gt;  (bytes + 7) &amp; 1..11000</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (((bytes) + <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(__ALIGN) - <span class="number">1</span>) &amp;</span><br><span class="line">			~(<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(__ALIGN) - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建 free_list[16] 数组, 里面存放 obj* 类型数据</span></span><br><span class="line"><span class="keyword">static</span> obj *<span class="keyword">volatile</span> free_list[__NFREELISTS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 决定使用第几号节点，从 0 起算 (本质就是就偏移)</span></span><br><span class="line"><span class="comment">// ((1~7) + 7) / 8 - 1 ---&gt; 0   .... 依次类推</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bytes + <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(__ALIGN) - <span class="number">1</span>) /</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(__ALIGN) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>《STL源码剖析》 — P59 - P61</p><p>《Effective C++ 3th》 — 条款2：尽量用 <em>const,enum,inline</em> 替代 #define （P15）</p></blockquote><hr><h5 id="2-2-3-2-空间配置函数-allocate"><a href="#2-2-3-2-空间配置函数-allocate" class="headerlink" title="2.2.3.2 空间配置函数 allocate()"></a>2.2.3.2 空间配置函数 <code>allocate()</code></h5><p>空间配置函数为 <code>allocate()</code>，如果需要分配的内存大于 128 则采用一级配置器，否则从自由链表中拔出内存使用，如果自由链表没有没存就需要调用 <code>refill()</code> 来填充自由链表。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">__default_alloc::allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;  <span class="comment">/*n &gt; 0*/</span></span><br><span class="line">    obj *<span class="keyword">volatile</span> *my_free_list;</span><br><span class="line">    obj *result;</span><br><span class="line">    <span class="comment">// 若 n 大于128,则采用一级配置器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; __MAX_BYTES) <span class="keyword">return</span> (malloc_alloc::allocate(n));</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// free_list 是一个存 obj*的数组, 数组名为free_list[0]指针</span></span><br><span class="line">    <span class="comment">// 通过 FREELIST_INDEX 求出偏移，并选择采用第几区块，并让 result 指向它</span></span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    result = *my_free_list;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 未找到可用free_list，准备填充free_list</span></span><br><span class="line">        <span class="keyword">void</span> *r = refill(ROUND_UP(n));</span><br><span class="line">        <span class="keyword">return</span> r; <span class="comment">// 并且返回一个指向内存的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 my_free_list 指向，当前 result 节点的 next (free_list_link)</span></span><br><span class="line">    *my_free_list = result-&gt;free_list_link;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/C++_Language/STL/Allocator/区块自freelist拔出.png" style="zoom:50%"></p><center><strong>图 4</strong> 区块自 <i>free-list</i> 拔出</center><blockquote><p>《STL源码剖析》 — P62 - P63</p></blockquote><hr><h5 id="2-2-3-3-空间释放函数-deallocate"><a href="#2-2-3-3-空间释放函数-deallocate" class="headerlink" title="2.2.3.3 空间释放函数 deallocate()"></a>2.2.3.3 空间释放函数 <code>deallocate()</code></h5><p>同样需要判断区块大小，大于128 字节，使用一级配置器，小于128 字节就找到对应的 <em>free-list</em>，将区块回收。</p><p>分为四个步骤</p><ul><li>强制类型转换，将 <em>p</em> 转化为 <em>obj** 节点类型 </em>q<em> ，使用 </em>reinterpret_cast<em> 将 </em>void* -&gt; obj**</li><li>根据内存的大小确定区块，调用 <code>FREELIST_INDEX()</code></li><li>将 <em>q</em> 的 next 区块指向当前 <strong>my_free_list</strong> 指向的内存</li><li>更新 <em>my_free_list</em> 为 <em>q</em></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">__default_alloc::deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p不可为nullptr，大于128字节，就调用一级配置器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(__MAX_BYTES))</span><br><span class="line">        malloc_alloc::deallocate(p, n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找对应的free list, 分为四个步骤 ：</span></span><br><span class="line">		<span class="comment">// 1：强制类型转换，将 p 转化为 q 的 节点类型指针</span></span><br><span class="line">		<span class="comment">// 使用 reinterpret_cast 将 void* -&gt; obj* </span></span><br><span class="line">        obj *q = <span class="keyword">reinterpret_cast</span>&lt;obj *&gt;(p);</span><br><span class="line">		<span class="comment">// 2：根据内存的大小确定区块 </span></span><br><span class="line">        obj *<span class="keyword">volatile</span> *my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">		<span class="comment">// 3：将 q 的下一区块指向当前 my_free_list 指向的内存</span></span><br><span class="line">        q-&gt;free_list_link = *my_free_list;</span><br><span class="line">		<span class="comment">// 4：更新 my_free_list 为 q</span></span><br><span class="line">        *my_free_list = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/C++_Language/STL/Allocator/区块回收_纳入freelist.png" style="zoom:50%"></p><center><strong>图 5</strong> 区块回收，纳入 <i>free-list</i></center><blockquote><p>《STL源码剖析》 — P64 - P65</p></blockquote><hr><h5 id="2-2-3-4-空间重配置函数-reallocate"><a href="#2-2-3-4-空间重配置函数-reallocate" class="headerlink" title="2.2.3.4 空间重配置函数 reallocate()"></a>2.2.3.4 空间重配置函数 <code>reallocate()</code></h5><p>根据新旧内存需求的大小关系可以分为五种情况，分别对应这三种处理方式。</p><ul><li>① <em>old_sz &gt; 128, new_sz &gt; 128​</em> ，直接使用 <code>realloc()</code> ；</li><li>② <code>ROUND_UP(old_sz)</code> == <code>ROUND_UP(new_sz)</code> <em>&lt;= 128​</em>：直接返回原内存指针即可；</li><li><code>ROUND_UP(old_sz)</code> != <code>ROUND_UP(new_sz)</code> ，统一调用 <code>allocate()</code> 函数，只是内部根据 <em>new_sz</em> 的大小使用不同的配置器。<ul><li>③ <em>old_sz &gt; 128, new_sz &lt;= 128</em> ：则会使用二级配置器；</li><li>④ <em>old_sz &lt;= 128, new_sz &gt; 128</em> ：则会使用一级配置器；</li><li>⑤ <em>old_sz &lt;= 128, new_sz &lt;= 128</em> ：则会使用二级配置器；</li></ul></li></ul><p><strong><font color="FF8888">注意</font></strong>：情况 ① 中包含了 <code>ROUND_UP(old_sz)</code> == <code>ROUND_UP(new_sz)</code> <em>&gt; 128</em></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">__default_alloc::reallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> old_sz, <span class="keyword">size_t</span> new_sz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *result;</span><br><span class="line">    <span class="keyword">size_t</span> copy_sz;</span><br><span class="line">    <span class="comment">// 1. old_sz &gt; 128,  new_sz &gt; 128   直接使用 realloc()</span></span><br><span class="line">    <span class="keyword">if</span> (old_sz &gt; <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(__MAX_BYTES) &amp;&amp;</span><br><span class="line">        new_sz &gt; <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(__MAX_BYTES))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">realloc</span>(p, new_sz);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. (ROUND_UP(old_sz) == ROUND_UP(new_sz) &lt;= 128</span></span><br><span class="line">    <span class="keyword">if</span> (ROUND_UP(old_sz) == ROUND_UP(new_sz)) <span class="keyword">return</span> p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. old_sz &gt; 128,  new_sz &lt;= 128 :  则会使用二级配置器</span></span><br><span class="line">    <span class="comment">// 4. old_sz &lt;= 128, new_sz &gt; 128  :  则会使用一级配置器</span></span><br><span class="line">    <span class="comment">// 5. old_sz &lt;= 128, new_sz &lt;= 128 :  则会使用二级配置器</span></span><br><span class="line">    result = allocate(new_sz);</span><br><span class="line">    <span class="comment">// 找到 copy_sz, 即 new_sz 和 old_sz 的最小值</span></span><br><span class="line">    copy_sz = new_sz &gt; old_sz ? old_sz : new_sz;</span><br><span class="line">    <span class="comment">// 将原有内容复制到新内存中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(result, p, copy_sz);</span><br><span class="line">    <span class="comment">// 释放旧内存</span></span><br><span class="line">    deallocate(p, old_sz);</span><br><span class="line">    <span class="comment">// 返回新内存</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MiniSTL / Allocator / subAllocation / alloc.h : <code>reallocate()</code></p><p><a href="https://www.it610.com/article/1289144097491197952.htm" target="_blank" rel="noopener">内存池技术（三）</a> 最后 <code>mem_realloc()</code> 讲解</p><p>《STL源码剖析》 — P62</p></blockquote><hr><h5 id="2-2-3-5-重新填充-refill"><a href="#2-2-3-5-重新填充-refill" class="headerlink" title="2.2.3.5 重新填充 refill()"></a>2.2.3.5 重新填充 <code>refill()</code></h5><p><code>refill()</code> 的工作就是，从内存池中获取内存。主要通过 <code>chunk_alloc()</code> 函数来获取内存。默认获取 20 个区块内存，由于内存不足，可能会小于这个数字，会根据获得内存的不同进行不同的处理。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当free_list无可用区块时，重新填充空间</span></span><br><span class="line"><span class="comment">// 新空间取自内存池，默认获取 20 个节点(区块)</span></span><br><span class="line"><span class="comment">// 若内存池不足，则获取的将小于 20</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">__default_alloc::refill</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123; <span class="comment">/* 这里的 n 是 8 的倍数 */</span></span><br><span class="line">    <span class="keyword">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 尝试调用 chunk_alloc,注意 nobjs 以 pass-by-reference 传入</span></span><br><span class="line">    <span class="keyword">char</span> *chunk = chunk_alloc(n, nobjs);</span><br><span class="line">    obj *<span class="keyword">volatile</span> *my_free_list;</span><br><span class="line">    obj *result;</span><br><span class="line">    obj *current_obj, *next_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若只获取了一个区块则直接分配给调用者，不加入free_list</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span> (chunk);</span><br><span class="line"></span><br><span class="line">    my_free_list = free_list + FREELIST_INDEX(n);</span><br><span class="line">    <span class="comment">// 在 chunk 空间内建立free_list</span></span><br><span class="line">    result = <span class="keyword">reinterpret_cast</span>&lt;obj *&gt;(chunk);</span><br><span class="line">    <span class="comment">// 引导 free_list 指向内存池分配的空间</span></span><br><span class="line">    <span class="comment">// chunk 指向的内存直接分给用户，free_list指向剩下（19或更少）的区块</span></span><br><span class="line">    *my_free_list = next_obj = <span class="keyword">reinterpret_cast</span>&lt;obj *&gt;(chunk + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;; ++i) &#123;</span><br><span class="line">        current_obj = next_obj;</span><br><span class="line">        next_obj =</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;obj *&gt;(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span> *&gt;(next_obj) + n);</span><br><span class="line">        <span class="comment">// 分配到最后时候</span></span><br><span class="line">		<span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">            current_obj-&gt;free_list_link = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 退出</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current_obj-&gt;free_list_link = next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>《STL源码剖析》 — P65 - P66</p></blockquote><hr><h5 id="2-2-3-6-内存池"><a href="#2-2-3-6-内存池" class="headerlink" title="2.2.3.6 内存池"></a>2.2.3.6 内存池</h5><p>从内存池中取空间给 <em>free-list</em> 使用，是 <code>chunk_alloc()</code> 的工作。在 <code>chunk_alloc()</code>之前需要明确内存池的结构。内存池的结构定义如下，图示如图 6 所示。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chunk allocation state</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *start_free;  <span class="comment">// 内存池起始位置，只在chunk_alloc()中变化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *end_free;    <span class="comment">// 内存池结束位置，只在chunk_alloc()中变化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员初始化(类外)</span></span><br><span class="line"><span class="keyword">char</span> *__default_alloc::start_free = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">char</span> *__default_alloc::end_free = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc::heap_size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="/C++_Language/STL/Allocator/内存池.png" style="zoom:50%"></p><center><strong>图 6</strong> 内存池简图</center><p><code>chunk_alloc()</code> 是内存池的关键函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">__default_alloc::chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> &amp;nobjs)</span> </span>&#123; <span class="comment">// size为 8 的整数倍</span></span><br><span class="line">    <span class="keyword">char</span> *result;</span><br><span class="line">    <span class="keyword">size_t</span> total_bytes = <span class="built_in">size</span> * nobjs;  <span class="comment">// 所需要分配的内存</span></span><br><span class="line">    <span class="keyword">size_t</span> bytes_left = end_free - start_free;  <span class="comment">// 内存池剩余空间</span></span><br><span class="line">    <span class="comment">/* ...</span></span><br><span class="line"><span class="comment">       ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据内存池的剩余空间与客端需求的关系，有<strong>三个</strong>处理路径：</p><ul><li>所需要分配的内存足够</li><li>容量至少满足一个区块的需求</li><li>内存池一个区块都无法满足提供</li></ul><p><strong><font color="F08F00">1. 所需要分配的内存足够</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 容量满足需求</span></span><br><span class="line"><span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">    <span class="comment">// 更新 start_free, 并返回内存指针</span></span><br><span class="line">    result = start_free;</span><br><span class="line">    start_free += total_bytes;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="F08F00">2. 容量至少满足一个区块的需求</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 容量至少满足一个区块需求</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt; <span class="built_in">size</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新 nobjs, start_free, 并返回内存指针</span></span><br><span class="line">    nobjs = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(bytes_left / <span class="built_in">size</span>);</span><br><span class="line">    total_bytes = <span class="built_in">size</span> * nobjs;</span><br><span class="line">    result = start_free;</span><br><span class="line">    start_free += total_bytes;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="F08F00">3. 内存池一个区块都无法满足提供</font></strong></p><p><code>行：5</code> 此时扩大需求量，新需求量是原需求量的<strong>二倍</strong>与现有内存池大小的<strong>十六分之一</strong>之和。</p><p><code>行：7-12</code>并做碎片资源回收操作，将内存池中碎片资源加入到对应的自由链表中。</p><p><code>行：14</code> 利用 <strong>malloc</strong> 函数向 <em>heap</em> 中申请所需内存</p><p>由于 <strong>malloc</strong> 的使用，会存在两种情况</p><ul><li><em>heap</em> 空间充足</li><li><em>heap</em> 空间不够</li></ul><p><strong>前者</strong> 直接更新部分参数，并递归调用自身以修正 <em>nobjs</em>，最终返回所需内存，结束调用。（递归操作必定会进入<em>if_else</em> 语句中，下同）</p><p><strong>后者</strong></p><ul><li>会在大于 <em>size</em> 的自由链表中，尝试分配所需的区块，如果成功找到，则回收至内存池，并递归调用自身以修正 <em>nobjs</em>，最终返回所需内存，结束调用。</li><li>如果自由链表中也没有内存，则会调用一级配置器，尝试调用一级配置器观察其能否分配内存，或抛出异常。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. 内存池一个区块都无法提供</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 向 heap 申请注入的内存，heap_size 将随着配置次数增加而增加</span></span><br><span class="line">    <span class="comment">// 扩大需要量,新需求量是原需求量的二倍与现有内存池大小的16分之一之和</span></span><br><span class="line">    <span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);  </span><br><span class="line">    <span class="comment">// 当前内存池还有一部分内存，为了不浪费分配给对应的 free_list (最少都为 8)</span></span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 该操作与回收资源类似</span></span><br><span class="line">        obj *<span class="keyword">volatile</span> *my_free_list = free_list + FREELIST_INDEX(bytes_left);</span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;obj *&gt;(start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line">        *my_free_list = <span class="keyword">reinterpret_cast</span>&lt;obj *&gt;(start_free);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置 heap 空间以补充内存池 (使用 malloc 函数)</span></span><br><span class="line">    start_free = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span> *&gt;(<span class="built_in">malloc</span>(bytes_to_get));</span><br><span class="line">    <span class="keyword">if</span> (!start_free) &#123;</span><br><span class="line">        <span class="comment">// heap 空间不足，malloc 失败</span></span><br><span class="line">        obj *<span class="keyword">volatile</span> *my_free_list;</span><br><span class="line">        obj *p;</span><br><span class="line">        <span class="comment">// 1. 先在 free_list 中检查是否有符合需求的区块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="built_in">size</span>; i &lt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(__MAX_BYTES);</span><br><span class="line">             i += <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(__ALIGN)) &#123;</span><br><span class="line">            my_free_list = free_list + FREELIST_INDEX(i);</span><br><span class="line">            p = *my_free_list;</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                <span class="comment">// 存在足以分配的区块</span></span><br><span class="line">                *my_free_list = p-&gt;free_list_link;  <span class="comment">// 抽离当前区块</span></span><br><span class="line">                start_free = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span> *&gt;(p);</span><br><span class="line">                end_free = start_free + i;</span><br><span class="line">                <span class="comment">// 递归调用以修正 nobjs，此时必然进入 else_if 分支</span></span><br><span class="line">                <span class="keyword">return</span> (chunk_alloc(<span class="built_in">size</span>, nobjs));  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end_free = <span class="literal">nullptr</span>;  <span class="comment">// 到处都找不到内存</span></span><br><span class="line">        <span class="comment">// 调用一级配置器观察其能否分配内存，或抛出异常</span></span><br><span class="line">        start_free = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span> *&gt;(malloc_alloc::allocate(bytes_to_get));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// heap 空间充足会运行到该步骤</span></span><br><span class="line">    heap_size += bytes_to_get;  <span class="comment">// 已占用的堆内存</span></span><br><span class="line">    end_free = start_free + bytes_to_get;</span><br><span class="line">    <span class="keyword">return</span> chunk_alloc(<span class="built_in">size</span>, nobjs);  <span class="comment">// 调用自身以修正 nobjs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/C++_Language/STL/Allocator/内存池实际操作结果.png" style="zoom:60%"></p><center><strong>图 7</strong> 内存池实际操练结果</center><blockquote><p>《STL源码剖析》 — P66 - P69</p></blockquote><hr><h3 id="2-3-内存基本处理工具-uninitialized-h"><a href="#2-3-内存基本处理工具-uninitialized-h" class="headerlink" title="2.3 内存基本处理工具 uninitialized.h"></a>2.3 内存基本处理工具 uninitialized.h</h3><h4 id="2-3-1-头文件"><a href="#2-3-1-头文件" class="headerlink" title="2.3.1 头文件"></a>2.3.1 头文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;        // 调用memove()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"construct.h"</span>    <span class="comment">// 调用构造函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stl_algobase.h"</span> <span class="comment">// 调用 copy()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stl_iterator.h"</span> <span class="comment">// 迭代器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"typeTraits.h"</span>   <span class="comment">// 萃取机</span></span></span><br></pre></td></tr></table></figure><p>关键的三个函数：</p><ul><li><code>uninitialized_copy()</code></li><li><code>uninitialized_fill()</code></li><li><code>uninitialized_fill_n()</code></li></ul><h4 id="2-3-2-uninitialized-copy"><a href="#2-3-2-uninitialized-copy" class="headerlink" title="2.3.2 uninitialized_copy()"></a>2.3.2 <code>uninitialized_copy()</code></h4><p>该函数有三个重载版本，分别是一个泛化版本和两个特化版本</p><p><strong><font color="F08F00">两个特化版本</font></strong>：直接使用 <code>memmove()</code> 移动内存</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//针对char*、wchar_t*存在特化版本 memmove直接移动内存</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> *<span class="title">uninitialized_copy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *first, <span class="keyword">const</span> <span class="keyword">char</span> *last, <span class="keyword">char</span> *result)</span> </span>&#123;</span><br><span class="line">    memmove(result, first, last - first);</span><br><span class="line">    <span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">wchar_t</span> *<span class="title">uninitialized_copy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span> *first, <span class="keyword">const</span> <span class="keyword">wchar_t</span> *last, <span class="keyword">wchar_t</span> *result)</span> </span>&#123;</span><br><span class="line">    memmove(result, first, <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>) * (last - first));</span><br><span class="line">    <span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="F08F00">泛化版本</font></strong>：需要使用<strong>萃取机</strong>获得型别，后通过不同的型别判断使用何种接口函数。<strong>(又是两个特化)</strong></p><p><strong>型别</strong>：<em>_true_type， _false_type</em></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> <span class="title">uninitialized_copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                          <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                          <span class="title">ForwardIterator</span> <span class="title">result</span>) &#123;</span></span><br><span class="line">    <span class="keyword">using</span> isPODType =</span><br><span class="line">        <span class="keyword">typename</span> _type_traits&lt;<span class="keyword">value_type_t</span>&lt;InputIterator&gt;&gt;::is_POD_type;</span><br><span class="line">    <span class="keyword">return</span> __uninitialized_copy_aux(first, last, result, isPODType());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口函数</strong>：<code>__uninitialized_copy_aux()</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _true_type 说明 trivial 类型，直接调用 STL 中 copy 函数即可</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> __<span class="title">uninitialized_copy_aux</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                                <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                                <span class="title">ForwardIterator</span> <span class="title">result</span>,</span></span><br><span class="line"><span class="class">                                                _<span class="title">true_type</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> MiniSTL::copy(first, last, result);  <span class="comment">// in stl_algobase.h</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// _true_type 说明 non-trivial 类型，使用构造函数来填充</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> __<span class="title">uninitialized_copy_aux</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                                <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                                <span class="title">ForwardIterator</span> <span class="title">result</span>,</span></span><br><span class="line"><span class="class">                                                _<span class="title">false_type</span>) &#123;</span></span><br><span class="line">    ForwardIterator cur = result;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++cur, ++first) construct(&amp;*cur, *first);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">注意</font></strong>：(下同)</p><p>is_POD_type 存在两种状态，<em>_true_type, false_type</em>，由萃取机获得。</p><p><em>_true_type</em> 说明 <em>trivial</em><br>如果这个类<strong>都是</strong> <em>trivial ctor / dtor / copy / assignment</em> 函数<br>我们对这个类进行构造、析构、拷贝和赋值时可以采用最有效率的方法，不调用无所事事正真的那些 <em>ctor / dtor</em>等，而直接采用内存操作如 <em>malloc()、memcpy(), memmove()</em>等提高性能。这也是SGI STL内部干的事情。</p><p><em>_false_type 也就是 non trivial</em><br>那么上面的四种函数有(<em>ctor / dtor / copy / assignment</em>) 是 <em>non - trivial</em> 函数，比如 <em>non-trivial ctor、non - trivial copy</em> ，也就是说有意义的函数，里面有一下必要的操作，比如类成员的初始化，释放内存等。这时候只能调用对应的 ctor，copy…</p><p><img src="/C++_Language/STL/Allocator/uni_copy.png" style="zoom:50%"></p><center><strong>图 8</strong> <i>uninitialized_copy()</i> 的泛型版本与特化版本</center><blockquote><p>可以参考 <a href="https://blog.csdn.net/francisapp/article/details/77063819?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">C++ trivial、non-trivial及POD类型</a></p><p>“typeTraits.h” 头文件中有详细的分类</p><p>《STL源码剖析》 — P70, P73 - P75</p></blockquote><hr><h4 id="2-3-3-uninitialized-fill"><a href="#2-3-3-uninitialized-fill" class="headerlink" title="2.3.3 uninitialized_fill()"></a>2.3.3 <code>uninitialized_fill()</code></h4><p>该函数是一个泛化版本，但是利用萃取机又可以分为两个特化的接口函数。</p><p><strong><font color="F08F00">泛化版本</font></strong>：需要使用<strong>萃取机</strong>获得型别，后通过不同的型别判断使用何种接口函数。<strong>(两个特化)</strong></p><p><strong>型别</strong>：<em>_true_type， _false_type</em></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">uninitialized_fill</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                               <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">value</span>) &#123;</span></span><br><span class="line">    <span class="keyword">using</span> isPODType =</span><br><span class="line">        <span class="keyword">typename</span> _type_traits&lt;<span class="keyword">value_type_t</span>&lt;ForwardIterator&gt;&gt;::is_POD_type;</span><br><span class="line">    __uninitialized_fill_aux(first, last, value, isPODType());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口函数</strong>： <code>__uninitialized_fill_aux()</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _true_type 说明 trivial 类型，直接调用 STL 中 fill 函数即可</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">uninitialized_fill_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                     <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">value</span>,</span></span><br><span class="line"><span class="class">                                     _<span class="title">true_type</span>) &#123;</span></span><br><span class="line">    MiniSTL::<span class="built_in">fill</span>(first, last, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// _true_type 说明 non-trivial 类型，使用构造函数来填充</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">uninitialized_fill_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">value</span>, _<span class="title">false_type</span>) &#123;</span></span><br><span class="line">    ForwardIterator cur = first;</span><br><span class="line">    <span class="keyword">for</span> (; cur != last; ++cur) construct(&amp;*cur, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/C++_Language/STL/Allocator/uni_fill.png" style="zoom:50%"></p><center><strong>图 9</strong> <i>uninitialized_fill()</i> 的泛型版本与特化版本</center><blockquote><p>《STL源码剖析》 — P71, P75 - P76</p></blockquote><hr><h4 id="2-3-4-uninitialized-fill-n"><a href="#2-3-4-uninitialized-fill-n" class="headerlink" title="2.3.4 uninitialized_fill_n()"></a>2.3.4 <code>uninitialized_fill_n()</code></h4><p>该函数是一个泛化版本，但是利用萃取机又可以分为两个特化的接口函数。</p><p><strong><font color="F08F00">泛化版本</font></strong>：需要使用<strong>萃取机</strong>获得型别，后通过不同的型别判断使用何种接口函数。<strong>(两个特化)</strong></p><p><strong>型别</strong>：<em>_true_type， _false_type</em></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> <span class="title">uninitialized_fill_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                                            <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">value</span>) &#123;</span></span><br><span class="line">    <span class="keyword">using</span> isPODType =</span><br><span class="line">        <span class="keyword">typename</span> _type_traits&lt;<span class="keyword">value_type_t</span>&lt;ForwardIterator&gt;&gt;::is_POD_type; </span><br><span class="line">    <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, value, isPODType());      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口函数</strong>： <code>__uninitialized_fill_n_aux()</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _true_type 说明 trivial 类型，直接调用 STL 中 fill 函数即可</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> __<span class="title">uninitialized_fill_n_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                                                  <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">value</span>, _<span class="title">true_type</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> MiniSTL::fill_n(first, n, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// _true_type 说明 non-trivial 类型，使用构造函数来填充</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> __<span class="title">uninitialized_fill_n_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                                           <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">value</span>, _<span class="title">false_type</span>) &#123;</span></span><br><span class="line">    ForwardIterator cur = first;</span><br><span class="line">    <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; --n, ++cur) construct(&amp;*cur, value);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/C++_Language/STL/Allocator/uni_fill_n.png" style="zoom:50%"></p><center><strong>图 10</strong> <i>uninitialized_fill_n()</i> 的泛型版本与特化版本</center><blockquote><p>《STL源码剖析》 — P71 - P73</p></blockquote><hr><h4 id="2-3-5-SGI-STL的扩展"><a href="#2-3-5-SGI-STL的扩展" class="headerlink" title="2.3.5 SGI_STL的扩展"></a>2.3.5 SGI_STL的扩展</h4><p>SGI_STL的扩展：</p><ul><li><code>uninitializd_copy_copy()</code></li><li><code>uninitialized_copy_fill()</code></li><li><code>uninitialized_fill_copy()</code></li></ul><p><code>uninitializd_copy_copy()</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __uninitialized_copy_copy</span></span><br><span class="line"><span class="comment">// Copies [first1, last1) into [result, result + (last1 - first1)), and</span></span><br><span class="line"><span class="comment">// copies [first2, last2) into [result, result + (last1 - first1) + (last2 -</span></span><br><span class="line"><span class="comment">// first2)).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> <span class="title">uninitialized_copy_copy</span>(<span class="title">InputIterator1</span> <span class="title">first1</span>,</span></span><br><span class="line"><span class="class">                                               <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                                               <span class="title">InputIterator2</span> <span class="title">first2</span>,</span></span><br><span class="line"><span class="class">                                               <span class="title">InputIterator2</span> <span class="title">last2</span>,</span></span><br><span class="line"><span class="class">                                               <span class="title">ForwardIterator</span> <span class="title">result</span>) &#123;</span></span><br><span class="line">    ForwardIterator mid = MiniSTL::uninitialized_copy(first1, last1, result);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MiniSTL::uninitialized_copy(first2, last2, mid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::exception &amp;) &#123;</span><br><span class="line">        destroy(result, mid);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uninitialized_copy_fill()</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// uninitialized_fill_copy</span></span><br><span class="line"><span class="comment">// Fills [result, mid) with x, and copies [first, last) into [mid, mid + (last -</span></span><br><span class="line"><span class="comment">// first)).</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> <span class="title">uninitialized_fill_copy</span>(<span class="title">ForwardIterator</span> <span class="title">result</span>,</span></span><br><span class="line"><span class="class">                                               <span class="title">ForwardIterator</span> <span class="title">mid</span>,</span></span><br><span class="line"><span class="class">                                               <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">val</span>,</span></span><br><span class="line"><span class="class">                                               <span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                               <span class="title">InputIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">    MiniSTL::uninitialized_fill(result, mid, val);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MiniSTL::uninitialized_copy(first, last, mid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::exception &amp;) &#123;</span><br><span class="line">        destroy(result, mid);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uninitialized_fill_copy()</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __uninitialized_copy_fill</span></span><br><span class="line"><span class="comment">// Copies [first1, last1) into [first2, first2 + (last1 - first1)), and fills</span></span><br><span class="line"><span class="comment">// [first2 + (last1 - first1), last2) with x.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">uninitialized_copy_fill</span>(<span class="title">InputIterator</span> <span class="title">first1</span>, <span class="title">InputIterator</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">ForwardIterator</span> <span class="title">first2</span>,</span></span><br><span class="line"><span class="class">                                    <span class="title">ForwardIterator</span> <span class="title">last2</span>, <span class="title">const</span> <span class="title">T</span> &amp;<span class="title">val</span>) &#123;</span></span><br><span class="line">    ForwardIterator mid2 = MiniSTL::uninitialized_copy(first1, last1, first2);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MiniSTL::uninitialized_fill(mid2, last2, val);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::exception &amp;) &#123;</span><br><span class="line">        destroy(first2, mid2);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MiniSTL / Allocator / subAllocation / alloc.h : <code>uninitializd_copy_copy()</code></p><p>MiniSTL / Allocator / subAllocation / alloc.h : <code>uninitializd_fill_copy()</code></p><p>MiniSTL / Allocator / subAllocation / alloc.h : <code>uninitializd_copy_fill()</code></p></blockquote><hr><h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><blockquote><p>《STL源码剖析》</p><p>《Effective C++ 3th》</p><p><a href="https://blog.csdn.net/francisapp/article/details/77063819?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">C++ trivial、non-trivial及POD类型</a></p><p><a href="https://www.it610.com/article/1289144097491197952.htm" target="_blank" rel="noopener">内存池技术（三）</a> 最后 <code>mem_realloc()</code> 讲解</p><p>MiniSTL / Allocator 部分</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>C++_Language</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer -- 动态规划</title>
    <url>/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="剑指offer-—-动态规划"><a href="#剑指offer-—-动态规划" class="headerlink" title="剑指offer — 动态规划"></a>剑指offer — 动态规划</h2><h3 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 10- I. 斐波那契数列</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：递归写法</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(2^N)$，指数级别。</p><p><strong>空间复杂度：</strong>$O(N)$，每一层运算所占用的空间为1，一共要递归 <em>n-1</em> 次；也就是约等于<em>n</em>。</p><p><strong><font color="F08F00">方法二：动态规划</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(N)$，<em>N</em> 为数组长度，一次遍历</p><p>空间复杂度：$O(N )$，<em>dp</em> 数组所需要的额外空间</p><p><strong><font color="F08F00">方法二：动态规划</font></strong>，滚动数组，<strong><font color="FF8888">空间优化</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">            r = (p + q) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为数组长度，一次遍历</p><p><strong>空间复杂度：</strong>$O(1)$，<em>p,q,r</em> 所需的额外常数空间</p><p><strong><font color="F08F00">方法三：矩阵快速幂</font></strong></p><p><a href="https://leetcode-cn.com/problems/fibonacci-number/solution/fei-bo-na-qi-shu-by-leetcode-solution-o4ze/" target="_blank" rel="noopener">斐波那契数_官方题解__方法二：矩阵快速幂</a></p><p><img src="/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/斐波那契矩阵快速幂.png" alt></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = matrix_pow(q, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 求矩阵的 n 次幂</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">matrix_pow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">// 初始化单位矩阵</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// n 存在奇数和偶数两种情况，整个思路同:剑指offer16 数值的整数次方</span></span><br><span class="line">            <span class="comment">// 奇数情况要多乘一次 a</span></span><br><span class="line">            <span class="comment">// a^n = a * (a^(n/2) * a^(n/2))</span></span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                ret = matrix_multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 偶数：a^n = a^(n/2) * a^(n/2)</span></span><br><span class="line">            a = matrix_multiply(a, a);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 二维矩阵乘法公式</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">matrix_multiply</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; c&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">注意</font></strong>：此题使用的快速幂算法与 <a href="https://czgitaccount.github.io/Data_Structure_and_Algorithm/剑指offer/分治算法/">数值的整数次方</a> 相同。</p><p><strong>时间复杂度：</strong>$O(\log N)$，二分的时间复杂度为对数级别。</p><p><strong>空间复杂度：</strong>$O(1)$，<em>res , q, a, ret</em> 等变量都有明确的大小，仅占用常数大小额外空间。</p><p><strong><font color="F08F00">方法四：通项公式</font></strong></p><p><a href="https://leetcode-cn.com/problems/fibonacci-number/solution/fei-bo-na-qi-shu-by-leetcode-solution-o4ze/" target="_blank" rel="noopener">斐波那契数_官方题解__方法三：通项公式</a></p><script type="math/tex;mode=display">F(n) = \frac{1}{\sqrt{5}}[(\frac{1 + \sqrt{5}}{2})^n - (\frac{1 - \sqrt{5}}{2})^n]</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibN = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">        <span class="keyword">return</span> round(fibN / sqrt5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度，空间复杂度</strong>皆为 $O(1)$。</p><h3 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">剑指 Offer 10- II. 青蛙跳台阶问题</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><p><strong>Solution</strong></p><p>与斐波那契数列本质相同，更多解法同上。以下是一个常规的动态规划+滚动数组优化空间解法。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">            r = (p + q) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为数组长度，一次遍历</p><p><strong>空间复杂度：</strong>$O(1)$，<em>p,q,r</em> 所需的额外常数空间</p><h3 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">剑指 Offer 19. 正则表达式匹配</a></h3><p>Difficulty: <strong><font color="FF0000">困难</font></strong></p><p>请实现一个函数用来匹配包含<code>&#39;. &#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母以及字符 <code>.</code> 和 <code>*</code>，无连续的 <code>&#39;*&#39;</code>。</li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.<span class="built_in">size</span>() + <span class="number">1</span>, n = p.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 初始化首行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; n; j += <span class="number">2</span>)</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">'*'</span>;</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 模式串是否为 *</span></span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j - <span class="number">2</span>]) dp[i][j] = <span class="literal">true</span>;  </span><br><span class="line">                    <span class="comment">// 当前模式串字符前一位与当前匹配串字符相同，或者为 . 则取决于正上方情况                            </span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">'.'</span>) dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// // 当前模式串字符与当前匹配串字符相同，或者为 . 则取决于左斜上方情况</span></span><br><span class="line">                    <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'.'</span> || s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(MN)$，其中 <em>M</em> 为匹配串的长度，<em>N</em> 为模式串的长度。</p><p><strong>空间复杂度：</strong>$O(MN)$，<em>dp</em> 矩阵所需要的额外空间消耗。</p><h3 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">剑指 Offer 42. 连续子数组的最大和</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>-100 &lt;= arr[i] &lt;= 100</code></li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> result = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// dp[i - 1] &lt; 0 的情况,dp[i] = nums[i],也就是重新从nums[i]开始遍历</span></span><br><span class="line">            <span class="comment">// dp[i - 1] &gt; 0 的情况,dp[i] = dp[i - 1] + nums[i],考虑前者仍然对其有增益效果</span></span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="comment">// 每轮更新最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为数组 <em>nums</em> 的长度。</p><p><strong>空间复杂度：</strong>$O(N)$，<em>dp</em> 所需要的额外空间消耗。</p><h3 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 46. 把数字翻译成字符串</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= num &lt; 2^31</code></li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// num 大于两位数</span></span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            y = num % <span class="number">10</span>; <span class="comment">// 倒数第一位</span></span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            x = num % <span class="number">10</span>; <span class="comment">// 倒数第二位</span></span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">10</span> * x + y;  <span class="comment">// 最后两位构成的数字</span></span><br><span class="line">            <span class="comment">// 如果该数字满足构成字母的要求，也即是符合 10 &lt;= tmp &lt;= 25</span></span><br><span class="line">            <span class="keyword">int</span> c = (tmp &gt;= <span class="number">10</span> &amp;&amp; tmp &lt;= <span class="number">25</span>) ? a + b : a;</span><br><span class="line">            b = a;</span><br><span class="line">            a = c;</span><br><span class="line">            y = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(log_{10}N)$，即 <em>num</em> 的位数。</p><p><strong>空间复杂度：</strong>$O(1)$，<em>a, b, c, x, y, tmp</em>, 常数个变量所需的额外空间。</p><h3 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 47. 礼物的最大价值</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt; grid.length &lt;= 200</code></li><li><code>0 &lt; grid[0].length &lt;= 200</code></li></ul><p><strong>Solution</strong></p><p><strong><font color="F08F00">动态规划</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		<span class="comment">// 初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前元素取值由其上方和左方元素决定</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(M \times N)$，<em>M</em> 为行数，<em>N</em> 为列数。</p><p><strong>空间复杂度：</strong>$O(M \times N)$ ，<em>dp</em> 所占用的额外空间。</p><p><strong><font color="F08F00">动态规划</font></strong>，<strong><font color="FF8888">空间优化</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) <span class="comment">// 初始化第一行</span></span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) <span class="comment">// 初始化第一列</span></span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                grid[i][j] += <span class="built_in">max</span>(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j]);</span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(M \times N)$，<em>M</em> 为行数，<em>N</em> 为列数。</p><p><strong>空间复杂度：</strong>$O(1)$ ，原地操作。</p><h3 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 48. 最长不含重复字符的子字符串</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>s.length &lt;= 40000</code></li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">-1</span>, res = <span class="number">0</span>; <span class="comment">// i = -1，从边界外开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(s[j]) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// i 为最接近 j 时，重复的位置</span></span><br><span class="line">                i = <span class="built_in">max</span>(mp[s[j]], i);</span><br><span class="line">            &#125;</span><br><span class="line">            mp[s[j]] = j; <span class="comment">// 更新字母的位置信息</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, j - i);  <span class="comment">// 更新最大长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为字符串长度，一次遍历即可</p><p><strong>空间复杂度：</strong>$O(1)$，哈希表最多存26个字母，因此是仅需要常数额外空间。</p><h3 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 49. 丑数</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li><code>1</code> 是丑数。</li><li><code>n</code> <strong>不超过</strong>1690。</li></ol><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n2 = dp[a] * <span class="number">2</span>, n3 = dp[b] * <span class="number">3</span>, n5 = dp[c] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(<span class="built_in">min</span>(n1, n2), n3);</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == n2) a++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == n3) b++;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == n5) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(n)$</p><p><strong>空间复杂度：</strong>$O(n)$，<em>dp</em> 额外所需的空间复杂度</p><h3 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 60. n个骰子的点数</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>1 &lt;= n &lt;= 11</code></p><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">6</span>, <span class="number">1.0</span> / <span class="number">6.0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">tmp</span><span class="params">(<span class="number">5</span> * i + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dp.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++) &#123;</span><br><span class="line">                    tmp[j + k] += dp[j] / <span class="number">6.0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/n个骰子点数时间空间复杂度.png" alt></p><p><strong><font color="FF8888">参考</font></strong>: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/ozsdss/" target="_blank" rel="noopener">图解算法数据结构 - 剑指offer60)</a></p><h3 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">剑指 Offer 63. 股票的最大利润</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= 数组长度 &lt;= 10^5</code></p><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minPrice = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> maxPro = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 找到当前最低值</span></span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, prices[i]);</span><br><span class="line">            maxPro = <span class="built_in">max</span>(maxPro, prices[i] - minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N )$，N 为 prices 长度，一次遍历</p><p><strong>空间复杂度：</strong>$O(1 )$，<em>minPrice</em> 和 <em>maxPro</em> 所需的</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/" target="_blank" rel="noopener">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 (leetcode-cn.com)</a> 官方题解</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Data_Structure_and_Algorithm</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer -- 数据结构</title>
    <url>/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="剑指offer-—-数据结构"><a href="#剑指offer-—-数据结构" class="headerlink" title="剑指offer — 数据结构"></a>剑指offer — 数据结构</h2><h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">剑指 Offer 05. 替换空格</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= s 的长度 &lt;= 10000</code></p><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：正序修改</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                res += <span class="string">"%20"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为 <em>s</em> 的长度。</p><p><strong>空间复杂度：</strong>$O(N)$，<em>res</em> 所需要的额外空间。</p><p><strong><font color="F08F00">方法二：反向修改</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 统计空格的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">' '</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        s.resize(len + <span class="number">2</span> * count); <span class="comment">// 修改 s 的长度</span></span><br><span class="line">        <span class="comment">// 双指针倒序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">' '</span>) &#123;</span><br><span class="line">                s[j] = s[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[j] = <span class="string">'0'</span>;</span><br><span class="line">                s[j - <span class="number">1</span>] = <span class="string">'2'</span>;</span><br><span class="line">                s[j - <span class="number">2</span>] = <span class="string">'%'</span>;</span><br><span class="line">                j -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为 <em>s</em> 的长度。</p><p><strong>空间复杂度：</strong>$O(1)$，由于原地扩展 <em>s</em> 的长度，因此使用常数的额外空间。</p><h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 06. 从尾到头打印链表</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= 链表长度 &lt;= 10000</code></p><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：正序输入，反转数组</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            res.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为链表长度，一次遍历链表。</p><p><strong>空间复杂度：</strong>$O(N)$，<em>res</em> 所需要的额外空间。</p><p><strong><font color="F08F00">方法二：辅助栈</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stk.push(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty()) &#123;</span><br><span class="line">            res.push_back(stk.top());</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为链表长度，一次遍历链表。</p><p><strong>空间复杂度：</strong>$O(N)$，<em>stk</em> 所需要的额外空间。</p><p><strong><font color="F08F00">方法三：递归</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="comment">// 递归在 push 之前</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = reversePrint(head-&gt;next);</span><br><span class="line">        a.push_back(head-&gt;val); </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为链表长度，一次遍历链表。</p><p><strong>空间复杂度：</strong>$O(N)$，系统递归所需要使用的栈空间。</p><h3 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= values &lt;= 10000</code></li><li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li></ul><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：每次delete，都进行倒出倒入操作</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 压栈</span></span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  1 空 则返回 - 1</span></span><br><span class="line">        <span class="keyword">if</span> (stack1.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 将 1 中元素倒入 2</span></span><br><span class="line">        <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录 2 中栈顶元素为结果</span></span><br><span class="line">        <span class="keyword">int</span> res = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="comment">// 倒回去</span></span><br><span class="line">        <span class="keyword">while</span> (!stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            stack1.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>插入操作 $O(1)$，删除操作 $O(N)$</p><p><strong>空间复杂度：</strong>$O(N)$</p><p><strong><font color="F08F00">方法二：仅输出栈空调用倒入操作，无倒回操作</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1; <span class="comment">// 输入栈</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2; <span class="comment">// 输出栈</span></span><br><span class="line">    CQueue() &#123;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 压栈</span></span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果输出栈为空，则需要倒入输入栈的数据</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                stack2.push(stack1.top());</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果此时仍然为空，则说明没有元素，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 否则，弹出输出栈栈顶元素即可</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> deleteItem = stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> deleteItem;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>插入操作 $O(1)$，删除操作 $O(N)$</p><p><strong>空间复杂度：</strong>$O(N)$</p><h3 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 20. 表示数值的字符串</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p><p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p><ol><li>若干空格</li><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li><li>若干空格</li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li><li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>至少一位数字</li></ol><p>部分<strong>数值</strong>列举如下：</p><ul><li><code>[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]</code></li></ul><p>部分<strong>非数值</strong>列举如下：</p><ul><li><code>[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;0&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;e&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;.&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;    .1  &quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，空格 <code>&#39; &#39;</code> 或者点 <code>&#39;.&#39;</code> 。</li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 24. 反转链表</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= 节点个数 &lt;= 5000</code></p><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：双指针</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            ListNode* post = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = post;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为链表长度，一次遍历链表。</p><p><strong>空间复杂度：</strong>$O(1)$，<em>pre, cur, post</em> 所需要常数级的额外空间。</p><p><strong><font color="F08F00">方法二：递归</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(head, <span class="literal">nullptr</span>);           <span class="comment">// 调用递归并返回</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">recur</span><span class="params">(ListNode* cur, ListNode* pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> pre;        <span class="comment">// 终止条件</span></span><br><span class="line">        ListNode* res = recur(cur-&gt;next, cur); <span class="comment">// 递归后继节点</span></span><br><span class="line">        cur-&gt;next = pre;                       <span class="comment">// 修改节点引用指向</span></span><br><span class="line">        <span class="keyword">return</span> res;                            <span class="comment">// 返回反转链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为链表长度，一次遍历链表。</p><p><strong>空间复杂度：</strong>$O(N)$，遍历链表的递归深度达到 <em>N</em>，系统使用 <em>O(N)</em> 大小的额外空间。</p><h3 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">剑指 Offer 30. 包含min函数的栈</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>各函数的调用总次数不超过 20000 次</li></ol><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：vector 实现</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minN;</span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        minN.push_back(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(x);</span><br><span class="line">        <span class="comment">// 输入的x更小</span></span><br><span class="line">        <span class="keyword">if</span> (minN.back() &gt; x) &#123;</span><br><span class="line">            minN.push_back(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 该步骤不能省略</span></span><br><span class="line">            minN.push_back(minN.back());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minN.pop_back();</span><br><span class="line">        <span class="built_in">stack</span>.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span>.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> minN.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong><font color="F08F00">方法二：stack 实现</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line">    MinStack() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s.push(x);</span><br><span class="line">        <span class="keyword">if</span>(m.empty() || x &lt;= m.top()) m.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.top() == m.top())  m.pop();</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：$O(1)$，<em>push, pop, top, min</em>，皆是 $O(1)$。</p><p><strong>空间复杂度</strong>：$O(N)$，需要额外的 <em>vector</em> 空间，或者 <em>stack</em> 空间。</p><h3 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 35. 复杂链表的复制</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt></strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-10000 &lt;= Node.val &lt;= 10000</code></li><li><code>Node.random</code> 为空（null）或指向链表中的节点。</li><li>节点数目不超过 1000 。</li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 58 - II. 左旋转字符串</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= k &lt; s.length &lt;= 10000</code></li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        reverse(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + n);</span><br><span class="line">        reverse(s.<span class="built_in">begin</span>() + n, s.<span class="built_in">end</span>());</span><br><span class="line">        reverse(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为 <em>s</em> 的长度，共两次遍历 <em>s</em>。</p><p><strong>空间复杂度：</strong>$O(1)$，C++ 原地字符串操作，使用常数大小额外空间。</p><h3 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - I. 滑动窗口的最大值</a></h3><p>Difficulty: <strong><font color="FF0000">困难</font></strong></p><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>你可以假设 _k_ 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - II. 队列的最大值</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的<strong>均摊</strong>时间复杂度都是O(1)。</p><p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</code></li><li><code>1 &lt;= value &lt;= 10^5</code></li></ul><p><strong>Solution</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 67. 把字符串转换成整数</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p><strong>说明：</strong></p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2<sup>31</sup>, 2<sup>31 </sup>− 1]。如果数值超过这个范围，请返回 INT_MAX (2<sup>31 </sup>− 1) 或 INT_MIN (−2<sup>31</sup>) 。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/" target="_blank" rel="noopener">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 (leetcode-cn.com)</a> 官方题解</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Data_Structure_and_Algorithm</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer -- 分治算法</title>
    <url>/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="剑指offer-—-分治算法"><a href="#剑指offer-—-分治算法" class="headerlink" title="剑指offer — 分治算法"></a>剑指offer — 分治算法</h2><h3 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 07. 重建二叉树</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= 节点个数 &lt;= 5000</code></p><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            inMap[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; inMap; <span class="comment">// 用来存 index 对应的 inorder 值</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preLeft &gt; preRight) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 根节点是前序遍历的第一个元素</span></span><br><span class="line">        <span class="keyword">int</span> rootIndex = preLeft; <span class="keyword">int</span> rootValue = preorder[rootIndex];</span><br><span class="line">        <span class="keyword">int</span> rootIndexInMap = inMap[rootValue];   <span class="comment">// 获得根节点在inorder中索引位置</span></span><br><span class="line">        <span class="keyword">int</span> leftSize = rootIndexInMap - inLeft; <span class="comment">// 获得左子树的节点树</span></span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootValue); <span class="comment">// 创建根节点</span></span><br><span class="line">        root-&gt;left = buildTree(preorder, inorder, preLeft + <span class="number">1</span>, preLeft + leftSize, inLeft, rootIndexInMap - <span class="number">1</span>);   <span class="comment">// 创建左节点</span></span><br><span class="line">        root-&gt;right = buildTree(preorder, inorder, preLeft + leftSize + <span class="number">1</span>, preRight, rootIndexInMap + <span class="number">1</span>, inRight);  <span class="comment">// 创建右节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为节点数</p><p><strong>空间复杂度：</strong>$O(N)$，哈希表占用空间 $O(N)$，树创建过程中 $O(\log N) \backsim O(N)$</p><h3 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">剑指 Offer 16. 数值的整数次方</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>实现 ，即计算 x 的 n 次幂函数（即，x<sup>n</sup>）。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">输出：9.26100</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li>$-2^{31} \leq n \leq 2^{31} - 1$</li><li>$-10^4 \leq x^n \leq 10^4$</li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0.0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">long</span> b = n;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 负数情况</span></span><br><span class="line">        <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = -b;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="comment">// 需要分奇偶情况，奇数情况 x^n = x(x^(n/2))^2</span></span><br><span class="line">            <span class="comment">// 偶数情况 x^n = (x^(n/2))^2</span></span><br><span class="line">            <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>; <span class="comment">// 右移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(\log N)$，二分的时间复杂度为对数级别。</p><p><strong>空间复杂度：</strong>$O(1)$，<em>res , b</em> 等变量占用常数大小额外空间。</p><h3 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 17. 打印从1到最大的n位数</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>用返回一个整数列表来代替打印</li><li>n 为正整数</li></ul><p><strong>Solution</strong></p><p><strong><font color="F08F00">1. 不考虑大数问题</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxN = <span class="built_in">pow</span>(<span class="number">10</span>, n);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(maxN - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxN; i++) &#123;</span><br><span class="line">            res[i - <span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度，空间复杂度皆是 $O(10^n)$</p><p><strong><font color="F08F00">2. 考虑大数问题</font></strong></p><p>回溯，排列问题</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        s.resize(n, <span class="string">'0'</span>);  <span class="comment">// 初始化 s</span></span><br><span class="line">        backtracking(<span class="number">0</span>, n, s);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="built_in">end</span>) &#123;</span><br><span class="line">            <span class="comment">// 去除首部0的情况</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] == <span class="string">'0'</span>) j++;</span><br><span class="line">            <span class="keyword">if</span> (j != s.<span class="built_in">size</span>()) nums.push_back(stoi(s.substr(j))); </span><br><span class="line">            <span class="comment">// 本题限制输出vector&lt;int&gt;，所以可以用stoi来转换，</span></span><br><span class="line">            <span class="comment">// 如果输出为vector&lt;string&gt;, 则不需要转换</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// 常见回溯写法</span></span><br><span class="line">            s[idx] = i + <span class="string">'0'</span>;</span><br><span class="line">            backtracking(idx + <span class="number">1</span>, <span class="built_in">end</span>, s);</span><br><span class="line">            s[idx] = <span class="string">'0'</span>; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">注意</font></strong>：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNjY5NTYxNA==&amp;action=getalbum&amp;album_id=1607983171550167042&amp;scene=173&amp;from_msgid=2247485372&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect" target="_blank" rel="noopener">回溯算法</a> 可以看 carl 大佬写的专题！</p><p>时间复杂度：$O(10^n)$，递归生成的排列数量为 $10^n - 1$。</p><p>空间复杂度：$O(10^n)$，中间获得的结果存于 <em>nums</em> 中。</p><h3 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>数组长度 &lt;= 1000</code></li></ol><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：递归写法</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> p = i;</span><br><span class="line">        <span class="comment">// 找到左子树，其中 postorder[j] 代表根节点</span></span><br><span class="line">        <span class="keyword">while</span> (postorder[p] &lt; postorder[j]) p++;</span><br><span class="line">        <span class="keyword">int</span> m = p;   <span class="comment">// m 为左右子树拐点，在右子树中第一个</span></span><br><span class="line">        <span class="comment">// 找到右子树，其中 postorder[j] 代表根节点</span></span><br><span class="line">        <span class="keyword">while</span> (postorder[p] &gt; postorder[j]) p++;</span><br><span class="line">        <span class="comment">// 只有 p 遍历到 根节点，左右子树都递归返回 true 才返回 true</span></span><br><span class="line">        <span class="keyword">return</span> p == j &amp;&amp; recur(postorder, i, m - <span class="number">1</span>) &amp;&amp; recur(postorder, m, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N^2)$，每次调用 <em>recur(i,j)</em> 减去一个根节点，因此递归占用 <em>O(N)</em> ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 <em>O(N)</em> 。</p><p><strong>空间复杂度：</strong>$O(N)$，最差情况下（即当树退化为链表），递归深度将达到 <em>N</em>。</p><p><strong><font color="F08F00">方法二：单调栈</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> root = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = postorder.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postorder[i] &gt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top() &gt; postorder[i]) &#123;</span><br><span class="line">                root = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(postorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，遍历 <em>postorder</em> 所有节点，各节点均入栈/出栈一次，使用 $O(N)$ 时间。</p><p><strong>空间复杂度：</strong>最差情况下，单调栈 <em>stack</em> 存储所有节点，使用 $O(N)$ 额外空间。</p><h3 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">剑指 Offer 51. 数组中的逆序对</a></h3><p>Difficulty: <strong><font color="FF0000">困难</font></strong></p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= 数组长度 &lt;= 50000</code></p><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：暴力解法</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暴力解法 (超时)</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N^2)$，两层遍历</p><p><strong>空间复杂度：</strong>$O(1)$，<em>count</em> 所需的额外空间</p><p><strong><font color="F08F00">方法二：归并排序</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(nums, temp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = mergeSort(nums, temp, left, mid) + mergeSort(nums, temp, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                <span class="comment">// 皆是顺序对</span></span><br><span class="line">                temp[k++] = nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = nums[j++];</span><br><span class="line">                res += mid - i + <span class="number">1</span>; <span class="comment">// 此时 j 所指向的数，与 i 指向及其以后数皆构成逆序对</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 i 还未遍历到 mid，则说明 j == right + 1, </span></span><br><span class="line">        <span class="comment">// 此时虽然 i 指向元素与后半部分元素会构成逆序对, 但是已经在前面计算过了，不用重复</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) temp[k++] = nums[i++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 j 还未遍历到 mid，则说明 i == mid + 1, 此时 j 所指向元素与前半部分元素皆构成顺序对</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) temp[k++] = nums[j++]; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 归并排序常规操作：temp 覆写 nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; k; l++) nums[l + left] = temp[l];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">参考</font></strong> 我自己写的排序算法总结中的归并排序： <a href="https://czgitaccount.github.io/Data_Structure_and_Algorithm/排序算法/">排序算法 | CongZ’s Blog (czgitaccount.github.io)</a></p><p>由于主要思想就是归并排序，故时间复杂度与空间复杂度与归并排序相同。</p><p><strong>时间复杂度：</strong>$O(N\log N)$</p><p><strong>空间复杂度：</strong>$O(N)$</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/" target="_blank" rel="noopener">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 (leetcode-cn.com)</a> 官方题解</p><p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNjY5NTYxNA==&amp;action=getalbum&amp;album_id=1607983171550167042&amp;scene=173&amp;from_msgid=2247485372&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect" target="_blank" rel="noopener">回溯算法__代码随想录</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Data_Structure_and_Algorithm</category>
      </categories>
      <tags>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer -- 查找算法</title>
    <url>/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="剑指offer-—-查找算法"><a href="#剑指offer-—-查找算法" class="headerlink" title="剑指offer — 查找算法"></a>剑指offer — 查找算法</h2><h3 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 03. 数组中重复的数字</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>2 &lt;= n &lt;= 100000</code></p><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：计数方法</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[nums[i]] == <span class="number">1</span>) <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="keyword">else</span> res[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，一次遍历</p><p><strong>空间复杂度：</strong>$O(N)$， res 数组占用额外空间</p><p><strong><font color="F08F00">方法二：原地交换</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="comment">// 只要当前索引位置不是对应的数字，就一直寻找</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">                swap(nums[i], nums[nums[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，一次遍历</p><p><strong>空间复杂度：</strong>$O(1)$， 原地操作，无额外空间消耗。</p><p><strong><font color="F08F00">方法三：替换法</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> index = nums[i] % n;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] &gt;= n) &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[index] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，一次遍历</p><p><strong>空间复杂度：</strong>$O(1)$， 原地操作，无额外空间消耗。</p><p><strong><font color="FF8888">注意</font></strong>：方法二，只能返回随机一个重复值（排列中最靠前的那个重复数字），方法一，方法三可以返回第一个（最小）重复值。</p><h3 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">剑指 Offer 04. 二维数组中的查找</a></h3><p>Difficulty: <strong><font color="F08000">中等</font></strong></p><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><p><strong>限制：</strong></p><p><code>0 &lt;= n &lt;= 1000</code></p><p><code>0 &lt;= m &lt;= 1000</code></p><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 判断是否为空集合</span></span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先从最右上角开始往左下角找</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == matrix[i][j]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 大了则向右找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[i][j]) j--;</span><br><span class="line">            <span class="comment">// 小了则向左找</span></span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N + M)$，其中，<em>N</em> 和 <em>M</em> 分别为矩阵行数和列数，此算法最多循环<em>M</em>+<em>N</em> 次。</p><p><strong>空间复杂度：</strong>$O(1)$，只需要 <em>i， j</em> 两个变量即可。</p><h3 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 11. 旋转数组的最小数字</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：排序</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        sort(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> numbers.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间空间复杂度基于<strong>排序</strong>算法的时间空间复杂度。</p><p><strong><font color="F08F00">方法二：一次遍历</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 也即是 数组中第一个降序的数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &lt; numbers[i - <span class="number">1</span>]) <span class="keyword">return</span> numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，N为数组长度</p><p><strong>空间复杂度：</strong>$O(1)$，无额外空间消耗</p><p><strong><font color="F08F00">方法三：二分查找</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 如果中点元素大于右值 则说明当前翻转点在右侧 (m , j]</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[m] &gt; numbers[j]) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果中点元素小于右值 则说明当前翻转点在左侧 [i , m]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[j]) j = m;</span><br><span class="line">            <span class="comment">// 如果相等，则缩小 右边界 范围即可</span></span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(\log N)$</p><p><strong>空间复杂度：</strong>只需要 <em>i，j，m</em> 变量即可</p><h3 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">剑指 Offer 50. 第一个只出现一次的字符</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= s 的长度 &lt;= 50000</code></p><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：哈希表</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a : s) &#123;</span><br><span class="line">            mp[a - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a : s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[a - <span class="string">'a'</span>] == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，N 为数组长度</p><p><strong>空间复杂度：</strong>$O(1)$，最多 26 个字符</p><p><strong><font color="F08F00">方法二：哈希表优化</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; keys;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; dic;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="comment">// 如果 c 不在 map 里面，将 c push  keys 中</span></span><br><span class="line">            <span class="comment">// key 中包含着非重复的数，最大 26 个</span></span><br><span class="line">            <span class="keyword">if</span>(dic.<span class="built_in">find</span>(c) == dic.<span class="built_in">end</span>())</span><br><span class="line">                keys.push_back(c);</span><br><span class="line">            <span class="comment">// 如果 map 中没有 c，将 map value 置 true</span></span><br><span class="line">            dic[c] = dic.<span class="built_in">find</span>(c) == dic.<span class="built_in">end</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在 keys 中遍历第一次出现 true 即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : keys) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dic[c]) <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间和空间复杂度均与 “方法一” 相同，而具体分析：方法一 需遍历 <code>s</code> 两轮；方法二 遍历 <code>s</code> 一轮，遍历 <code>keys</code> 一轮（ <code>dic, keys</code> 的长度都不大于 26 ）。空间上，方法二多了 <code>keys</code>，但是其长度最大为 26；</p><h3 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>统计一个数字在排序数组中出现的次数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= 数组长度 &lt;= 50000</code></p><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：哈希表</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            mp[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp.<span class="built_in">find</span>(target) == mp.<span class="built_in">end</span>() ? <span class="number">-1</span> : mp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为数组长度，一次遍历构建哈希表。</p><p><strong>空间复杂度：</strong>$O(N)$，哈希表所占额外空间。</p><p><strong><font color="F08F00">方法二：二分查找</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 关键在于如果 &gt;= 情况下都让 right = mid</span></span><br><span class="line">            <span class="comment">// 这样可以找到最左边一个符合条件的位置</span></span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; len &amp;&amp; nums[left++] == target) count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(\log N)$，<em>N</em> 为数组长度。</p><p><strong>空间复杂度：</strong>$O(1)$，<em>left, right, mid, count</em> 几个变量所需的额外空间。</p><h3 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>1 &lt;= 数组长度 &lt;= 10000</code></p><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：一次遍历</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，<em>N</em> 为数组长度</p><p><strong>空间复杂度：</strong>$O(1)$，无需额外空间</p><p><strong><font color="F08F00">方法二：二分查找</font></strong></p><p><strong><font color="FF8888">注意</font>：</strong>看个人喜好选择自己更容易理解的版本，本人更倾向版本二。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();     </span><br><span class="line">        <span class="comment">// 版本一：</span></span><br><span class="line">        <span class="comment">// 取小于等于版本，也就是 ( ] right 可以取到，所以 right = n - 1;</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == mid) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>; <span class="comment">// right 可以取到，所以 mid - 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 版本二：</span></span><br><span class="line">        <span class="comment">// 取小于版本，也就是 ( ) right 不可以取到，所以 right = n;</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == mid) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;  <span class="comment">// right 取不到 等同于 mid - 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(\log N)$，<em>N</em> 为数组长度。</p><p><strong>空间复杂度：</strong>$O(1)$，<em>left, right, mid</em> 几个变量所需的额外空间。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/" target="_blank" rel="noopener">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 (leetcode-cn.com)</a> 官方题解</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Data_Structure_and_Algorithm</category>
      </categories>
      <tags>
        <tag>查找算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer -- 双指针</title>
    <url>/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="剑指offer-—-双指针"><a href="#剑指offer-—-双指针" class="headerlink" title="剑指offer — 双指针"></a>剑指offer — 双指针</h2><h3 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 18. 删除链表的节点</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p><strong>注意：</strong>此题对比原题有改动</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>题目保证链表中节点的值互不相同</li><li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="comment">// 如果要删除的节点是头节点</span></span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == val) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (head-&gt;next-&gt;val != val) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N)$ ，<em>N</em> 为链表长度，删除操作平均需循环 <em>N/2</em> 次，最差 <em>N</em> 次。<br><strong>空间复杂度：</strong> $O(1)$ ， <em>dummy</em> 占用常数大小额外空间。</p><h3 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= nums.length &lt;= 50000</code></li><li><code>1 &lt;= nums[i] &lt;= 10000</code></li></ol><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：非原地</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果是奇数往左侧放置</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] % <span class="number">2</span>) &#123;</span><br><span class="line">                res[left] = nums[i];</span><br><span class="line">                left++; <span class="comment">// 指针右移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是偶数往右侧放置 </span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res[right] = nums[i];</span><br><span class="line">                right--; <span class="comment">// 指针左移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 循环退出条件</span></span><br><span class="line">            <span class="keyword">if</span> (left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N)$ ，<em>N</em> 为<em>nums</em>数组长度。<br><strong>空间复杂度：</strong> $O(N)$ ， <em>res</em> 占用<em>nums</em>相同大小空间。</p><p><strong><font color="F08F00">方法二：原地</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 该方法的 while 循环操作与 快速排序的 partition 求取 pivot 过程相似</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; (nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; (nums[j] &amp; <span class="number">1</span>) == <span class="number">0</span>) j--;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">关键算法思路</font></strong>可以参考 <a href="https://czgitaccount.github.io/Data_Structure_and_Algorithm/排序算法/">快速排序</a> 算法中 <em>partition</em> 求取 <em>pivot</em> 过程。</p><p><strong>时间复杂度：</strong> $O(N)$ ，<em>N</em> 为 <em>nums</em> 数组长度。<br><strong>空间复杂度：</strong> $O(1)$ ， 原地交换操作，无额外消耗。</p><h3 id="剑指-Offer-22-链表中倒数第K个节点"><a href="#剑指-Offer-22-链表中倒数第K个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第K个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 22. 链表中倒数第K个节点</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="comment">// 先让 head 向前移动 k 步骤</span></span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后 dummy 与 head 同时移动，直到 head 到链表尾部，</span></span><br><span class="line">        <span class="comment">// 此时 dummy 指向的位置就是所需的位置</span></span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            dummy = dummy-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N) $ ， <em>N</em> 为链表长度；总体看， <em>head</em> 走了 <em>N</em> 步， <em>dummy</em> 走了 <em>(N−k)</em> 步。<br><strong>空间复杂度：</strong> $O(1)$ ， <em>dummy</em> 使用常数大小的额外空间。</p><h3 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 25. 合并两个排序的链表</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= 链表长度 &lt;= 1000</code></p><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = res;</span><br><span class="line">        <span class="comment">// 如果 l1 为空节点，直接返回 l2</span></span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="comment">// 如果 l2 为空节点，直接返回 l1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// l1 和 l2 都不是空的情况下，判断val</span></span><br><span class="line">            <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">                <span class="comment">// 如果 l2 val 更小则，先链接 l2</span></span><br><span class="line">                <span class="keyword">if</span> (l1-&gt;val &gt; l2-&gt;val) &#123;</span><br><span class="line">                    cur-&gt;next = l2;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                    l2 = l2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果 l1 val 更小则，先链接 l1 </span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur-&gt;next = l1;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                    l1 = l1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时最后拼接上多余的节点</span></span><br><span class="line">            cur-&gt;next = (!l1 ? l2 : l1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(M + N) $ ， <em>M</em> 为 <em>l1</em> 长度， <em>N</em> 为 <em>l2</em> 长度<br><strong>空间复杂度：</strong> $O(1)$ ， <em>res，cur</em> 使用常数大小的额外空间。</p><h3 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 52. 两个链表的第一个公共节点</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表<strong>：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" style="zoom:67%"></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" style="zoom:67%"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" style="zoom:67%"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" style="zoom:67%"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(_n_) 时间复杂度，且仅用 O(_1_) 内存。</li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    	ListNode* A = headA, *B = headB;</span><br><span class="line">        <span class="comment">// 如果有相交点，则会在 A == B 时候返回</span></span><br><span class="line">        <span class="comment">// 如果没有相交点，也会 A = nullptr = B 时返回</span></span><br><span class="line">        <span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">            <span class="comment">// 如果 A 为 nullptr 时，将 A 指向 headB,否则 A 向后遍历</span></span><br><span class="line">            A = !A ? headB : A-&gt;next;</span><br><span class="line">            <span class="comment">// 如果 B 为 nullptr 时，将 B 指向 headA,否则 B 向后遍历</span></span><br><span class="line">            B = !B ? headA : B-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(M + N) $ ， <em>M</em> 为 <em>l1</em> 长度， <em>N</em> 为 <em>l2</em> 长度<br><strong>空间复杂度：</strong> $O(1)$ ， <em>A，B</em> 使用常数大小的额外空间。</p><h3 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 57. 和为s的两个数字</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^6</code></li></ul><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：哈希表</font></strong>（同两数之和）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (nums.size() &lt;= 1) return &#123;&#125;;</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> toFind = target - num;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">set</span>.<span class="built_in">find</span>(toFind) != <span class="built_in">set</span>.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;toFind, num&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">set</span>.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N) $ ，<em>N</em> 为数组长度。<br><strong>空间复杂度：</strong> $O(N)$ ， 哈希表额外空间。</p><p><strong><font color="F08F00">方法二：双指针</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 类同于二分查找</span></span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[left] + nums[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[left] + nums[right]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;nums[left], nums[right]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N) $ ，<em>N</em> 为数组长度。<br><strong>空间复杂度：</strong> $O(1)$ ， 无额外空间消耗。</p><h3 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener">剑指 Offer 58 - I. 翻转单词顺序</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>无空格字符构成一个单词。</li><li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 反转整个字符串</span></span><br><span class="line">        reverse(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;  <span class="comment">// 用来指示单词位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n; ++start) &#123;</span><br><span class="line">            <span class="comment">// 删除字符串前部分的空格</span></span><br><span class="line">            <span class="keyword">if</span> (s[start] != <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="comment">// 填一个空白字符然后将idx移动到下一个单词的开头位置</span></span><br><span class="line">                <span class="keyword">if</span> (idx != <span class="number">0</span>) s[idx++] = <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环遍历至单词的末尾</span></span><br><span class="line">                <span class="keyword">int</span> <span class="built_in">end</span> = start;	<span class="comment">// idx 从 0 开始计数， end 从 start 开始计数</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">end</span> &lt; n &amp;&amp; s[<span class="built_in">end</span>] != <span class="string">' '</span>) s[idx++] = s[<span class="built_in">end</span>++];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 反转整个单词</span></span><br><span class="line">                reverse(s.<span class="built_in">begin</span>() + idx - (<span class="built_in">end</span> - start), s.<span class="built_in">begin</span>() + idx);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新start，去找下一个单词</span></span><br><span class="line">                start = <span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除最后的连续空格</span></span><br><span class="line">        s.erase(s.<span class="built_in">begin</span>() + idx, s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N)$，<em>N</em> 为字符串长度</p><p><strong>空间复杂度：</strong> $O(1)$，<em>idx，start, end</em> 使用常数大小的额外空间。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/" target="_blank" rel="noopener">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 (leetcode-cn.com)</a> 官方题解</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Data_Structure_and_Algorithm</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/Data_Structure_and_Algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>比较相邻元素，第一个比第二个大，就交换</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (vec[j] &gt; vec[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        		swap(vec[j], vec[j + <span class="number">1</span>]);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	bubble_sort(vec);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Linux 下编译的时候需要添加编译选项 <strong><code>-std=c++11</code></strong></p><p><img src="/Data_Structure_and_Algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/冒泡排序.png" alt></p><p>最优的情况下也就是输入有序：$O(n)$</p><p>最差的情况下也就是输入逆序：$O(n^2)$</p><p>无额外<strong>空间</strong>需求：$O(1)$</p><p><strong>稳定</strong></p><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><p>首先在未排序的队列中找到最小的元素，存放在排序序列的起始位置，之后找第二小的，以此类推</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> minIdx = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vec[j] &lt; vec[minIdx]) &#123;</span><br><span class="line">				minIdx = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(vec[minIdx], vec[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	selectionSort(vec);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Data_Structure_and_Algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/选择排序.png" alt></p><p>每次操作 $n - 1 + n - 2 + … + 1 = ((1 + n - 1) * n - 1) / 2$</p><p><strong>时间</strong>复杂度：$O(n^2)$</p><p><strong>空间</strong>复杂度：$O (1)$</p><p><strong>不稳定</strong>：例子: $80_1, 80_2, 70 —&gt; 70, 80_2, 80_1$</p><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h3><p>算法描述：斗地主摸牌插入手牌</p><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		T key = vec[i];</span><br><span class="line">		<span class="keyword">int</span> j = i;</span><br><span class="line">		<span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; vec[j - <span class="number">1</span>] &gt; key) &#123;</span><br><span class="line">			vec[j] = vec[j - <span class="number">1</span>];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		vec[j] = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	insertSort(vec);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Data_Structure_and_Algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/插入排序.png" alt></p><p>最优的情况下也就是输入有序：$O(n)$</p><p>最差的情况下也就是输入逆序：$O(n^2)$</p><p>无额外<strong>空间</strong>需求：$O(1)$</p><p><strong>稳定</strong></p><h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h3><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = n / <span class="number">2</span>; <span class="built_in">step</span> &gt; <span class="number">0</span>; <span class="built_in">step</span> /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">step</span>; i &lt; n; i++) &#123;</span><br><span class="line">            T key = vec[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="built_in">step</span> &amp;&amp; vec[j - <span class="built_in">step</span>] &gt; key) &#123;</span><br><span class="line">                vec[j] = vec[j - <span class="built_in">step</span>];</span><br><span class="line">                j -= <span class="built_in">step</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vec[j] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	shellSort(vec);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Data_Structure_and_Algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/希尔排序.png" style="zoom:80%"></p><p><strong>时间</strong>复杂度：$O(nlog_2n)$，看 step</p><p><strong>空间</strong>复杂度：$O(1)$</p><p><strong>不稳定</strong>：例子： $80_1, 80_2, 80_3, 70 —&gt; 70, 80_1, 80_3, 80_2$</p><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h3><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortRecur</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp; vec, <span class="built_in">vector</span>&lt;T&gt;&amp; temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt;temp(n);</span><br><span class="line">    mergeSortRecur(vec, temp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortRecur</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp; vec, <span class="built_in">vector</span>&lt;T&gt;&amp; temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSortRecur(vec, temp, left, mid);</span><br><span class="line">        mergeSortRecur(vec, temp, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            temp[k++] = vec[i] &lt;= vec[j] ? vec[i++] : vec[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) temp[k++] = vec[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) temp[k++] = vec[j++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; k; l++) vec[left + l] = temp[l];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	mergeSort(vec);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Data_Structure_and_Algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/归并排序.png" style="zoom:80%"></p><p><strong>时间</strong>复杂度：最好，最坏，平均：$O(nlog_2n)$</p><p><strong>空间</strong>复杂度：$O(n)$</p><p><strong>稳定</strong></p><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h3><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp; vec, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp; vec, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> pivot = partition(vec, left, right);</span><br><span class="line">	quickSort(vec, left, pivot - <span class="number">1</span>);</span><br><span class="line">	quickSort(vec, pivot + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp; vec, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 基准为最左侧值</span></span><br><span class="line">	T pivot = vec[left];</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; vec[right] &gt;= pivot) --right;</span><br><span class="line">		vec[left] = vec[right];</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; vec[left] &lt;= pivot) ++left;</span><br><span class="line">		vec[right] = vec[left];</span><br><span class="line">	&#125;</span><br><span class="line">	vec[left] = pivot;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> right = vec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	quickSort(vec, <span class="number">0</span>, right);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Data_Structure_and_Algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/快速排序.png" style="zoom:80%"></p><p><strong>时间</strong>复杂度：<strong>最坏</strong>情况：，有序情况，$O(n^2)$；<strong>平摊</strong>期望时间：$O(nlog_2n)$ 且隐含的常数因子很小，对于绝大多数顺序性较弱的随机序列，优于归并排序。</p><p><strong>空间</strong>复杂度：每次递归传参 <code>left</code>，和 <code>right</code>，平均递归次数是 $o(log_2n)$ 次，所以<strong>平均</strong>空间复杂度是$o(log_2n)$ ,递归栈的深度。<strong>最坏</strong>的情况是$o(n)$ （初始是逆序的情况）</p><p><strong>不稳定</strong>：例子 $80_1, 80_2, 80_3, 70 — &gt; 70, 80_2, 80_3, 80_1$ (基准最左边)</p><p><strong>快速排序的优化</strong>：</p><blockquote><p><a href="https://blog.csdn.net/qq_19525389/article/details/81436838" target="_blank" rel="noopener">快速排序的5种优化方法</a></p></blockquote><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h3><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li></ol><p>堆排序的平均时间复杂度为 $O(nlog_2n)$。</p><p><strong>算法步骤：</strong></p><ol><li>创建一个堆 $H[0……n-1]$；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 <strong><code>shift_down(0)​</code></strong> ，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heap</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp; vec, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 记录父节点索引</span></span><br><span class="line">	<span class="keyword">int</span> parent = start;</span><br><span class="line">	<span class="comment">// 记录子节点索引开始位置</span></span><br><span class="line">	<span class="keyword">int</span> son = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (son &lt;= <span class="built_in">end</span>) &#123;</span><br><span class="line">		<span class="comment">// 选择两个孩子节点中，最大的一个孩子，记录其索引</span></span><br><span class="line">		<span class="keyword">if</span> (son + <span class="number">1</span> &lt;= <span class="built_in">end</span> &amp;&amp; vec[son] &lt; vec[son + <span class="number">1</span>]) &#123;</span><br><span class="line">			son++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (vec[parent] &gt;= vec[son]) &#123;</span><br><span class="line">			<span class="comment">// 如果父节点已经大于所有子节点了，则直接返回</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 否则交换父子节点</span></span><br><span class="line">			swap(vec[parent], vec[son]);</span><br><span class="line">			<span class="comment">// 父亲索引改为其子节点索引</span></span><br><span class="line">			parent = son;</span><br><span class="line">			<span class="comment">// 其子节点索引在指向孙节点继续相同的比较</span></span><br><span class="line">			son = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 初始化调整：从最后一个父节点找起</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		max_heap(vec, i, len - <span class="number">1</span>);</span><br><span class="line">	&#125;<span class="comment">// 获得最大堆</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先将第一个元素和已经排好的元素前一位做交换，</span></span><br><span class="line">	<span class="comment">// 再重新调整(刚调整的元素之前的元素)，知道排序完毕</span></span><br><span class="line">	<span class="comment">// 注：vec[0] 为堆顶，即为最大值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">		swap(vec[<span class="number">0</span>], vec[i]);</span><br><span class="line">		max_heap(vec, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> right = vec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	heapSort(vec);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Data_Structure_and_Algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/堆排序.png" style="zoom:80%"></p><p><strong>时间</strong>复杂度：$O(nlog_2n)$</p><p><strong>空间</strong>复杂度：$O(1)$</p><p><strong>不稳定</strong>：例子：$80_1, 80_2, 70 —&gt; 70, 80_2, 80_1$</p><h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p><strong>计数排序的特征</strong></p><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 $O(n + k)$。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p><p><strong>算法的步骤如下：</strong></p><ul><li>（1）找出待排序的数组中最大和最小的元素</li><li>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li><li>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;int, int&gt; findMaxMinOfVec(const vector&lt;int&gt;&amp; vec) &#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">min</span> = INT_MAX;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">max</span> = INT_MIN;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v &gt; <span class="built_in">max</span>) <span class="built_in">max</span> = v;</span><br><span class="line">		<span class="keyword">if</span> (v &lt; <span class="built_in">min</span>) <span class="built_in">min</span> = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;<span class="built_in">max</span>, <span class="built_in">min</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">	pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pa = findMaxMinOfVec(vec);</span><br><span class="line">	<span class="keyword">int</span> maxN = pa.first;</span><br><span class="line">	<span class="keyword">int</span> minN = pa.second;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">freq</span><span class="params">(maxN - minN + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) &#123;</span><br><span class="line">		freq[v - minN]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">end</span> = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = maxN - minN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">while</span>(freq[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			vec[<span class="built_in">end</span>--] = i + minN;</span><br><span class="line">			freq[i]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	countSort(vec);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Data_Structure_and_Algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/计数排序.png" style="zoom:80%"></p><p><strong>时间</strong>复杂度：$O(n + k)$</p><p><strong>空间</strong>复杂度：$O(k)$ 其中 k 为最大最小值差值 + 1</p><p><strong>稳定</strong>：需要反向填充数组</p><h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><p><strong>最快</strong>：当输入的数据可以均匀的分配到每一个桶中。</p><p><strong>最慢</strong>：当输入的数据被分配到了同一个桶中。</p><p><strong>示意图</strong></p><p>元素分布在桶中：</p><p><img src="/Data_Structure_and_Algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/桶排序示意图.png" style="zoom:50%"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUCKET_NUM = <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    explicit ListNode(int i = 0) : val(i), next(nullptr) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入操作，插入有序链表</span></span><br><span class="line"><span class="function">ListNode* <span class="title">insert</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode* dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummyNode-&gt;next = head;</span><br><span class="line">    ListNode* newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    ListNode* pre, *cur;</span><br><span class="line">    pre = dummyNode;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;val &lt;= val) &#123;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;next = cur;</span><br><span class="line">    pre-&gt;next = newNode;</span><br><span class="line">    <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">buckets</span><span class="params">(BUCKET_NUM, (ListNode*)(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 桶编号</span></span><br><span class="line">        <span class="keyword">int</span> idx = vec[i] / BUCKET_NUM;</span><br><span class="line">        ListNode *head = buckets.at(idx);</span><br><span class="line">        buckets.at(idx) = insert(head, vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按照桶编号，依次输出结果即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BUCKET_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buckets[i]) &#123;</span><br><span class="line">            ListNode* cur = buckets[i];</span><br><span class="line">            <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">                vec[k++] = cur-&gt;val;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">17</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    bucketSort(vec);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Data_Structure_and_Algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/桶排序.png" style="zoom:80%"></p><p><strong>时间</strong>复杂度：$O(n + k)$，最坏情况下 $O(n^2)$</p><p><strong>空间</strong>复杂度：$O(n + k)$</p><p><strong>稳定</strong>，但是确切说应该取决于桶中排序算法。</p><h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>基数排序有两种方法：</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxbit</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = to_string(v).<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &gt; maxLen) maxLen = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> d = maxbit(vec);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">10</span>]; <span class="comment">// 统计被分配到 0 1 2 ... 9 的次数</span></span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(count, <span class="number">0</span>, <span class="keyword">sizeof</span>(count));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = (vec[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据每个桶的大小，分配区间位置，从小到大分配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = (vec[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 反向插入</span></span><br><span class="line">            temp[count[k] - <span class="number">1</span>] = vec[j];</span><br><span class="line">            count[k]--; <span class="comment">// 向前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        vec = temp; <span class="comment">// 赋值</span></span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">20</span>,<span class="number">51</span>,<span class="number">6</span>,<span class="number">78</span>,<span class="number">9</span>,<span class="number">30</span>,<span class="number">41</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">54</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">18</span>,<span class="number">81</span>,<span class="number">75</span>,<span class="number">94</span>,<span class="number">9</span>,<span class="number">64</span>,<span class="number">82</span>,<span class="number">37</span>,<span class="number">42</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    radixSort(vec);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Data_Structure_and_Algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/基数排序.png" style="zoom:80%"></p><p><strong>时间</strong>复杂度：$O(n * k)$</p><p><strong>空间</strong>复杂度：$O(n + k)$</p><p><strong>稳定</strong></p><h3 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h3><p><img src="/Data_Structure_and_Algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/十大排序.png" style="zoom:50%"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html" target="_blank" rel="noopener">1.0 十大经典排序算法 | 菜鸟教程 (runoob.com)</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Data_Structure_and_Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer -- 数学</title>
    <url>/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="剑指offer-—-数学"><a href="#剑指offer-—-数学" class="headerlink" title="剑指offer — 数学"></a>剑指offer — 数学</h2><h3 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 14- I. 剪绳子</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code> 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 58</code></li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为求最大乘积，需要尽可能的以 3 为分组</span></span><br><span class="line">        <span class="keyword">int</span> m = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> d = n / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以分为 d 个 3</span></span><br><span class="line">        <span class="keyword">if</span> (!m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 多出一个 1 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, d - <span class="number">1</span>) * <span class="number">4</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 多出一个 2 </span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, d) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 14- II. 剪绳子 II</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m - 1]</code> 。请问 <code>k[0]*k[1]*...*k[m - 1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 1000</code></li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            res *= <span class="number">3</span>;</span><br><span class="line">            res %= <span class="number">1000000007</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(res * n % <span class="number">1000000007</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>剑指 offer 14</strong> 两道题基本相同，时间空间复杂度分析相同</p><p><strong>时间复杂度：</strong> $O(1)$，简单的算术运算</p><p><strong>空间复杂度：</strong> $O(1) $</p><h3 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>1 &lt;= 数组长度 &lt;= 50000</code></p><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：排序</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[n / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>取决于快速排序的时间空间复杂度</p><p><strong>时间复杂度：</strong> $O(N \log N)$</p><p><strong>空间复杂度：</strong> $O(\log N) $</p><p><strong><font color="F08F00">方法二：哈希表</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; n : nums) &#123;</span><br><span class="line">            mp[n]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp[n] &gt;= (nums.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N)$，简单的算术运算</p><p><strong>空间复杂度：</strong> $O(N) $</p><p><strong><font color="F08F00">方法二：摩尔投票</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                res = num;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res == n ? count++ : count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N)$，简单的算术运算</p><p><strong>空间复杂度：</strong> $O(1) $</p><h3 id="剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数"></a><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h3><p>Difficulty: <strong><font color="FF0000">困难</font></strong></p><p>输入一个整数 <code>n</code> ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt; 2^31</code></li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> high = n / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = n % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="comment">// 当 high 和 cur 同时为 0，说明已经越过最高位</span></span><br><span class="line">        <span class="keyword">while</span> (cur || high) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 核心代码，3 个判断条件</span></span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span>) res += high * digit;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) res += (high * digit) + low + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> res += (high + <span class="number">1</span>) * digit;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将 cur 加入 low, 组成下轮 low, 也就是 low 左移</span></span><br><span class="line">            low += cur * digit;</span><br><span class="line">            <span class="comment">// 下轮 cur 是本轮 high 的最低位, 也就是 cur 左移</span></span><br><span class="line">            cur = high % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 将本轮 high 最低位删除，得到下轮 high，也就是 high 左移</span></span><br><span class="line">            high = high / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 位因子每轮 * 10</span></span><br><span class="line">            digit = digit * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(logn) $ ，循环内的计算操作使用 $O(1)$ 时间；循环次数为数字 n 的位数，即 $\log_{10}{n}$ ，因此循环使用 $O(\log n)$时间。<br><strong>空间复杂度</strong>： $O(1)$， 几个变量使用常数大小的额外空间。</p><h3 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 44. 数字序列中某一位的数字</a></h3><p>Difficulty: <strong><font color="F008F00">中等</font></strong></p><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 11</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= n &lt; 2^31</code></li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; count) &#123;</span><br><span class="line">            n -= count;</span><br><span class="line">            start *= <span class="number">10</span>;  <span class="comment">// 1, 10, 100, ...</span></span><br><span class="line">            digit += <span class="number">1</span>;   <span class="comment">// 1, 2, 3, ...</span></span><br><span class="line">            count = digit * start * <span class="number">9</span>; <span class="comment">// 9, 180, 2700</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定num </span></span><br><span class="line">        <span class="keyword">long</span> num = start + (n - <span class="number">1</span>) / digit;</span><br><span class="line">        <span class="comment">// 确定 n 位置在 num 中哪一位</span></span><br><span class="line">        <span class="keyword">return</span> to_string(num)[(n - <span class="number">1</span>) % digit] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(logn)$， 所求数位 n 对应数字 num 的位数 digit 最大为 $O(\log n)$ ；第一步最多循环 $O(\log n)$ 次；第三步中将 num 转化为字符串使用 $O(\log n)$ 时间；因此总体为 $O(\log n)$ 。<br><strong>空间复杂度：</strong>$O(logn)$ ，将数字 num 转化为字符串 str(num) ，占用 $O(\log n)$ 的额外空间。</p><h3 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 57 - II. 和为s的连续正数序列</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= target &lt;= 10^5</code></li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findContinuousSequence</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">1</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = left + right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只需要循环到中位数即可</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt;= ((target + <span class="number">1</span>) / <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;     </span><br><span class="line">                <span class="keyword">if</span> (target == sum) &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                        temp.push_back(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.push_back(temp);</span><br><span class="line">                    sum -= left;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; sum) &#123;</span><br><span class="line">                    sum -= left;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right++;</span><br><span class="line">                    sum += right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            right++; <span class="comment">// 跳出中位数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N)$，其中 $N = target$；连续整数序列至少有两个数字，而 $i &lt; j$恒成立，因此至多循环 $target$ 次（ $i , j$ 都移动到 $\frac{target}{2}$ ），使用 $O(N)$ 时间；当 $i = 1$ 时，达到最大序列长度 $\frac{-1 + \sqrt{1 + 8s}}{2}$ ，考虑到解的稀疏性，将列表构建时间简化考虑为 $O(1)$；</p><p><strong>空间复杂度：</strong> $O(1) $</p><h3 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 62. 圆圈中最后剩下的数字</a></h3><p>Difficulty: <strong><font color="0008F00">简单</font></strong></p><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 5, m &#x3D; 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10, m &#x3D; 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= m &lt;= 10^6</code></li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res = (res + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E6%95%B0%E5%AD%A6/圆圈中最后剩下的数字.png" style="zoom:67%"></p><h3 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener">剑指 Offer 66. 构建乘积数组</a></h3><p>Difficulty: <strong><font color="F08F00">中等</font></strong></p><p>给定一个数组 <code>A[0,1,…,n-1]</code>，请构建一个数组 <code>B[0,1,…,n-1]</code>，其中 <code>B[i]</code> 的值是数组 <code>A</code> 中除了下标 <code>i</code> 以外的元素的积, 即 <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。不能使用除法。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>所有元素乘积之和不会溢出 32 位整数</li><li><code>a.length &lt;= 100000</code></li></ul><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：当前位置的值 = 左边乘积 * 右边乘积</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructArr</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定动态规划矩阵</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dpLeft</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dpRight</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 简单求取左右乘积矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = n - <span class="number">1</span>; i &lt; n, j &gt;= <span class="number">0</span>; i++, j--)&#123;</span><br><span class="line">            dpLeft[i] = dpLeft[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">            dpRight[j] = dpRight[j + <span class="number">1</span>] * a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] = dpLeft[i] * dpRight[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N)$，2次遍历数组</p><p><strong>空间复杂度：</strong> $O(N) $，左右乘积矩阵占用的空间</p><p><strong><font color="F08F00">方法二：双向遍历</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructArr</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 正向遍历,获得左乘积矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            B[i] = temp;</span><br><span class="line">            temp *= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        temp = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 反向遍历,获得右乘积矩阵，同时与左乘积矩阵相乘，相比于方法一少去一部分操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            B[i] = B[i] * temp;</span><br><span class="line">            temp *= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N)$，2次遍历数组</p><p><strong>空间复杂度：</strong> $O(N) $，数组 B 占用的空间</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/" target="_blank" rel="noopener">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 (leetcode-cn.com)</a> 官方题解</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Data_Structure_and_Algorithm</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer -- 排序</title>
    <url>/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="剑指offer-—-排序"><a href="#剑指offer-—-排序" class="headerlink" title="剑指offer — 排序"></a>剑指offer — 排序</h2><h3 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 40. 最小的k个数</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li><li><code>0 &lt;= arr[i] &lt;= 10000</code></li></ul><p><strong>Solution</strong></p><p><strong><font color="F08000">方法一：排序</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res.push_back(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(n\log n)$，其中 n 是数组 arr 的长度。算法的时间复杂度即排序的时间复杂度。</p><p><strong>空间复杂度：</strong> $O(\log n) $，排序所需额外的空间复杂度。</p><p><strong><font color="F08000">方法二：堆</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123; <span class="comment">// 排除 0 的情况</span></span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            Q.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; (<span class="keyword">int</span>)arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Q.top() &gt; arr[i]) &#123;</span><br><span class="line">                Q.pop();</span><br><span class="line">                Q.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            vec[i] = Q.top();</span><br><span class="line">            Q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度： </strong>$O(n\log k)$，其中 n 是数组 arr 的长度。由于大根堆实时维护前 k 小值，所以插入删除都是 $O(\log k)$ 的时间复杂度，最坏情况下数组里 n 个数都会插入，所以一共需要 $O(n\log k)$ 的时间复杂度。</p><p><strong>空间复杂度： </strong>$O(k$)，因为大根堆里最多 k 个数。</p><h3 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 41. 数据流中的中位数</a></h3><p>Difficulty: <strong><font color="FF0000">困难</font></strong></p><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li>最多会对 <code>addNum、findMedian</code> 进行 <code>50000</code> 次调用。</li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; A;  <span class="comment">// 大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; B; <span class="comment">// 小顶堆</span></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.<span class="built_in">size</span>() == B.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            B.push(num);</span><br><span class="line">            <span class="keyword">int</span> temp = B.top();</span><br><span class="line">            B.pop();</span><br><span class="line">            A.push(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A.push(num);</span><br><span class="line">            <span class="keyword">int</span> temp = A.top();</span><br><span class="line">            A.pop();</span><br><span class="line">            B.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() == B.<span class="built_in">size</span>() ?(A.top() + B.top()) / <span class="number">2.0</span> : A.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><ul><li>查找中位数：$O(1)$</li><li>添加数字：$O(\log N)$</li></ul><p><strong>空间复杂度： </strong>$O(N)$，其中 N 为数据流中的元素数量。</p><h3 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 45. 把数组排成最小的数</a></h3><p>Difficulty: <strong><font color="F08000">中等</font></strong></p><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>0 &lt; nums.length &lt;= 100</code></li></ul><p><strong>说明:</strong></p><ul><li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li><li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            vec.push_back(to_string(num));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序中使用 lambda 函数</span></span><br><span class="line">        sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; A, <span class="keyword">const</span> <span class="built_in">string</span>&amp; B) &#123; <span class="keyword">return</span> A + B &lt; B + A; &#125; );</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : vec) &#123;</span><br><span class="line">            res += v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N\log N )$，其中 N 为数组长度，时间复杂度主要为排序算法时间复杂度</p><p><strong>空间复杂度： </strong>$O(N)$，字符串数组额外空间</p><h3 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 61. 扑克牌中的顺子</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p>数组长度为 5</p><p>数组的数取值为 [0, 13] .</p><p><strong>Solution</strong></p><p><strong><font color="F08000">方法一：哈希集合</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isStraight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="comment">// 如果 num != 0 , 不是大小王的情况下</span></span><br><span class="line">            <span class="keyword">if</span> (num) &#123;</span><br><span class="line">                <span class="comment">// 出现重复，则一定不是顺子</span></span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">find</span>(num) != s.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 没有出现过，则插入到哈希集合中</span></span><br><span class="line">                s.insert(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在集合非空的情况下，如果当前集合最大最小值差值 &gt;= 5 </span></span><br><span class="line">            <span class="comment">// 则说明不可能形成顺子 (0 并没有被插入)</span></span><br><span class="line">            <span class="keyword">if</span> (!s.empty() &amp;&amp; *s.rbegin() - *s.<span class="built_in">begin</span>() &gt;= <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(1)$，遍历长度为 5</p><p><strong>空间复杂度：</strong> $O(1)$，哈希集合可能的最大长度为 5</p><p><strong><font color="F08000">方法二：排序</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isStraight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> joker = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 排序数组</span></span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 统计大小王数量</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) joker++;</span><br><span class="line">            <span class="comment">// 如果重复，则不可能出现顺子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>] - nums[joker] &lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(1)$，遍历长度为 5，所以排序算法后时间复杂度仍然是 $O( 1)$</p><p><strong>空间复杂度：</strong> $O(1)$，变量 joker</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/" target="_blank" rel="noopener">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 (leetcode-cn.com)</a> 官方题解</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Data_Structure_and_Algorithm</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer -- 搜索与回溯算法</title>
    <url>/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="剑指offer-—-搜索与回溯算法"><a href="#剑指offer-—-搜索与回溯算法" class="headerlink" title="剑指offer — 搜索与回溯算法"></a>剑指offer — 搜索与回溯算法</h2><h3 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 12. 矩阵中的路径</a></h3><p>Difficulty: <strong><font color="F08000">中等</font></strong></p><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt></p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= board.length &lt;= 200</code></li><li><code>1 &lt;= board[i].length &lt;= 200</code></li><li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        m = board.<span class="built_in">size</span>();</span><br><span class="line">        n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (verify(board, <span class="keyword">word</span>, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>&amp; <span class="keyword">word</span>, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 超出边界的话直接返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || board[i][j] != <span class="keyword">word</span>[k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果遍历到恰好长度，且元素相符合则返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">word</span>.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 代表已经访问过，随便一个非字母的字符即可</span></span><br><span class="line">        board[i][j] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="comment">// 向四个方向进行搜索，只要有一方找到即可</span></span><br><span class="line">        <span class="keyword">bool</span> res = verify(board, <span class="keyword">word</span>, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || </span><br><span class="line">                   verify(board, <span class="keyword">word</span>, i, j + <span class="number">1</span>, k + <span class="number">1</span>) ||</span><br><span class="line">                   verify(board, <span class="keyword">word</span>, i - <span class="number">1</span>, j, k + <span class="number">1</span>) ||</span><br><span class="line">                   verify(board, <span class="keyword">word</span>, i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 回溯时候填回数字</span></span><br><span class="line">        board[i][j] = <span class="keyword">word</span>[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(3^KMN)$ ， 最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为 $O(3^K)$；矩阵中共有 $MN $ 个起点，时间复杂度为 $O(MN)$。</p><ul><li>方案数计算： 设字符串长度为 KK ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为 $O(3^K)$。</li></ul><p><strong>空间复杂度：</strong> $O(K)$， 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 $O(K)$（因为函数返回后，系统调用的栈空间会释放）。最坏情况下 $K = MNK=MN$ ，递归深度为 $MN$ ，此时系统栈使用 $O(MN)$ 的额外空间。</p><h3 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">剑指 Offer 13. 机器人的运动范围</a></h3><p>Difficulty: <strong><font color="F08000">中等</font></strong></p><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n,m &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 20</code></li></ul><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：DFS</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, visited, m, n, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> si, <span class="keyword">int</span> sj, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果越界，或者不满足数位大小之和，或者已经被访问过，则返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 访问该点</span></span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">int</span> a = (i + <span class="number">1</span>) % <span class="number">10</span> ? si + <span class="number">1</span> : si - <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> b = (j + <span class="number">1</span>) % <span class="number">10</span> ? sj + <span class="number">1</span> : sj - <span class="number">8</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关于以上代码的一个简单的例子, </span></span><br><span class="line">        <span class="comment">// 其中的 si 是当前横坐标各位之和, s_(i+1) 是下移后情况下横坐标各位之和</span></span><br><span class="line">        <span class="comment">// 19 -&gt; 20  si = 10, s_(i+1) = 2, s_(i+1) = si - 8;</span></span><br><span class="line">        <span class="comment">// 18 -&gt; 19  si = 9, s_(i+1) = 10, s_(i+1) = si + 1;</span></span><br><span class="line">        </span><br><span class="line">                   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, a, sj, visited, m, n, k)   <span class="comment">// 下移</span></span><br><span class="line">                 + dfs(i, j + <span class="number">1</span>, si, b, visited, m, n, k);  <span class="comment">// 右移</span></span><br><span class="line">                  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="F08F00">方法二：BFS</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每次 push 是一个 四元组</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> i = x[<span class="number">0</span>], j = x[<span class="number">1</span>], si = x[<span class="number">2</span>], sj = x[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">            q.push(&#123;i + <span class="number">1</span>, j, (i + <span class="number">1</span>) % <span class="number">10</span> ? si + <span class="number">1</span>: si - <span class="number">8</span>, sj&#125;);</span><br><span class="line">            q.push(&#123;i, j + <span class="number">1</span>, si, (j + <span class="number">1</span>) % <span class="number">10</span> ? sj + <span class="number">1</span>: sj - <span class="number">8</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两种方法时间复杂度，空间复杂度分析相同。</p><p><strong>时间复杂度：</strong> $O(MN)$ ，最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 $O(MN)$ 。<br><strong>空间复杂度：</strong> $O(MN)$， 最差情况下，访问矩阵存储所有单元格的索引，使用 $O(MN)$ 的额外空间。</p><h3 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">剑指 Offer 26. 树的子结构</a></h3><p>Difficulty: <strong><font color="F08000">中等</font></strong></p><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3  </span><br><span class="line">   &#x2F; \  </span><br><span class="line">  4   5  </span><br><span class="line"> &#x2F; \  </span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>给定的树 B：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4   </span><br><span class="line"> &#x2F;  </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p></p><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= 节点个数 &lt;= 10000</code></p><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// true 条件：1. A B 都不为空</span></span><br><span class="line">        <span class="comment">// 2. A 是根节点，B为其子树; B 为 A 左（右）子树中的子树</span></span><br><span class="line">        <span class="keyword">return</span> (A &amp;&amp; B) &amp;&amp; (recur(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// B 空则说明到底，期间没有错误，所以正确</span></span><br><span class="line">        <span class="keyword">if</span> (!B) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// A 空则说明，B 没有搜索到，或者 期间搜索错误，都说明搜索错误</span></span><br><span class="line">        <span class="keyword">if</span> (!A || A-&gt;val != B-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 左子树对应左子树，右子树对应右子树</span></span><br><span class="line">        <span class="keyword">return</span> recur(A-&gt;left, B-&gt;left) &amp;&amp; recur(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(MN)$， 其中 M, NM,N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 $O(M)$ ，每次调用 recur(A, B) 判断占用 $O(N)$ 。<br><strong>空间复杂度：</strong> $O(M)$ ， 当树 A 和树 B 都退化为链表时，递归调用深度最大。当 $M≤N$ 时，遍历树 A 与递归判断的总递归深度为 M ；当 $M&gt;N$ 时，最差情况为遍历至树 A 的叶节点，此时总递归深度为 M。</p><h3 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">剑指 Offer 27. 二叉树的镜像</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4  </span><br><span class="line">   &#x2F;   \  </span><br><span class="line">  2     7  </span><br><span class="line"> &#x2F; \   &#x2F; \  </span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>镜像输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4  </span><br><span class="line">   &#x2F;   \  </span><br><span class="line">  7     2  </span><br><span class="line"> &#x2F; \   &#x2F; \  </span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= 节点个数 &lt;= 1000</code></p><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：递归</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);</span><br><span class="line">        invertTree(root-&gt;left);</span><br><span class="line">        invertTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(root-&gt;val);</span><br><span class="line">        node-&gt;left = dfs(root-&gt;right);</span><br><span class="line">        node-&gt;right = dfs(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$， 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点。<br><strong>空间复杂度：</strong>$O(N)$， 最差情况下（当二叉树退化为链表），递归时系统需使用 $O(N)$ 大小的栈空间。</p><p><strong><font color="F08F00">方法二：迭代</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">            TreeNode* node = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            swap(node-&gt;left, node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) stk.push(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) stk.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$， 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点。<br><strong>空间复杂度：</strong>$O(N) $， 最差情况下，栈 stack 最多同时存储 $\frac{N + 1}{2}$ ，占用 $O(N)$ 额外空间。</p><h3 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 28. 对称的二叉树</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1  </span><br><span class="line">   &#x2F; \  </span><br><span class="line">  2   2  </span><br><span class="line"> &#x2F; \ &#x2F; \  </span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1  </span><br><span class="line"> &#x2F; \  </span><br><span class="line">2   2  </span><br><span class="line"> \   \  </span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>0 &lt;= 节点个数 &lt;= 1000</code></p><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：递归</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> judge(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(TreeNode* l, TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果两个节点皆为空，返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 一个节点为空，另一个节点非空，返回 false</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!l || !r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    	<span class="comment">// 数值不同，返回 false</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l-&gt;val != r-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> judge(l-&gt;left, r-&gt;right) &amp;&amp; judge(l-&gt;right, r-&gt;left);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$，其中 <em>N</em> 为二叉树的节点数量，每次执行 <code>judge()</code> 可以判断一对节点是否对称，因此最多调用 N<em>/2 次 <code>judge()</code> 方法。<br><em>*空间复杂度：</em></em>$O(N)$， 最差情况下（当二叉树退化为链表），递归时系统需使用 $O(N)$ 大小的栈空间。</p><p><strong><font color="F08F00">方法二：迭代</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>  (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root-&gt;left);</span><br><span class="line">        q.push(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            TreeNode* u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            TreeNode* v = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (!u &amp;&amp; !v) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((!u || !v) || (u-&gt;val != v-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q.push(u-&gt;left);</span><br><span class="line">            q.push(v-&gt;right);</span><br><span class="line">            q.push(u-&gt;right);</span><br><span class="line">            q.push(v-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(N)$， 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点。<br>空间复杂度：$O(N) $， 这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 <em>n</em> 个点，故渐进空间复杂度为 $O(N) $</p><h3 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - I. 从上到下打印二叉树</a></h3><p>Difficulty: <strong><font color="F08000">中等</font></strong></p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                res.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                path.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h3><p>Difficulty: <strong><font color="F08000">中等</font></strong></p><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            level++;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                path.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                reverse(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>剑指offer32</strong> 3 道题目时间空间复杂度分析相同</p><p><strong>时间复杂度：</strong> $O(N)$， N 为二叉树的节点数量，即 BFS 需循环 N 次。<br><strong>空间复杂度 ：</strong>$O(N)$，最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 $O(N)$ 大小的额外空间。</p><h3 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 34. 二叉树中和为某一值的路径</a></h3><p>Difficulty: <strong><font color="F08000">中等</font></strong></p><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>target = 22</code>，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure><p>返回:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 10000</code></li></ol><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        dfs(root, sum, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 只要 root 非空</span></span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="comment">// 如果处理该节点后满足 sum 条件，且是叶子节点，则找到一个数值</span></span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span> &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, sum, path);</span><br><span class="line">        dfs(root-&gt;right, sum, path);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$， 其中 N 为二叉树的节点数量，需要遍历树的所有节点。<br><strong>空间复杂度：</strong>$O(N)$， 最差情况下（当二叉树退化为链表），path 存储所有节点，使用额外 $O(N)$ 空间</p><h3 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 36. 二叉搜索树与双向链表</a></h3><p>Difficulty: <strong><font color="F08000">中等</font></strong></p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png" alt></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" alt></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = NULL;</span></span><br><span class="line"><span class="comment">        right = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        recur(root);</span><br><span class="line">        <span class="comment">// 首尾相连 :  pre &lt;-- head,   pre --&gt; head;</span></span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* pre, head;</span><br><span class="line">    <span class="comment">//  中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(Node* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur) <span class="keyword">return</span>;</span><br><span class="line">        recur(cur-&gt;left);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前向存在，则 pre 右为 cur : pre  --&gt; cur</span></span><br><span class="line">        <span class="keyword">if</span> (pre) pre-&gt;right = cur;</span><br><span class="line">        <span class="comment">// 否则说明当前 cur 为中序遍历最左侧子节点，也即是 head</span></span><br><span class="line">        <span class="keyword">else</span> head = cur;</span><br><span class="line">        <span class="comment">// 确定 cur 的左连接为 pre :  pre &lt;-- cur</span></span><br><span class="line">        cur-&gt;left = pre;</span><br><span class="line">        <span class="comment">// pre 向后遍历</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        </span><br><span class="line">        recur(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(N)$， 其中 N 为二叉树的节点数量，需要遍历树的所有节点。<br><strong>空间复杂度：</strong>$O(N)$， 最差情况下（当二叉树退化为链表），递归深度 N，使用系统 $O(N)$ 栈空间。</p><h3 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 37. 序列化二叉树</a></h3><p>Difficulty: <strong><font color="FF0000">困难</font></strong></p><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你可以将以下二叉树：</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果根节点为空则说明返回 "[]"</span></span><br><span class="line">        <span class="comment">// 层次遍历方法</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="comment">// 初始化先键入 [</span></span><br><span class="line">        <span class="built_in">string</span> data&#123;<span class="string">"["</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            TreeNode* node = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="comment">// 如果当前节点存在的话</span></span><br><span class="line">            <span class="keyword">if</span>(node) &#123;</span><br><span class="line">                <span class="comment">// 键入 val,</span></span><br><span class="line">                data.append(to_string(node-&gt;val));</span><br><span class="line">                data.append(<span class="string">","</span>);</span><br><span class="line">                <span class="comment">// 键入 左右节点，是否为空不用判断</span></span><br><span class="line">                que.push(node-&gt;left);</span><br><span class="line">                que.push(node-&gt;right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果为空，输入 null, 即可</span></span><br><span class="line">                data.append(<span class="string">"null,"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到最后是数字的位置</span></span><br><span class="line">        <span class="keyword">size_t</span> post = data.find_last_of(<span class="string">"0123456789"</span>);</span><br><span class="line">        <span class="comment">// 截取所需字符，也就是去除多添加的 null,</span></span><br><span class="line">        data = data.substr(<span class="number">0</span>, post + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 末尾添加 ]</span></span><br><span class="line">        data.append(<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果接受的字符串为 [] 则说明为空</span></span><br><span class="line">        <span class="keyword">if</span>(data == <span class="string">"[]"</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 去 "[ ]"</span></span><br><span class="line">        <span class="keyword">size_t</span> len = data.<span class="built_in">size</span>();</span><br><span class="line">        data = data.substr(<span class="number">1</span>, len - <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 提取 data 中所需的字符，也即是去除 ','</span></span><br><span class="line">        <span class="comment">// 所需字符存于 vector&lt;string&gt; 中</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        <span class="comment">// 用于记录中间变量</span></span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 遇到 ',' 则存入一次 string</span></span><br><span class="line">            <span class="keyword">if</span> (data[i] == <span class="string">','</span>) &#123;</span><br><span class="line">                vec.push_back(temp);</span><br><span class="line">                temp = <span class="string">""</span>;</span><br><span class="line">            <span class="comment">// 到达末尾，也进行存入 string 操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == data.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                temp += data[i];</span><br><span class="line">                vec.push_back(temp);</span><br><span class="line">                temp = <span class="string">""</span>;</span><br><span class="line">            <span class="comment">// 除此之外，只要更新 string 即可</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp += data[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先现根据 vec[0] 创建根节点</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(vec[<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            <span class="comment">// 如果 null 的话会逐渐的被 pop 出</span></span><br><span class="line">            TreeNode* node = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="comment">// 不是 null，先创建左节点</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; vec.<span class="built_in">size</span>() &amp;&amp; vec[i] != <span class="string">"null"</span>) &#123;</span><br><span class="line">                node-&gt;left = <span class="keyword">new</span> TreeNode(stoi(vec[i]));</span><br><span class="line">                que.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">// 后创建右节点</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; vec.<span class="built_in">size</span>() &amp;&amp; vec[i] != <span class="string">"null"</span>) &#123;</span><br><span class="line">                node-&gt;right = <span class="keyword">new</span> TreeNode(stoi(vec[i]));</span><br><span class="line">                que.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure><p>序列化，反序列化时间空间复杂度相同。其中 N 为可能的节点数。</p><p><strong>时间复杂度：</strong> $O(N)$</p><p><strong>空间复杂度</strong>：$O(N)$</p><h3 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 38. 字符串的排列</a></h3><p>Difficulty: <strong><font color="F08000">中等</font></strong></p><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>1 &lt;= s 的长度 &lt;= 8</code></p><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：常规回溯</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该方法遍历所有可能，最后在输入的时候通过再一次的查找重复项来去重，会超时 ！</span></span><br><span class="line"><span class="comment">// 该方法使用了记忆化，但是并没有用来去重，而是避免重复选择使用同一个位置元素而已</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">string</span> path;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(s.<span class="built_in">size</span>(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        backtracking(s, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 通过查找来判断是否存在重复项</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>()) == res.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                res.push_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次都遍历全部长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            path += s[i];</span><br><span class="line">            backtracking(s, visited);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="F08F00">方法二：记忆化回溯</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">string</span> path;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要提前排序</span></span><br><span class="line">        sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(len)</span></span>;</span><br><span class="line">        backtracking(s, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 关键在于同层去重，可以剪枝，具体详见备注</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] == s[i] &amp;&amp; visited[i - <span class="number">1</span>] == <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                path += s[i];</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                backtracking(s, visited);</span><br><span class="line">                visited[i] = <span class="literal">false</span>;</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">备注</font></strong> ：carl 大佬写的两篇相关文章，感受颇深！</p><p><strong>去重思路</strong>：<a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&amp;mid=2247485360&amp;idx=1&amp;sn=2256a0f01a304d82a2b59252327f3edb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">回溯算法：求组合总和（三）</a></p><p><strong>树层上去重，与树枝上去重的区别</strong>：<a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&amp;mid=2247485514&amp;idx=1&amp;sn=29aa5828c0847fe39d2ea90804fba69e&amp;chksm=f9a23b1bced5b20d3b7b6e5502ad229e4be53cee7c9b3047c0fc23d595ea7cad03d407ccf789&amp;scene=178&amp;cur_album_id=1607983171550167042#rd" target="_blank" rel="noopener">回溯算法：排列问题（二） (qq.com)</a></p><p><strong><font color="F08F00">方法三：交换思想求取排列</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        dfs(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == s.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            res.push_back(s);                       <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">find</span>(s[i]) != st.<span class="built_in">end</span>()) <span class="keyword">continue</span>; <span class="comment">// 重复，因此剪枝</span></span><br><span class="line">            st.insert(s[i]);</span><br><span class="line">            swap(s[i], s[x]);                       <span class="comment">// 交换，将 s[i] 固定在第 x 位</span></span><br><span class="line">            dfs(s, x + <span class="number">1</span>);                          <span class="comment">// 开启固定第 x + 1 位字符</span></span><br><span class="line">            swap(s[i], s[x]);                       <span class="comment">// 恢复交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/字符串的排列时间空间复杂度.png" style="zoom:67%"></p><h3 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 54. 二叉搜索树的第k大节点</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p>1 ≤ k ≤ 二叉搜索树元素个数</p><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        count = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 二叉搜索树的中序遍历为递增序列，所以反向中序遍历可以获得递减序列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (!count) &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - I. 二叉树的深度</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>例如：</p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 10000</code></li></ol><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度 ：</strong>$O(N)$， N 为树的节点数量，计算树的深度需要遍历所有节点。<br><strong>空间复杂度：</strong>$O(N)$， 最差情况下（当树退化为链表时），递归深度可达到 N 。</p><h3 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - II. 平衡二叉树</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p><strong>示例 1:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回 <code>true</code> 。</p><p><strong>示例 2:</strong></p><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>返回 <code>false</code> 。</p><p><strong>限制：</strong></p><ul><li><code>0 &lt;= 树的结点个数 &lt;= 10000</code></li></ul><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：先序遍历 + 判断深度</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(dfs(root-&gt;left) - dfs(root-&gt;right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dfs(root-&gt;left), dfs(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/平衡二叉树方法一时间空间复杂度分析.png" alt></p><p><strong><font color="F08F00">方法二：后序遍历 + 剪枝</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> getDep(root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDep</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getDep(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = getDep(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度 ：</strong>$O(N)$， N 为树的节点数量，计算树的深度需要遍历所有节点。<br><strong>空间复杂度：</strong>$O(N)$， 最差情况下（当树退化为链表时），递归深度可达到 N 。</p><h3 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">剑指 Offer 64. 求1+2+…+n</a></h3><p>Difficulty: <strong><font color="F08000">中等</font></strong></p><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt;= 10000</code></li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用门电路实现判断语句</span></span><br><span class="line">        n &gt; <span class="number">1</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(n) $， 计算 $n + (n-1) + … + 2 + 1n+(n−1)+…+2+1$ 需要开启 n 个递归函数。<br><strong>空间复杂度：</strong> $O(n)$， 递归深度达到 n ，系统使用 $O(n)$ 大小的额外空间。</p><h3 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><p><strong>Solution</strong></p><p><strong><font color="F08F00">方法一：递归</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N)$ ，其中 N 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 $\log N$（满二叉树），最大为 N （退化为链表）。<br><strong>空间复杂度：</strong> $O(N)$ ， 最差情况下，即树退化为链表时，递归深度达到树的层数 N 。</p><p><strong><font color="F08F00">方法二：迭代</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提前比较p和q的大小，可以使得在循环中可减少判断条件，提升计算效率 </span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &gt; q-&gt;val)</span><br><span class="line">            swap(p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// p,q 都在 root 的右子树中</span></span><br><span class="line">            <span class="comment">// if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) </span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &lt; p-&gt;val) <span class="comment">// p,q 都在 root 的右子树中</span></span><br><span class="line">                root = root-&gt;right; <span class="comment">// 遍历至右子节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// p,q 都在 root 的左子树中</span></span><br><span class="line">            <span class="comment">// else if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; q-&gt;val) <span class="comment">// p,q 都在 root 的左子树中</span></span><br><span class="line">                root = root-&gt;left; <span class="comment">// 遍历至左子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N)$ ，其中 N 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 $\log N$（满二叉树），最大为 N （退化为链表）。<br><strong>空间复杂度：</strong> $O(1)$ ，使用常数大小的额外空间。</p><h3 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || p == root || q == root) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p , q);</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p , q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!left) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!right) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度 ：</strong>$O(N)$， N 为树的节点数量，计算树的深度需要遍历所有节点。<br><strong>空间复杂度：</strong>$O(N)$， 最差情况下（当树退化为链表时），递归深度可达到 N 。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/" target="_blank" rel="noopener">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNjY5NTYxNA==&amp;action=getalbum&amp;album_id=1485825793120387074&amp;scene=173&amp;from_msgid=2247485360&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect" target="_blank" rel="noopener">#数据结构与算法 (qq.com)</a></p><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 (leetcode-cn.com)</a> 官方题解</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Data_Structure_and_Algorithm</category>
      </categories>
      <tags>
        <tag>搜索与回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer -- 位运算</title>
    <url>/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="剑指offer-—-位运算"><a href="#剑指offer-—-位运算" class="headerlink" title="剑指offer — 位运算"></a>剑指offer — 位运算</h2><h3 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 15. 二进制中1的个数</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li></ul><p><strong>Solution</strong></p><p><strong><font color="F0800F">方法一：逐位运算</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += n % <span class="number">2</span>;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(log_2n)$</p><p><strong>空间复杂度：</strong> $O(1)$</p><p><strong><font color="F0800F">方法二：n &amp; n - 1</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(M)$ ，M 为二进制数字 n 中 1 的<strong>个数</strong></p><p><strong>空间复杂度：</strong> $O(1)$</p><h3 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - I. 数组中数字出现的次数</a></h3><p>Difficulty: <strong><font color="F08000">中等</font></strong></p><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 10000</code></li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获得两个只出现一次数字的异或值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            n ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过该异或值，求出其最后一个位数 1 所在位置，以此对数组分组</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// ！特别需要注意的是 &amp; 操作时需要加 (), 其优先级小于 == ， 下同</span></span><br><span class="line">        <span class="keyword">while</span> ((n &amp; c) == <span class="number">0</span>) &#123;</span><br><span class="line">            c &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组中的数字分组, </span></span><br><span class="line">        <span class="comment">// a 中存 c 位置，二进制为 1 的所有数异或和</span></span><br><span class="line">        <span class="comment">// b 中则存相反情况</span></span><br><span class="line">        <span class="comment">// 这样这两个只出现一次的数字被分开</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="comment">// 注意 ()</span></span><br><span class="line">            <span class="keyword">if</span> ((c &amp; num) == <span class="number">0</span>) a ^= num;</span><br><span class="line">            <span class="keyword">else</span> b ^= num;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N)$</p><p><strong>空间复杂度：</strong> $O(1)$</p><h3 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h3><p>Difficulty: <strong><font color="F08000">中等</font></strong></p><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,3,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10000</code></li><li><code>1 &lt;= nums[i] &lt; 2^31</code></li></ul><p><strong>Solution</strong></p><p><strong><font color="F0800F">方法一：哈希表</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            hashmap[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [r, t] : hashmap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N)$，遍历一次数组，一次哈希表即可，$O(N + (N - 1) / 3 + 1) \approx O(N)$。</p><p><strong>空间复杂度：</strong> $O(N)$，哈希表需要空间 $O((N - 1) / 3 + 1) \approx O(N)$。</p><p><strong><font color="F0800F">方法二：遍历统计</font></strong>，该方法可以通用 m &gt; 1 的所有情况</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法可以通用 m &gt; 1 的所有情况</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 用来记录当前位 1 的个数之和</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">                <span class="comment">// 当前位置是 1 时，count++;</span></span><br><span class="line">                <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i))) count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果统计结果 mod m == 1，则说明当前 1 多余，</span></span><br><span class="line">            <span class="comment">// 也就是所求数字 1 的相应位置</span></span><br><span class="line">            <span class="keyword">if</span> (count % m == <span class="number">1</span>) &#123;</span><br><span class="line">                res |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N)$</p><p><strong>空间复杂度：</strong> $O(1)$</p><p><strong><font color="F0800F">方法三：有限状态机</font></strong>，数字电路方法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 真值表 表头 n a b</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; n : nums) &#123;</span><br><span class="line">            b = ~a &amp; (b ^ n);</span><br><span class="line">            <span class="comment">// a = (~a &amp; b &amp; n) | (a &amp; ~b &amp; ~n) 经过优化</span></span><br><span class="line">            a = ~b &amp; (a ^ n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化方式：<a href="https://leetcode-cn.com/problems/single-number-ii/solution/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetc-23t6/" target="_blank" rel="noopener">只出现一次的数字 II - 只出现一次的数字 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><strong>时间复杂度：</strong> $O(N)$</p><p><strong>空间复杂度：</strong> $O(1)$</p><h3 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">剑指 Offer 65. 不用加减乘除做加法</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: a &#x3D; 1, b &#x3D; 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>a</code>, <code>b</code> 均可能是负数或 0</li><li>结果不会溢出 32 位整数</li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 主要思想就是将带进位的加法，转变成无进位加法 + 进位值，两个部分分开计算</span></span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="comment">// c 代表进位，只有 a b 当前位皆为 1 才会进位</span></span><br><span class="line">            <span class="comment">// 每一位可能的进位，左移 1 位来实现</span></span><br><span class="line">            <span class="keyword">int</span> c = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 二进制无进位加法就是异或操作</span></span><br><span class="line">            a ^= b;</span><br><span class="line">            <span class="comment">// 将进位情况变成下一次的加数</span></span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(1)$，最大情况 32 次循环</p><p><strong>空间复杂度：</strong> $O(1)$</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/" target="_blank" rel="noopener">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 (leetcode-cn.com)</a> 官方题解</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Data_Structure_and_Algorithm</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer -- 模拟</title>
    <url>/Data_Structure_and_Algorithm/%E5%89%91%E6%8C%87offer/%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="剑指offer-—-模拟"><a href="#剑指offer-—-模拟" class="headerlink" title="剑指offer — 模拟"></a>剑指offer — 模拟</h2><h3 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">剑指 Offer 29. 顺时针打印矩阵</a></h3><p>Difficulty: <strong><font color="008F00">简单</font></strong></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= matrix.length &lt;= 100</code></li><li><code>0 &lt;= matrix[i].length &lt;= 100</code></li></ul><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="comment">// 四个边界条件</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, t = <span class="number">0</span>, b = n - <span class="number">1</span>, r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向右输出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) res.push_back(matrix[t][i]);</span><br><span class="line">            <span class="comment">// 如果当前循环至最底层 退出</span></span><br><span class="line">            <span class="keyword">if</span> (++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 向下输出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= b; i++) res.push_back(matrix[i][r]);</span><br><span class="line">            <span class="comment">// 如果当前循环至最左 退出</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 向左输出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; i--) res.push_back(matrix[b][i]);</span><br><span class="line">            <span class="comment">// 如果当前循环至最上 退出</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 向上输出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &gt;= t; i--) res.push_back(matrix[i][l]);</span><br><span class="line">            <span class="comment">// 如果当前循环至最右 退出</span></span><br><span class="line">            <span class="keyword">if</span> (++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(M\cdot N)$</p><p><strong>空间复杂度：</strong> $O(1)$，只需要四个方向变量，其中 res 是输出要求空间，不算做算法空间。</p><h3 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 31. 栈的压入、弹出序列</a></h3><p>Difficulty: <strong><font color="F08000">中等</font></strong></p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li><li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li><li><code>pushed</code> 是 <code>popped</code> 的排列。</li></ol><p><strong>Solution</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : pushed) &#123;</span><br><span class="line">            stk.push(num);</span><br><span class="line">            <span class="comment">// 因为 pushed 与 popped 长度相同，不可能出现 i 在循环中超限的情况</span></span><br><span class="line">            <span class="comment">// 所以不用单独为 i 设定判断条件</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top() == popped[i]) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong> $O(N)$，同时遍历一次数组</p><p><strong>空间复杂度：</strong> $O(N)$，额外栈空间</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/" target="_blank" rel="noopener">图解算法数据结构 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台 (leetcode-cn.com)</a> 官方题解</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Data_Structure_and_Algorithm</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB 常用命令</title>
    <url>/Complie_and_Debug/GDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h3 id="GDB-常用命令"><a href="#GDB-常用命令" class="headerlink" title="GDB 常用命令"></a>GDB 常用命令</h3><p><strong>基本指令</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中 -o 指定输出文件名, -g 指定可以调试  -m64 选项编译为64位</span></span><br><span class="line">gcc bugging.c -o bugging -g -m64</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 进入gdb 调试 bugging 程序</span></span><br><span class="line">gdb bugging</span><br><span class="line"></span><br><span class="line"><span class="comment">// (gdb) -&gt; 表示在gdb 命令行界面 </span></span><br><span class="line"><span class="comment">// 执行调试程序 </span></span><br><span class="line">(gdb) <span class="built_in">run</span>  </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 退出gdb</span></span><br><span class="line">(gdb) quit</span><br></pre></td></tr></table></figure><p><strong>常用命令表</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">简写</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">list</td><td style="text-align:center">l</td><td style="text-align:center">查看源码（10行）</td></tr><tr><td style="text-align:center">backtrace</td><td style="text-align:center">bt, where</td><td style="text-align:center">打印函数栈信息</td></tr><tr><td style="text-align:center">next</td><td style="text-align:center">n</td><td style="text-align:center">执行下一行，逐行</td></tr><tr><td style="text-align:center">step</td><td style="text-align:center">s</td><td style="text-align:center">一次执行一行，逐过程，会步入</td></tr><tr><td style="text-align:center">finish</td><td style="text-align:center"></td><td style="text-align:center">运行到函数结束</td></tr><tr><td style="text-align:center">continue</td><td style="text-align:center">c</td><td style="text-align:center">继续运行</td></tr><tr><td style="text-align:center">break</td><td style="text-align:center">b</td><td style="text-align:center">设置断点</td></tr><tr><td style="text-align:center">info breakpoints</td><td style="text-align:center"></td><td style="text-align:center">显示断点信息</td></tr><tr><td style="text-align:center">delete</td><td style="text-align:center">d</td><td style="text-align:center">删除断点</td></tr><tr><td style="text-align:center">print</td><td style="text-align:center">p</td><td style="text-align:center">打印表达式的值</td></tr><tr><td style="text-align:center">run</td><td style="text-align:center">r</td><td style="text-align:center">启动程序</td></tr><tr><td style="text-align:center">until</td><td style="text-align:center">u</td><td style="text-align:center">执行到指定行</td></tr><tr><td style="text-align:center">info</td><td style="text-align:center">i</td><td style="text-align:center">显示信息</td></tr><tr><td style="text-align:center">help</td><td style="text-align:center">h</td><td style="text-align:center">帮助信息</td></tr></tbody></table></div><p><strong>补充</strong></p><p><code>list 行号</code> 显示行号附近10 行</p><p><code>list 函数名</code> 显示函数附近10 行</p><p><code>break 行号</code> 在行号位置打断点</p><p><code>break 文件名：行号</code> 在某文件行号位置打断点</p><p><code>break 函数名</code> 在函数处打断点</p><p><code>break 文件名：函数名</code> 在某文件内函数处打断点</p><p><code>info breakpoints</code> 显示当前断点信息</p><ul><li><code>Num</code> 代表断点编号</li><li><code>Type</code> 代表断点类型</li><li><code>Disp</code>代表断点被命中后，该断点保留(<code>keep</code>)，删除(<code>del</code>)，关闭(<code>dis</code>)</li><li><code>Enb</code> 代表断点 enable(<code>y</code>)，disable(<code>n</code>)</li><li><code>Addreee</code> 代表断点处虚拟内存地址</li><li><code>What</code> 代表断点源文件信息</li></ul><p><code>delete</code> 删除所有断点</p><p><code>delete Num</code> 删除指定断点</p><p><code>enable Num</code> 开启指定断点</p><p><code>enable once Num</code> 断点 hit 一次之后关闭该断点</p><p><code>enable delete Num</code> 断点 hit 一次之后删除该断点</p><p><code>disable Num</code> 关闭指定断点</p><p><code>info locals</code> 打印当前断点处所在函数的所有局部变量，不包括函数参数</p><p><code>print 变量或表达式</code> 打印表达式的值，可显示当前函数的变量值，全局变量的值</p><p><code>next (N)</code> 单步执行 (N 次) —&gt; <strong><em>不会进入函数内部</em></strong></p><p><code>step (N)</code> 单步执行 (N 次) —&gt; <strong><em>会进入函数内部</em></strong></p><p><code>continue</code> 继续</p><p><code>until N</code> 执行到程序第 N 行</p><p><code>display varname</code> 追踪变量</p><p><code>undisplay varnum</code> 关闭追踪， varnum 可以由 <code>info display</code> 来查看</p><p><code>set follow-fork-mode [parent|child]</code> 选择父子进程调试</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Complie_and_Debug</category>
      </categories>
      <tags>
        <tag>GDB - Complie_and_Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile 格式</title>
    <url>/Complie_and_Debug/makefile%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="makefile-格式"><a href="#makefile-格式" class="headerlink" title="makefile 格式"></a>makefile 格式</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是注释</span></span><br><span class="line"><span class="comment"># 第一层：显示规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###   目标文件：依赖文件</span></span><br><span class="line"><span class="comment">###  【Tab】 指令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个目标文件是最终目标</span></span><br><span class="line"><span class="section">hello.exe: hello.o other.o</span></span><br><span class="line">	gcc hello.o other.o -o hello.exe</span><br><span class="line"></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	gcc -c hello.c -o hello.o</span><br><span class="line"><span class="section">other.o: other.c</span></span><br><span class="line">	gcc -c other.c -o other.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪目标：.PHONY:</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf hello.o other.o hello.exe</span><br></pre></td></tr></table></figure><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二层</span></span><br><span class="line"><span class="comment"># 变量 =（替换） +=（追加） :=（恒等于）</span></span><br><span class="line"></span><br><span class="line">TAR = hello.exe</span><br><span class="line">OBJ = hello.o other.o</span><br><span class="line">CC := gcc</span><br><span class="line">RMRF := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TAR)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">	CC <span class="variable">$(OBJ)</span> -o <span class="variable">$(TAR)</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">	CC -c hello.c -o hello.o</span><br><span class="line"><span class="section">other.o: other.c</span></span><br><span class="line">	CC -c other.c -o other.o</span><br><span class="line">	</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(RMRF)</span> <span class="variable">$(OBJ)</span> <span class="variable">$(TAR)</span></span><br></pre></td></tr></table></figure><h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第三层 隐含规则 </span></span><br><span class="line"><span class="comment"># %.c %.o *.c *.o  </span></span><br><span class="line"><span class="comment"># %（任意的）   </span></span><br><span class="line"><span class="comment"># *（所有的）</span></span><br><span class="line"></span><br><span class="line">TAR = hello.exe</span><br><span class="line">OBJ = hello.o other.o</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TAR)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(OBJ)</span> -o <span class="variable">$(TAR)</span></span><br><span class="line">	</span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c %.c -o %.o	</span><br><span class="line">	</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(OBJ)</span> <span class="variable">$(TAR)</span></span><br></pre></td></tr></table></figure><h3 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第四层 通配符</span></span><br><span class="line"><span class="comment"># $^ 所有的依赖文件 </span></span><br><span class="line"><span class="comment"># $@ 所有的目标文件</span></span><br><span class="line"><span class="comment"># $&lt; 所有依赖文件的第一个文件</span></span><br><span class="line"></span><br><span class="line">TAR = hello.exe</span><br><span class="line">OBJ = hello.o other.o</span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TAR)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(OBJ)</span> <span class="variable">$(TAR)</span></span><br></pre></td></tr></table></figure><h3 id="多可执行文件"><a href="#多可执行文件" class="headerlink" title="多可执行文件"></a>多可执行文件</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多可执行文件</span></span><br><span class="line"><span class="comment"># all hello.exe hello_1.exe</span></span><br><span class="line"></span><br><span class="line">TAR1 = hello.exe</span><br><span class="line">TAR2 = hello_1.exe</span><br><span class="line"></span><br><span class="line">OBJ1 = hello.o other.o</span><br><span class="line">OBJ2 = hello_1.o other_1.o</span><br><span class="line"></span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键是 all : %.exe %.exe</span></span><br><span class="line"><span class="section">all: hello.exe hello_1.exe</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TAR1)</span>: <span class="variable">$(OBJ1)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="variable">$(TAR2)</span>: <span class="variable">$(OBJ2)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span>  </span><br><span class="line">	</span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">	</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(OBJ1)</span> <span class="variable">$(OBJ2)</span> <span class="variable">$(TAR1)</span> <span class="variable">$(TAR2)</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Complie_and_Debug</category>
      </categories>
      <tags>
        <tag>Complie_and_Debug - makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11 并发多线程</title>
    <url>/Network_Communications/C++_Multithreading/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h3 id="一、线程启动、结束，创建线程的多种方法、join，detach"><a href="#一、线程启动、结束，创建线程的多种方法、join，detach" class="headerlink" title="一、线程启动、结束，创建线程的多种方法、join，detach"></a>一、线程启动、结束，创建线程的多种方法、join，detach</h3><ul><li><strong><code>thread</code></strong></li><li><strong><code>join()</code> , <code>detach()</code> , <code>joinable()</code></strong></li><li>用类，lambda 表达式创建</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程开始执行...."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程运行完毕...."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ta</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载函数运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程开始运行..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程运行完毕..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员函数：</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getMsg</span><span class="params">(<span class="keyword">int</span> input)</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveMsg</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// (1) 创建线程，myPrint为线程入口</span></span><br><span class="line">    <span class="comment">// 线程类参数是一个可调用对象</span></span><br><span class="line">    <span class="comment">// 可以是函数，函数指针，lambda表达式，bind创建的对象或者重载函数调用运算符的类对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ⅰ 以函数对象创建线程</span></span><br><span class="line">    <span class="function">thread <span class="title">myThread</span><span class="params">(myPrint)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ⅱ 以类对象创建线程</span></span><br><span class="line">    Ta ta;</span><br><span class="line">    <span class="function">thread <span class="title">myThread</span><span class="params">(ta)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ⅲ 以lambda表达式创建线程</span></span><br><span class="line">    <span class="keyword">auto</span> lambdaThread = [] &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程开始了..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程结束了..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">thread <span class="title">myThread</span><span class="params">(lambdaThread)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ⅳ 以类中成员函数</span></span><br><span class="line">    <span class="comment">// 第一个 &amp; 取地址，第二个 &amp; 引用，相当于 std::ref(s)</span></span><br><span class="line">    <span class="comment">// threadObj1(&amp;Ta::saveMsg, ta) 传值也是可以的，但是会调用一次构造函数，两次拷贝构造</span></span><br><span class="line">    <span class="comment">// threadObj1(&amp;Ta::saveMsg, &amp;ta) 传引用，会调用一次构造函数，一次拷贝构造</span></span><br><span class="line">    Ta ta;</span><br><span class="line">    <span class="keyword">int</span> input = <span class="number">0</span>;</span><br><span class="line">    <span class="function">thread <span class="title">threadObj1</span><span class="params">(&amp;Ta::saveMsg, &amp;ta)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">threadObj2</span><span class="params">(&amp;Ta::getMsg, &amp;ta, input)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (2) 阻塞主线程并等待 myThread 线程执行完毕</span></span><br><span class="line">    myThread.join();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (3) 不阻塞主线程，主线程往下执行，如果主线程退出，子线程还未结束</span></span><br><span class="line">    <span class="comment">// 将会由后台托管执行。</span></span><br><span class="line">    myThread.<span class="built_in">detach</span>();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// (4) join , detach 只能使用一个，可以使用 joinable 来进行辅助判断</span></span><br><span class="line">    <span class="comment">// 注：上述只是举例写法，真实代码环境，join,detach只能使用一个 </span></span><br><span class="line">    <span class="keyword">if</span> (myThread.joinable()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"可以调用join()，或者detach()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"不能调用join(), 或者detach()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 主线程打印语句</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、线程传参详解，detach-再探，类成员函数作为线程入口函数"><a href="#二、线程传参详解，detach-再探，类成员函数作为线程入口函数" class="headerlink" title="二、线程传参详解，detach()再探，类成员函数作为线程入口函数"></a>二、线程传参详解，detach()再探，类成员函数作为线程入口函数</h3><ul><li>传递临时对象作为线程参数，要避免的陷阱</li><li>临时对象作为线程参数，线程id，临时对象构造时机抓捕</li><li>传递类对象、只能指针作为线程参数</li><li>用成员函数指针做线程入口函数</li></ul><h4 id="2-1-可能的陷阱"><a href="#2-1-可能的陷阱" class="headerlink" title="2.1 可能的陷阱"></a>2.1 可能的陷阱</h4><p><strong><code>传递临时对象作为线程参数</code></strong> 要避免的<font color="FF0000">陷阱</font></p><p><strong>陷阱一：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i, <span class="keyword">char</span>* pmybuf)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果线程从主线程 detach 了</span></span><br><span class="line">	<span class="comment">// i 不是 mvar 真正的引用，实际上值传递，即使主线程运行完毕了，</span></span><br><span class="line">    <span class="comment">// 子线程用 i 仍然是安全的，但仍不推荐传递引用</span></span><br><span class="line">	<span class="comment">// 推荐改为 const int i</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// pmybuf还是指向原来的字符串，所以这么写是不安全的</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pmybuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mvar = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; mvary = mvar;</span><br><span class="line">	<span class="keyword">char</span> mybuf[] = <span class="string">"this is a test"</span>;</span><br><span class="line">    <span class="comment">// 第一个参数是函数名，后两个参数是函数的参数</span></span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, mvar, mybuf)</span></span>;</span><br><span class="line">	myThread.join();</span><br><span class="line">	<span class="comment">// myThread.detach();</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>陷阱二：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="built_in">string</span>&amp; pmybuf)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pmybuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mvar = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; mvary = mvar;</span><br><span class="line">	<span class="keyword">char</span> mybuf[] = <span class="string">"this is a test"</span>;</span><br><span class="line">	<span class="comment">// 如果 detach 了，这样仍然是不安全的</span></span><br><span class="line">	<span class="comment">// 因为存在主线程运行完了，mybuf被回收了，系统采用 mybuf 隐式类型转换成 string</span></span><br><span class="line">    <span class="comment">// 可能还没转化，主线程就已经结束了</span></span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, mvar, mybuf)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 推荐先创建一个临时对象,就绝对安全了。。。。</span></span><br><span class="line">    <span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, mvar, <span class="built_in">string</span>(mybuf))</span></span>;</span><br><span class="line">    </span><br><span class="line">	myThread.join();</span><br><span class="line">	<span class="comment">//myThread.detach();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>总结</p><ul><li>如果传递<strong>简单类型</strong>，如内置类型，推荐使用值传递，<strong>不要用引用</strong></li><li>如果传递<strong>类对象</strong>，<strong>避免使用隐式类型转换</strong>，全部都是创建线程这一行就创建出临时对象，然后在函数参数里，用引用来接，否则还会创建出一个对象</li><li>建议不使用 detach</li></ul><h4 id="2-2-线程-id"><a href="#2-2-线程-id" class="headerlink" title="2.2 线程 id"></a>2.2 线程 id</h4><p><strong><code>线程 Id</code></strong> 通过如下获取：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::this_thread::get_id();</span><br></pre></td></tr></table></figure><h4 id="2-3-传递-类对象-、-智能指针-作为线程参数"><a href="#2-3-传递-类对象-、-智能指针-作为线程参数" class="headerlink" title="2.3 传递 类对象 、 智能指针 作为线程参数"></a>2.3 传递 <strong><code>类对象</code></strong> 、 <strong><code>智能指针</code></strong> 作为线程参数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">mutable</span> <span class="keyword">int</span> m_i; <span class="comment">// m_i即使是在 const 中也可以被修改</span></span><br><span class="line">	A(<span class="keyword">int</span> i) :m_i(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">const</span> A&amp; pmybuf)</span> </span>&#123;</span><br><span class="line">	pmybuf.m_i = <span class="number">199</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程myPrint的参数地址是"</span> &lt;&lt; &amp;pmybuf &lt;&lt; <span class="string">"thread = "</span> </span><br><span class="line">          &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">myObj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">// myPrint(const A&amp; pmybuf)中引用不能去掉，如果去掉会多创建一个对象</span></span><br><span class="line">	<span class="comment">// const也不能去掉，去掉会出错</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 即使是传递的const引用，但在子线程中还是会调用拷贝构造函数构造一个新的对象，</span></span><br><span class="line">	<span class="comment">// 所以在子线程中修改m_i的值不会影响到主线程</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 如果希望子线程中修改m_i的值影响到主线程，</span></span><br><span class="line">    <span class="comment">// 可以用thread myThread(myPrint, std::ref(myObj));</span></span><br><span class="line">	<span class="comment">// 这样const就是真的引用了，myPrint定义中的const可以去掉了，类A定义中的mutable也可以去掉了</span></span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, myObj)</span></span>;</span><br><span class="line">	myThread.join();</span><br><span class="line">	<span class="comment">//myThread.detach();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; ptn)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">	<span class="comment">//独占式指针只能通过std::move()才可以传递给另一个指针</span></span><br><span class="line">	<span class="comment">//传递后 up 就指向空，新的 ptn 指向原来的内存</span></span><br><span class="line">	<span class="comment">//所以这时就不能用 detach 了，因为如果主线程先执行完，ptn指向的对象就被释放了</span></span><br><span class="line">	<span class="function">thread <span class="title">myThread</span><span class="params">(myPrint, <span class="built_in">std</span>::<span class="built_in">move</span>(up))</span></span>;</span><br><span class="line">	myThread.join();</span><br><span class="line">	<span class="comment">//myThread.detach();</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、创建多个进程、数据共享问题分析"><a href="#三、创建多个进程、数据共享问题分析" class="headerlink" title="三、创建多个进程、数据共享问题分析"></a>三、创建多个进程、数据共享问题分析</h3><h4 id="3-1-创建和等待多个线程"><a href="#3-1-创建和等待多个线程" class="headerlink" title="3.1 创建和等待多个线程"></a>3.1 创建和等待多个线程</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TextThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"我是线程"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">/*  …  */</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"线程"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">"执行结束"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数里   vector threadagg;</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;thread&gt; threadagg;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">         threadagg.push_back(thread(TextThread));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">         threadagg[i].join();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-数据共享问题分析"><a href="#3-2-数据共享问题分析" class="headerlink" title="3.2 数据共享问题分析"></a>3.2 数据共享问题分析</h4><ul><li>只读数据是安全稳定的</li><li>如果存在写操作，若不加处理就会出错</li></ul><h3 id="四、互斥量概念、用法、死锁"><a href="#四、互斥量概念、用法、死锁" class="headerlink" title="四、互斥量概念、用法、死锁"></a>四、互斥量概念、用法、死锁</h3><ul><li>互斥量（mutex）的基本概念</li><li>互斥量的用法： <strong><code>lock()</code> , <code>unlock()</code> , <code>std::lock_guard</code></strong> 类模板</li><li>死锁及一般解决方案， <strong><code>std::lock()</code></strong> 函数模板， <strong><code>std::lock_guard</code></strong> 的 <strong><code>std::adopt_lock</code></strong> 参数</li></ul><h4 id="4-1-互斥量的基本概念及用法"><a href="#4-1-互斥量的基本概念及用法" class="headerlink" title="4.1 互斥量的基本概念及用法"></a>4.1 互斥量的基本概念及用法</h4><p><strong>互斥量</strong>就是个<strong>类对象</strong>，可以理解为一把锁，多个线程尝试用 <strong><code>lock()</code></strong> 成员函数来加锁，只有一个线程能锁定成功，如果没有锁成功，那么流程将卡在 <strong><code>lock()</code></strong> 这里不断尝试去锁定。互斥量使用要小心，保护数据不多也不少，少了达不到效果，多了影响效率。</p><p>包含 <strong><code>#include&lt;mutex&gt;</code></strong> 头文件，成员函数有， <strong><code>lock()</code> ， <code>unlock()</code></strong> 。基本使用步骤：</p><ul><li><strong><code>lock()</code></strong></li><li>操作共享数据</li><li><strong><code>unlock()</code></strong></li></ul><p><strong><code>lock_guard类模板</code></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">lock_guard <span class="title">sbguard</span><span class="params">(myMutex)</span></span>;  <span class="comment">// 取代lock() 和 unlock()</span></span><br><span class="line"><span class="comment">// lock_guard构造函数执行了mutex::lock();</span></span><br><span class="line"><span class="comment">// 在作用域结束时，调用析构函数，执行mutex::unlock()</span></span><br></pre></td></tr></table></figure><h4 id="4-2-死锁"><a href="#4-2-死锁" class="headerlink" title="4.2 死锁"></a>4.2 死锁</h4><p>两个以上互斥量使用，相互竞争，都在争锁，不释放已有锁。主要<strong>解决办法</strong>是保证多个互斥量上锁的顺序合理。</p><p><strong><code>std::lock()</code></strong> 函数模板</p><ul><li><strong><code>std::lock(mutex1, mutex2,...);</code></strong> 一次性锁定多个互斥量，用于<strong>处理多个互斥量</strong>。</li><li>如果互斥量中一个没锁住，他就等着，等所有互斥量锁住，才能继续执行。如果有一个没锁住，就会把已经锁住的释放掉（要么互斥量都锁住，要么都没锁住，防止死锁）</li></ul><p><strong><code>std::lock_guard</code> </strong>中 <strong><code>std::adopt_lock</code></strong> 参数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加入adopt_lock后，在调用lock_guard的构造函数时，不再进行lock();</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">my_guard</span><span class="params">(my_mutex, <span class="built_in">std</span>::adopt_lock)</span></span>; </span><br><span class="line"><span class="comment">// adopt_guard为结构体对象，起一个标记作用，表示这个互斥量已经lock()，不需要在lock()。</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"插入一个元素"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="comment">//lock_guard&lt;mutex&gt; sbguard(myMutex1, adopt_lock);</span></span><br><span class="line">				lock(myMutex1, myMutex2);</span><br><span class="line">				<span class="comment">//myMutex2.lock();</span></span><br><span class="line">				<span class="comment">//myMutex1.lock();</span></span><br><span class="line">				msgRecvQueue.push_back(i);</span><br><span class="line">				myMutex1.unlock();</span><br><span class="line">				myMutex2.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">outMsgLULProc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		myMutex1.lock();</span><br><span class="line">		myMutex2.lock();</span><br><span class="line">		<span class="keyword">if</span> (!msgRecvQueue.empty()) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"删除元素"</span> &lt;&lt; msgRecvQueue.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			msgRecvQueue.pop_front();</span><br><span class="line">			myMutex2.unlock();</span><br><span class="line">			myMutex1.unlock();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		myMutex2.unlock();</span><br><span class="line">		myMutex1.unlock();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (outMsgLULProc()) &#123;&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"数组为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; msgRecvQueue;</span><br><span class="line">	mutex myMutex1;</span><br><span class="line">	mutex myMutex2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A myobja;</span><br><span class="line">	mutex myMutex;</span><br><span class="line">	<span class="function">thread <span class="title">myOutMsgObj</span><span class="params">(&amp;A::outMsgRecvQueue, &amp;myobja)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">myInMsgObj</span><span class="params">(&amp;A::inMsgRecvQueue, &amp;myobja)</span></span>;</span><br><span class="line">	myOutMsgObj.join();</span><br><span class="line">	myInMsgObj.join();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、unique-lock-模板类"><a href="#五、unique-lock-模板类" class="headerlink" title="五、unique_lock 模板类"></a>五、unique_lock 模板类</h3><ul><li><strong><code>unique_lock</code></strong> 取代 <strong><code>lock_guard</code></strong> （优点：灵活，缺点：效率降低）</li><li><strong><code>unique_lock</code></strong> 的第二个参数： <strong><code>std::adopt_lock，std::try_to_lock，std::defer_lock</code></strong></li><li><strong><code>unique_lock</code></strong> 的成员函数： <strong><code>lock()，unlock()，try_lock()，release()</code></strong></li><li><strong><code>unique_lock</code></strong> 所有权的传递</li></ul><h4 id="5-1-unique-lock-的第二个参数"><a href="#5-1-unique-lock-的第二个参数" class="headerlink" title="5.1 unique_lock 的第二个参数:"></a>5.1 unique_lock 的第二个参数:</h4><p><strong><code>std::adopt_lock</code></strong></p><ul><li>表示这个互斥量已经被 <strong><code>lock()</code></strong> ，即不需要在构造函数中 lock 这个互斥量</li><li><strong><font color="FF0000">前提必须提前lock</font></strong>， <strong><code>lock_guard</code></strong> 也可以用这个参数</li></ul><p><strong><code>std::try_to_lock</code></strong></p><ul><li>尝试用 mutex 的 <strong><code>lock()</code></strong> 去锁定这个 mutex，如果没有成功，会立即返回，不会阻塞。</li><li>使用 <strong><code>try_to_lock()</code></strong> 的原因是：防止其他的线程锁定的 mutex 太长时间，导致本线程一直阻塞在 lock 这个地方</li><li><font color="FF0000">**前提不能提前 lock()**</font></li><li><strong><code>owns_lock()</code></strong> 方法判断是否拿到锁，如果拿到返回 true</li></ul><p><strong><code>std::defer_lock</code></strong></p><ul><li>如果没有第二个参数就对 mutex 加锁，加上 <strong><code>defer_lock</code></strong> 是初始化一个没有加锁的mutex</li><li>不给他加锁的目的是以后可以调用 <strong><code>unique_lock</code></strong> 的一些方法</li><li><font color="FF0000">**前提不能提前 lock()**</font></li></ul><p><strong>unique_lock的成员函数（前三个与 <code>std::defer_lock</code> 联合使用）</strong></p><p><strong><code>lock()</code></strong> ：加锁</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock</span><span class="params">(myMutex, defer_lock)</span></span>; <span class="comment">// 本质是所有权的转移</span></span><br><span class="line">myUniLock.lock(); <span class="comment">// 不用自己 unlock</span></span><br></pre></td></tr></table></figure><p><strong><code>unlock()</code></strong> ：解锁</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock</span><span class="params">(myMutex, defer_lock)</span></span>;</span><br><span class="line">myUniLock.lock();</span><br><span class="line"><span class="comment">// .... 处理一些共享代码</span></span><br><span class="line">myUniLock.unlock();</span><br><span class="line"><span class="comment">// .... 处理一些非共享代码</span></span><br><span class="line"><span class="comment">// .... 释放锁给其他线程，防止其他线程过长时间等待</span></span><br><span class="line">myUniLock.lock();</span><br><span class="line"><span class="comment">// .... 处理一些共享代码</span></span><br></pre></td></tr></table></figure><p><strong><code>try_lock()</code></strong> ：尝试给互斥量加锁，如果拿不到返回 false，否则返回 true。</p><p><strong><code>release()</code></strong> :</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock</span><span class="params">(myMutex)</span></span>; <span class="comment">// 相当于把myMutex 和 myUniLock绑定在一起，release()就是接触绑定，返回它所管理的mutex对象的指针，并释放所有权</span></span><br><span class="line">mutex* ptr = myUniLock.<span class="built_in">release</span>(); <span class="comment">// 由原来的mutex对象处理加锁状态，就需要ptr在以后进行解锁，例如  ptr-&gt;unlock();</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>lock 的代码段越少，执行越快，整个程序的运行效率越高<ul><li>锁住的代码少 -&gt; 细粒度 -&gt; 执行效率高</li><li>锁住的代码多 -&gt; 粗粒度 -&gt; 执行效率低</li></ul></li></ul><p><strong>unique_lock所有权的传递</strong></p><ul><li>使用 move 转移</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只能通过移动语句转移所有权，不能使用拷贝</span></span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock1</span><span class="params">(myMutex)</span></span>;</span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(myUniLock1))</span></span>;</span><br></pre></td></tr></table></figure><ul><li>return 一个临时变量，即可实现转移</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">aFuc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock</span><span class="params">(myMutex)</span></span>;</span><br><span class="line">    <span class="comment">// 系统会生成临时的 unique_lock 对象调用它的移动构造函数。</span></span><br><span class="line">    <span class="keyword">return</span> myUniLock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、单例设计模式共享数据问题分析、解决，call-once"><a href="#六、单例设计模式共享数据问题分析、解决，call-once" class="headerlink" title="六、单例设计模式共享数据问题分析、解决，call_once"></a>六、单例设计模式共享数据问题分析、解决，call_once</h3><ul><li>单例设计模式：项目中，有某个或者某些特殊的类，只能创建一个属于该类的对象。</li><li>单例设计模式共享数据问题分析、解决</li><li><strong><code>std::call_once()</code></strong></li></ul><h4 id="6-1-单例模式共享数据问题分析、解决"><a href="#6-1-单例模式共享数据问题分析、解决" class="headerlink" title="6.1 单例模式共享数据问题分析、解决"></a>6.1 单例模式共享数据问题分析、解决</h4><p><strong>面临问题</strong>：需要在自己创建的线程中来创建单例类的对象，这种线程可能不止一个，可能操作 <strong><code>GetInstance()</code></strong> 这种成员函数需要互斥。</p><p><strong>技巧</strong>：可以在加锁前判断 <strong><code>m_instance</code></strong> 是否为空，否则每次调用 <strong><code>Singlton::getInstance()</code></strong> 都要进行加锁，十分影响效率。<strong><font color="FF0000">（双重锁定）</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>	<span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">mutex myMutex;</span><br><span class="line"><span class="comment">// 懒汉模式，在初次使用的时候创建对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singelton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singelton * <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双重锁定 提高效率</span></span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="function">lock_guard&lt;mutex&gt; <span class="title">myLockGua</span><span class="params">(myMutex)</span></span>;</span><br><span class="line">			<span class="keyword">if</span> (instance == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				instance = <span class="keyword">new</span> Singelton;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Singelton() &#123;&#125;</span><br><span class="line">	<span class="keyword">static</span> Singelton *instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singelton * Singelton::instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿汉模式，在类外先创建对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singelton2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singelton2* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Singelton2() &#123;&#125;</span><br><span class="line">	<span class="keyword">static</span> Singelton2 * instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singelton2 * Singelton2::instance = <span class="keyword">new</span> Singelton2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Singelton * singer = Singelton::getInstance();</span><br><span class="line">	Singelton * singer2 = Singelton::getInstance();</span><br><span class="line">	<span class="keyword">if</span> (singer == singer2)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"二者是同一个实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"二者不是同一个实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------	以下是 饿汉模式  ------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Singelton2 * singer3 = Singelton2::getInstance();</span><br><span class="line">	Singelton2 * singer4 = Singelton2::getInstance();</span><br><span class="line">	<span class="keyword">if</span> (singer3 == singer4)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"二者是同一个实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"二者不是同一个实例"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果觉得在单例模式中 new 了一个对象，而没有自己delete</strong> ，不合理，可以增加一个类中类 <strong><code>CGarHuiShou</code></strong> ，<strong>new</strong> 一个单例类时创建一个静态的 <strong><code>CGarhuishou</code></strong> 对象，这样在程序结束时会调用 <strong><code>CGarhuishou</code></strong> 的析构函数，释放掉 <strong>new</strong> 出来的单例对象。<strong><font color="FF0000">(技巧)</font></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singelton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singelton * <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 定义一个静态对象，该静态对象的生命周期随程序结束才中断</span></span><br><span class="line">			<span class="keyword">static</span> CGarhuishou huishou;</span><br><span class="line">			instance = <span class="keyword">new</span> Singelton;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">CGarhuishou</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 定义析构函数</span></span><br><span class="line">		~CGarhuishou() &#123;</span><br><span class="line">            <span class="comment">// 如果析构的时候内存还未释放，主动释放</span></span><br><span class="line">			<span class="keyword">if</span> (Singelton::instance)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">delete</span> Singelton::instance;</span><br><span class="line">				Singelton::instance = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Singelton() &#123;&#125;</span><br><span class="line">	<span class="keyword">static</span> Singelton *instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-2-std-call-once"><a href="#6-2-std-call-once" class="headerlink" title="6.2 std::call_once()"></a>6.2 <strong><code>std::call_once()</code></strong></h4><p>函数模板，该函数的第一个参数为<strong>标记</strong>，第二个参数是一个函数名（如a()）。<br>功能：能够保证函数a()只被调用一次。具备互斥量的能力，而且比互斥量消耗的资源更少，更高效。<br><strong><code>call_once()</code></strong> 需要与一个标记结合使用，这个标记为 <strong><code>std::once_flag</code></strong> ；其实 <strong><code>once_flag</code></strong> 是一个结构， <strong><code>call_once()</code></strong> 就是通过标记来决定函数是否执行，调用成功后，就把标记设置为一种已调用状态。</p><p>多个线程同时执行时，一个线程会等待另一个线程先执行。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::once_flag g_flag;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singelton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        instance = <span class="keyword">new</span> Singelton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两个线程同时执行到这里，其中一个线程要等另外一个线程执行完毕</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singelton * <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// call_once 保证其只被调用一次</span></span><br><span class="line">         call_once(g_flag, CreateInstance);</span><br><span class="line">         <span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Singelton() &#123;&#125;</span><br><span class="line">	<span class="keyword">static</span> Singelton *instance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 懒汉模式</span></span><br><span class="line">Singelton * Singelton::instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="七、condition-variable、wait、notify-one、notify-all"><a href="#七、condition-variable、wait、notify-one、notify-all" class="headerlink" title="七、condition_variable、wait、notify_one、notify_all"></a>七、condition_variable、wait、notify_one、notify_all</h3><ul><li>条件变量 <strong><code>std::condition_variable</code>、<code>wait()</code>、<code>notify_one()</code>、<code>notify_all</code></strong></li></ul><p><strong><code>std::condition_variable</code></strong> 实际上是一个类，是一个和条件相关的类，就是等待一个条件成立。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mymutex1;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">sbguard1</span><span class="params">(mymutex1)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::condition_variable condition;</span><br><span class="line">condition.wait(sbguard1, </span><br><span class="line">               [<span class="keyword">this</span>]()&#123; <span class="keyword">if</span> (!msgRecvQueue.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                         <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; &#125;);</span><br><span class="line">condition.wait(sbguard1);</span><br></pre></td></tr></table></figure><p><strong><code>wait()</code></strong> 用来等一个东西</p><ul><li>如果第二个参数的lambda表达式返回值是 <strong>false</strong>， <strong><code>wait()</code></strong> 将解锁互斥量并阻塞到本行</li><li>如果第二个参数的lambda表达式返回值是 <strong>true</strong>， <strong><code>wait()</code></strong> 直接返回并继续执行</li></ul><p><strong>阻塞到什么时候为止呢？</strong>阻塞到其他<u>某个线程调用 <strong><code>notify_one()</code></strong> 成员函数</u>为止；</p><p>如果没有第二个参数，那么效果跟第二个参数lambda表达式返回 <strong>false</strong> 效果一样 <strong><code>wait()</code></strong> 将解锁互斥量，并阻塞到本行，阻塞到其他某个线程调用 <strong><code>notify_one()</code></strong> 成员函数为止。</p><p>当其他线程用 <strong><code>notify_one()</code></strong> 将本线程 <strong><code>wait()</code></strong> 唤醒后，这个 <strong><code>wait()</code></strong>恢复后<br>1、 <strong><code>wait()</code></strong> 不断尝试获取互斥量锁，如果获取不到，那么流程就卡在 <strong><code>wait()</code></strong> 这里等待获取；如果获取到了，那么 <strong><code>wait()</code></strong> 就继续执行，获取到了锁。</p><p>2、如果 <strong><code>wait()</code></strong> 有第二个参数就判断这个 lambda 表达式。</p><p>a) 如果表达式为 <strong>false</strong>，<strong>那 wait 又对互斥量解锁，然后又休眠</strong>，等待再次被<strong><code>notify_one()</code></strong>唤醒<br>b) 如果lambda表达式为 <strong>true</strong>，则 <strong><code>wait()</code></strong> 返回，流程可以继续执行（<strong><font color="FF0000">此时互斥量已被锁住</font></strong>），如果wait没有第二个参数，则 <strong><code>wait()</code></strong>返回，流程走下去。</p><p>流程只要走到了 <strong><code>wait()</code></strong> 下面则互斥量一定被锁住了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inMsgRecvQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"inMsgRecvQueue插入一个元素"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">sbguard1</span><span class="params">(mymutex1)</span></span>;</span><br><span class="line">            msgRecvQueue.push_back(i); </span><br><span class="line">            <span class="comment">// 尝试把 wait()线程唤醒,执行完这行，</span></span><br><span class="line">            <span class="comment">// 那么 outMsgRecvQueue()里的 wait()就会被唤醒</span></span><br><span class="line">            <span class="comment">// 只有当另外一个线程正在执行wait()时 notify_one() 才会起效，</span></span><br><span class="line">            <span class="comment">// 否则没有作用</span></span><br><span class="line">            condition.notify_one();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outMsgRecvQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> command = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">sbguard2</span><span class="params">(mymutex1)</span></span>;</span><br><span class="line">            <span class="comment">// wait()用来等一个东西</span></span><br><span class="line">            <span class="comment">// 如果第二个参数的lambda表达式返回值是false，</span></span><br><span class="line">            <span class="comment">// 那么wait()将解锁互斥量，并阻塞到本行</span></span><br><span class="line">            <span class="comment">// 阻塞到什么时候为止呢？</span></span><br><span class="line">            <span class="comment">// 阻塞到其他某个线程调用notify_one()成员函数为止；</span></span><br><span class="line">            <span class="comment">// 当 wait() 被 notify_one()激活时， </span></span><br><span class="line">            <span class="comment">// 会先执行它的条件判断表达式是否为 true，</span></span><br><span class="line">            <span class="comment">// 如果为true才会继续往下执行</span></span><br><span class="line">            condition.wait(sbguard2, [<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="keyword">if</span> (!msgRecvQueue.empty())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;&#125;);</span><br><span class="line">            command = msgRecvQueue.front();</span><br><span class="line">            msgRecvQueue.pop_front();</span><br><span class="line">            <span class="comment">// 因为unique_lock的灵活性，我们可以随时unlock，以免锁住太长时间</span></span><br><span class="line">            sbguard2.unlock(); </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"outMsgRecvQueue()执行，取出第一个元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; msgRecvQueue;</span><br><span class="line">	<span class="built_in">std</span>::mutex mymutex1;</span><br><span class="line">	<span class="built_in">std</span>::condition_variable condition;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A myobja;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">myoutobj</span><span class="params">(&amp;A::outMsgRecvQueue, &amp;myobja)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">myinobj</span><span class="params">(&amp;A::inMsgRecvQueue, &amp;myobja)</span></span>;</span><br><span class="line">	myinobj.join();</span><br><span class="line">	myoutobj.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深入思考</strong></p><p>上面的代码可能导致出现一种情况：<br>因为 <strong><code>outMsgRecvQueue()</code></strong> 与 <strong><code>inMsgRecvQueue()</code></strong> 并不是一对一执行的，所以当程序循环执行很多次以后，可能在 <strong><code>msgRecvQueue</code></strong> 中已经有了很多消息，但是 <strong><code>outMsgRecvQueue</code></strong> 还是被唤醒一次只处理一条数据。</p><p>这时可以考虑把 <strong><code>outMsgRecvQueue</code></strong> 多执行几次，或者对 <strong><code>inMsgRecvQueue</code></strong> 进行限流。</p><p><strong><code>notify_one()</code></strong> ：通知一个线程的 <strong><code>wait()</code></strong></p><p><strong><code>notify_all()</code></strong> ：通知所有线程的 <strong><code>wait()</code></strong></p><h3 id="八、async、future、packaged-task、promise"><a href="#八、async、future、packaged-task、promise" class="headerlink" title="八、async、future、packaged_task、promise"></a><strong>八、async、future、packaged_task、promise</strong></h3><ul><li><strong><code>std::async</code></strong> 、 <strong><code>std::future</code></strong> 创建后台任务并返回值</li><li><strong><code>std::packaged_task</code></strong></li><li><strong><code>std::promise</code></strong></li></ul><h4 id="8-1-std-async、std-future-创建后台任务并返回值"><a href="#8-1-std-async、std-future-创建后台任务并返回值" class="headerlink" title="8.1 std::async、std::future 创建后台任务并返回值"></a>8.1 <strong><code>std::async</code>、<code>std::future</code> 创建后台任务并返回值</strong></h4><p>需要包含头文件 <strong><code>#include &lt;future&gt;</code></strong></p><p><strong><code>std::async</code></strong> 是一个函数模板，用来启动一个<strong><font color="FF0000">异步任务</font></strong>，启动起来一个异步任务之后，它返回一个 <strong><code>std::future</code></strong> 对象，这个对象是个<strong>类模板</strong>。</p><p>什么叫“启动一个异步任务”？就是自动创建一个线程，并开始执行对应的线程入口函数，返回一个 <strong><code>std::future</code></strong> 对象，这个 <strong><code>std::future</code></strong> 对象中就含有线程入口函数所返回的结果，我们可以通过调用 <strong><code>std::future</code></strong> 对象的成员函数 <strong><code>get()</code></strong>来获取结果。</p><p>“future”将来的意思，也有人称呼 <strong><code>std::future</code></strong> 提供了一种访问异步操作结果的机制，就是说这个结果你可能没办法马上拿到，但在不久的将来，这个线程执行完毕时，你就能够拿到结果，<strong>所以可以理解为：future中保存着一个值，这个值是在将来的某个时刻能够拿到。</strong></p><p><strong><code>std::future</code></strong>对象的 <strong><code>get()</code></strong>成员函数会<strong><font color="FF0000">等待线程执行结束</font></strong>并返回结果，拿不到结果它就会一直等待，感觉有点像 <strong><code>join()</code></strong> 但是，它是可以获取结果的。</p><p><strong><code>std::future</code></strong>对象的 <strong><code>wait()</code></strong> 成员函数，用于等待线程返回，<strong>本身并不返回结果</strong>，这个效果和 <strong><code>std::thread</code></strong> 的 <strong><code>join()</code></strong> 更像。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">(<span class="keyword">int</span> mypar)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> mypar;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start threadid = "</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 定义睡眠时间 5S</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(dura); <span class="comment">// 睡眠</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mainThreadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 普通线程函数</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result1 = <span class="built_in">std</span>::async(mythread);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"continue........"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 卡在这里等待mythread()执行完毕，拿到结果</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; result1.<span class="built_in">get</span>() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 类成员函数</span></span><br><span class="line">    <span class="comment">// 第二个参数是对象引用才能保证线程里执行的是同一个对象</span></span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">12</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result2 = <span class="built_in">std</span>::async(&amp;A::mythread, &amp;a, tmp); </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; result2.<span class="built_in">get</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 或者 result2.wait(); -&gt; 没有返回值</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"good luck"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过向 <strong><code>std::async()</code></strong> 传递一个参数，改参数是 <strong><code>std::launch</code></strong> 类型（枚举类型），来达到一些特殊的目的：</p><ul><li><strong><code>std::lunch::deferred</code></strong> (defer推迟，延期）</li></ul><p>表示线程入口函数的调用会被延迟，一直到 <strong><code>std::future</code></strong> 的 <strong><code>wait()</code></strong> 或者 <strong><code>get()</code></strong> 函数被调用时（<strong>由主线程调用</strong>）才会执行；如果 <strong><code>wait()</code></strong> 或者 <strong><code>get()</code></strong> 没有被调用，则不会执行。</p><p><strong><font color="FF0000">实际上根本就没有创建新线程</font>。 <code>std::lunch::deferred</code> 意思时延迟调用，并没有创建新线程，是在主线程中调用的线程入口函数。</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mainThreadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred ,mythread);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"continue........"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//卡在这里等待mythread()执行完毕，拿到结果</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; result1.<span class="built_in">get</span>() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"good luck"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>std::launch::async</code></strong> ，在调用 async 函数的时候就开始<strong>创建新线程</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mainThreadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async ,mythread);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"continue........"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; result1.<span class="built_in">get</span>() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"good luck"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-std-async-续谈"><a href="#8-2-std-async-续谈" class="headerlink" title="8.2 std::async 续谈"></a>8.2 <code>std::async</code> 续谈</h4><p><strong><code>std::async</code></strong> 参数详述，async 用来创建一个异步任务</p><ul><li><p><strong><code>std::launch::deferred</code></strong> 【<strong>延迟调用，(主线程调用)</strong>】</p></li><li><p><strong><code>std::launch::async</code></strong> 【<strong>强制创建一个线程</strong>】</p></li></ul><p><strong><code>std::async()</code></strong> 一般不叫创建线程（他能够创建线程），一般叫它创建一个异步任务。</p><p><strong><code>std::async</code></strong> 和 <strong><code>std::thread</code></strong> 最明显的<strong><font color="FF0000">不同</font></strong>，就是 <strong>async</strong> 有时候<strong>并不创建新线程。</strong></p><p><strong>① 如果用<code>std::launch::deferred</code>来调用 async？</strong></p><p>延迟到调用 <strong><code>get()</code></strong> 或者 <strong><code>wait()</code></strong> 时执行，如果不调用就不会执行</p><p><strong>② 如果用<code>std::launch::async</code>来调用 async？</strong></p><p>强制这个异步任务在新线程上执行，这意味着，系统必须要创建出新线程来运行入口函数。</p><p><strong>③ 如果同时用 <code>std::launch::async | std::launch::deferred</code></strong></p><p>这里这个或者关系意味着 <strong>async</strong> 的行为可能是 <strong><code>std::launch::async</code></strong> 创建新线程立即执行， 也可能是 <strong><code>std::launch::deferred</code></strong> 没有创建新线程并且延迟到调用 <strong><code>get()</code></strong>执行，由系统根据实际情况来决定采取哪种方案。</p><p><strong>④ 不带额外参数 <code>std::async(mythread)</code> ，只给 async 一个入口函数名</strong></p><p>此时的系统给的默认值是 <strong><code>std::launch::async | std::launch::deferred</code></strong> 和 ③ 一样，有系统自行决定异步还是同步运行。</p><p><strong><code>std::async</code>和<code>std::thread()</code>区别：</strong></p><p><strong><code>std::thread()</code></strong> 如果系统资源紧张可能出现创建线程失败的情况，如果创建线程失败那么程序就<strong>可能崩溃</strong>，而且不容易拿到函数返回值（不是拿不到）<br><strong><code>std::async()</code></strong> 创建异步任务。可能创建线程也可能不创建线程，并且容易拿到线程入口函数的返回值；</p><p>由于系统资源限制：<br>① 如果用 <strong><code>std::thread</code></strong> 创建的线程太多，则可能创建失败，系统报告异常，崩溃。</p><p>② 如果用 <strong><code>std::async</code></strong> ，一般就不会报异常，因为如果系统资源紧张，无法创建新线程的时候，async 不加额外参数的调用方式就不会创建新线程。而是在后续调用 <strong><code>get()</code></strong> 请求结果时执行在这个调用 <strong><code>get()</code></strong> 的线程上。</p><p>如果你强制 async 一定要创建新线程就要使用 <strong><code>std::launch::async</code></strong> 标记。承受的代价是，系统资源紧张时可能崩溃。</p><p>③ 根据经验，一个程序中线程数量 不宜超过100~200 。</p><p><strong>async 不确定性问题的解决</strong><br>不加额外参数的 async 调用时让<strong>系统自行决定</strong>，是否创建新线程。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span> result = <span class="built_in">std</span>::async(mythread);</span><br><span class="line"><span class="comment">// 问题焦点在于这个写法，任务到底有没有被推迟执行。</span></span><br><span class="line"><span class="comment">// 可以通过 wait_for 返回状态来判断：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果资源不紧张的情况下：</span></span><br><span class="line"><span class="comment">// - 如果线程运行需要5秒，主线程在这要等待 6 秒的话，此时 status = ready</span></span><br><span class="line"><span class="comment">// - 如果线程运行需要5秒，主线程在这里要等待 1 秒的话，此时 status = timeout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果资源紧张的情况下：</span></span><br><span class="line"><span class="comment">// 如果出现了 status = deferred，则说明系统选择了 std::launch::deferred，延迟调用</span></span><br><span class="line"><span class="comment">// 一旦使用了deferred，就不会创建线程，都是在get()才会调用线程入口函数，不管wait_for多长时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::future_status status = result.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">6</span>));</span><br><span class="line"><span class="comment">//std::future_status status = result.wait_for(6s);</span></span><br><span class="line">	<span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::timeout) &#123;</span><br><span class="line">		<span class="comment">// 超时：表示线程还没有执行完</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"超时了，线程还没有执行完"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::<span class="built_in">ready</span>) &#123;</span><br><span class="line">		<span class="comment">// 表示线程成功返回</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"线程执行成功，返回"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::deferred) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"线程延迟执行"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-std-packaged-task：打包任务，把任务包装起来"><a href="#8-3-std-packaged-task：打包任务，把任务包装起来" class="headerlink" title="8.3 std::packaged_task：打包任务，把任务包装起来"></a>8.3 <strong>std::packaged_task：打包任务，把任务包装起来</strong></h4><p>类模板，它的模板参数是各种可调用对象，通过 <strong><code>packaged_task</code></strong> 把<strong>各种可调用对象</strong>包装起来，方便将来作为线程入口函数来调用。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">(<span class="keyword">int</span> mypar)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mainThreadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 我们把函数mythread通过packaged_task包装起来</span></span><br><span class="line">    <span class="comment">// 返回值类型是int,参数是一个int:  int mythread(int)</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">mypt1</span><span class="params">(mythread)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以封装 lambda 函数</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">mypt2</span><span class="params">([](<span class="keyword">int</span> mypar) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="built_in">cout</span> &lt;&lt; mypar &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="built_in">std</span>::chrono::milliseconds dura(<span class="number">5000</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="built_in">std</span>::this_thread::sleep_for(dura);</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> </span></span></span><br><span class="line"><span class="function"><span class="params">             &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">return</span> <span class="number">5</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">	&#125;)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程 t1，使用packaged_task封装的线程入口函数 </span></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(<span class="built_in">std</span>::ref(mypt1), <span class="number">1</span>)</span></span>;</span><br><span class="line">	t1.join();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = mypt1.get_future(); </span><br><span class="line">	<span class="comment">// std::future对象里包含有线程入口函数的返回结果，通过 get_future()函数</span></span><br><span class="line">    <span class="comment">// 这里 result 保存 mythread 返回的结果。</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// packaged_task 包装起来的可调用对象还可以直接调用，从这个角度来讲，、、</span></span><br><span class="line">    <span class="comment">// packaged_task 对象也是一个可调用对象,lambda可以直接调用</span></span><br><span class="line">    mypt2(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = mypt2.get_future();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 上段程序是在主线程中进行的</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-std-promise"><a href="#8-4-std-promise" class="headerlink" title="8.4 std::promise"></a>8.4 <code>std::promise</code></h4><p>模板类，能够在某个线程中给它赋值，并可以在其他线程中，把这个值取出来</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread</span><span class="params">(<span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; &amp;tmp, <span class="keyword">int</span> clac)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> result = clac;</span><br><span class="line">	tmp.set_value(result); <span class="comment">// 结果保存到了tmp这个对象中,使用 set_val() 函数</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt;&gt; task_vec;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; myprom;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(mythread, <span class="built_in">std</span>::ref(myprom), <span class="number">180</span>)</span></span>;</span><br><span class="line">	t1.join(); <span class="comment">//在这里线程已经执行完了</span></span><br><span class="line">    <span class="comment">// promise 和 future绑定，用于获取线程返回值</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; fu1 = myprom.get_future(); </span><br><span class="line">	<span class="keyword">auto</span> result = fu1.<span class="built_in">get</span>();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"result = "</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <strong><code>promise</code></strong> 保存一个值，在将来某个时刻我们通过把一个<strong><code>future</code></strong>绑定到这个 <strong><code>promise</code></strong> 上，来得到绑定的值。注意，使用 thread 时，必须 <strong><code>join()</code></strong>或者 <strong><code>detach()</code></strong>， 否则程序会报异常。</p><h3 id="九、future-其他成员函数、shared-future、atomic"><a href="#九、future-其他成员函数、shared-future、atomic" class="headerlink" title="九、future 其他成员函数、shared_future、atomic"></a>九、future 其他成员函数、shared_future、atomic</h3><ul><li><strong><code>std::future</code></strong> 其他成员函数</li><li><strong><code>std::shared_future</code></strong></li><li><strong><code>std::atomic</code></strong></li></ul><h4 id="9-1-std-future-的成员函数"><a href="#9-1-std-future-的成员函数" class="headerlink" title="9.1 std::future 的成员函数"></a>9.1 <code>std::future</code> 的成员函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::future_status status = result.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>卡住当前流程，等待 <strong><code>std::async()</code></strong> 的异步任务运行一段时间，然后返回其状态<strong><code>std::future_status</code></strong> 。如果<strong><code>std::async()</code></strong>的参数是 <strong><code>std::launch::deferred</code></strong> （延迟执行），<strong><font color="FF0000">则不会卡住主流程</font></strong>，<strong>没有创建新线程，线程入口函数仍然在遇到 <code>get()</code> 的时候调用，只是主线程中的普通函数调用。</strong><br><strong><code>std::future_status</code></strong> 是枚举类型，表示异步任务的执行状态。类型的取值有</p><ul><li><strong><code>std::future_status::timeout</code></strong></li><li><strong><code>std::future_status::ready</code></strong></li><li><strong><code>std::future_status::deferred</code></strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mainThreadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = <span class="built_in">std</span>::async(mythread);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"continue........"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//卡在这里等待mythread()执行完毕，拿到结果</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; result1.get() &lt;&lt; endl; </span></span><br><span class="line">	<span class="comment">// 等待1秒</span></span><br><span class="line">    <span class="built_in">std</span>::future_status status=result.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::timeout) &#123;</span><br><span class="line">		<span class="comment">// 超时：表示线程还没有执行完</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"超时了，线程还没有执行完"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> &lt;&lt;                                  <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//std::chrono::milliseconds dura(5000);</span></span><br><span class="line">	<span class="comment">//std::this_thread::sleep_for(dura);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mainThreadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred, mythread);</span><br><span class="line">	<span class="comment">//std::future&lt;int&gt; result = std::async(mythread);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"continue........"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//卡在这里等待mythread()执行完毕，拿到结果</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; result1.get() &lt;&lt; endl; </span></span><br><span class="line">	<span class="built_in">std</span>::future_status status=result.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">6</span>));</span><br><span class="line">	<span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::timeout) &#123;</span><br><span class="line">		<span class="comment">// 超时：表示线程还没有执行完</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"超时了，线程还没有执行完"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::<span class="built_in">ready</span>) &#123;</span><br><span class="line">		<span class="comment">// 表示线程成功结束并返回</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"线程执行成功，返回"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::deferred) &#123;</span><br><span class="line">		<span class="comment">// 如果设置 std::future&lt;int&gt; result = </span></span><br><span class="line">        <span class="comment">// std::async(std::launch::deferred, mythread);，则本条件成立</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"线程延迟执行"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"good luck"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-std-shared-future"><a href="#9-2-std-shared-future" class="headerlink" title="9.2 std::shared_future"></a>9.2 <code>std::shared_future</code></h4><p><strong><code>std::shared_future</code>：也是个类模板</strong></p><ul><li><p><strong><code>std::future</code></strong>的 <strong><code>get()</code></strong> 成员函数是转移数据</p></li><li><p><strong><code>std::shared_future</code></strong> 的 <strong><code>get()</code></strong> 成员函数是复制数据</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() start"</span> &lt;&lt; <span class="string">"threadid = "</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread() end"</span> &lt;&lt; <span class="string">"threadid = "</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"mainThreadid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">mypt</span><span class="params">(mythread)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(<span class="built_in">std</span>::ref(mypt))</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; result = mypt.get_future();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">bool</span> ifcanget = result.valid(); <span class="comment">//判断future 中的值是不是一个有效值</span></span><br><span class="line">    <span class="comment">// 执行完毕后result_s里有值，而result里空了</span></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::shared_future&lt;<span class="keyword">int</span>&gt; <span class="title">result_s</span><span class="params">(result.share())</span></span>;</span><br><span class="line">    <span class="comment">// 使用移动构造函数来创建 shared_future对象</span></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::shared_future&lt;<span class="keyword">int</span>&gt; <span class="title">result_s</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(result))</span></span>;</span><br><span class="line">    <span class="comment">// 通过get_future返回值直接构造一个shared_future对象</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::shared_future&lt;<span class="keyword">int</span>&gt; <span class="title">result_s</span><span class="params">(mypt.get_future())</span></span>;</span><br><span class="line">    </span><br><span class="line">    t1.join();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> myresult1 = result_s.<span class="built_in">get</span>();</span><br><span class="line">	<span class="keyword">auto</span> myresult2 = result_s.<span class="built_in">get</span>();</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"good luck"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-std-atomic-原子操作"><a href="#9-3-std-atomic-原子操作" class="headerlink" title="9.3 std::atomic 原子操作"></a>9.3 <code>std::atomic</code> 原子操作</h4><p>有两个线程，对一个变量进行操作，一个线程读这个变量的值，一个线程往这个变量中写值。即使是一个简单变量的读取和写入操作，如果不加锁，也有可能会导致读写值混乱（一条C语句会被拆成3、4条汇编语句来执行，所以仍然有可能混乱）;</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> g_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 该语句会被拆成多条汇编语句，所以可能在线程切换的过程中出现混乱</span></span><br><span class="line">		g_count++; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(mythread1)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(mythread1)</span></span>;</span><br><span class="line">	t1.join();</span><br><span class="line">	t2.join();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"正常情况下结果应该是200 0000次，实际是"</span> &lt;&lt; g_count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// !!! 注意：输出结果并不一定是 2000000  !!!</span></span><br></pre></td></tr></table></figure><p>互斥量：多线程编程中用于保护共享数据：先锁住， 操作共享数据， 解锁。所以通过 mutex 可以解决，<strong>但是效率不高。</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mymutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">u1</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">        <span class="comment">// std::lock_guard&lt;std::mutex&gt; u1(mymutex);</span></span><br><span class="line">		g_count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(mythread1)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(mythread1)</span></span>;</span><br><span class="line">	t1.join();</span><br><span class="line">	t2.join();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"正常情况下结果应该是200 0000次，实际是"</span> &lt;&lt; g_count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-4-std-atomic-用法"><a href="#9-4-std-atomic-用法" class="headerlink" title="9.4 std::atomic 用法"></a>9.4 <code>std::atomic</code> 用法</h4><p>原子操作：在多线程中不会被打断的程序执行片段。原子操作可以理解成一种：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。</p><ul><li><p><strong>优势</strong>：从效率上来说，原子操作要比互斥量的方式<strong>效率要高</strong>。</p></li><li><p><strong>区别</strong>：互斥量的加锁一般是针对<strong>一个代码段</strong>，而原子操作针对的一般都是<strong>一个变量</strong>。</p></li></ul><p>原子操作，一般都是指“不可分割的操作”；也就是说这种操作状态要么是完成的，要么是没完成的，不可能出现半完成状态。</p><p><strong><code>std::atomic</code></strong> 来代表原子操作，是个类模板，用来封装某个类型的值的。</p><p>需要添加头文件 <strong><code>#include &lt;atomic&gt;</code></strong>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; g_count = <span class="number">0</span>;  <span class="comment">// 封装了一个类型为int的 对象（值）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		g_count++;</span><br><span class="line">        <span class="comment">// 另外需要注意的是：一般atomic原子操作</span></span><br><span class="line">        <span class="comment">// 针对 ++，–，+=，-=，&amp;=，|=，^= 是支持的，其他操作不一定支持。</span></span><br><span class="line">        g_count += <span class="number">1</span>;  <span class="comment">// 支持</span></span><br><span class="line">        g_count = g_count + <span class="number">1</span>; <span class="comment">// 不支持</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(mythread1)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(mythread1)</span></span>;</span><br><span class="line">	t1.join();</span><br><span class="line">	t2.join();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"正常情况下结果应该是200 0000次，实际是"</span> &lt;&lt; g_count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; g_ifEnd = <span class="literal">false</span>; <span class="comment">// 封装了一个类型为bool的 对象（值）</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">dura</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 每 1 秒中判断一次 g_ifEnd</span></span><br><span class="line">	<span class="keyword">while</span> (g_ifEnd == <span class="literal">false</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"th_id = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"th id = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"over"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(mythread)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(mythread)</span></span>;</span><br><span class="line">    <span class="comment">// 主线程 睡眠 5s</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(dura);</span><br><span class="line">	g_ifEnd = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"程序执行完毕"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	t1.join();</span><br><span class="line">	t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><blockquote><p><a href="https://www.bilibili.com/video/BV1Yb411L7ak" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yb411L7ak</a></p><p><a href="https://blog.csdn.net/qq_38231713/category_10001159.html" target="_blank" rel="noopener">https://blog.csdn.net/qq_38231713/category_10001159.html</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Network_Communications</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Network_Communications</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 进程间通信</title>
    <url>/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h3 id="一、进程通信概述"><a href="#一、进程通信概述" class="headerlink" title="一、进程通信概述"></a>一、进程通信概述</h3><h4 id="1-进程通信、线程通信"><a href="#1-进程通信、线程通信" class="headerlink" title="1. 进程通信、线程通信"></a>1. 进程通信、线程通信</h4><p>进程通信：在用户空间实现进程通信<strong><font color="FF0000">不可能</font></strong>，需要通过 Linux 内核通信</p><p>线程通信：可以在用户空间实现，通过<strong>全局变量</strong>即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> process_inter = <span class="number">0</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// child process code second</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (process_inter == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"this is child process i = %d"</span>, i);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">// parent process code first</span></span><br><span class="line">    	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"this iparent process i = %d"</span>, i);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        process_inter = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无法通过<strong>用户空间</strong>全局变量实现进程间通信，上段程序只能运行父进程。</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/全局变量_进程通信_error.png" style="zoom:80%"></p><h4 id="2-进程通信方式"><a href="#2-进程通信方式" class="headerlink" title="2. 进程通信方式"></a>2. 进程通信方式</h4><p><strong>单机模式</strong>下：（只有一个 Linux 内核）</p><ul><li>管道通信：无名管道、有名管道（文件系统中有名）</li><li>信号通信：信号的发送、信号的接收和信号的处理</li><li>IPC（Inter-Process Communication）：共享内存、消息队列和信号灯（量）</li></ul><p>多机模式下：（两个 Linux 内核）</p><ul><li>Socket 通信：存在于一个网络中两个进程之间的通信。</li></ul><h4 id="3-进程通信的学习思路"><a href="#3-进程通信的学习思路" class="headerlink" title="3. 进程通信的学习思路"></a>3. 进程通信的学习思路</h4><p>进程通信的学习思路：每一种通信方式都是基于文件IO的思想</p><ul><li><strong><code>open</code></strong> ：创建或者打开进程通信对象。函数形式可能不同，可能有多个函数完成</li><li><strong><code>write</code></strong> ：向进程通信对象中写入内容。函数形式可能不同。</li><li><strong><code>read</code></strong> ：从进程通信对象中读取内容。函数形式可能不同。</li><li><strong><code>close</code></strong> ：关闭或删除进程通信对象。函数形式可能不同。</li></ul><h3 id="二、无名管道"><a href="#二、无名管道" class="headerlink" title="二、无名管道"></a>二、无名管道</h3><p>通信原理：</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/无名管道通信原理.png" style="zoom:50%"></p><p>管道文件是一个特殊文件，是有<strong>队列</strong>来实现的。</p><h4 id="2-1-无名管道的创建"><a href="#2-1-无名管道的创建" class="headerlink" title="2.1 无名管道的创建"></a>2.1 无名管道的创建</h4><p>在文件IO中创建一个文件或打开一个文件是由 <strong><code>open</code></strong> 函数实现的，它不能创建管道文件。只能用 <strong><code>pipe</code></strong> 函数来创建管道。</p><p><strong>函数形式</strong>： <strong><code>int pipe(int fd[2])</code></strong></p><p><strong>功能</strong>：创建管道，为系统调用， <strong><code>unistd.h</code></strong></p><p><strong>参数</strong>：就是得到的文件描述符。可见有两个文件描述符，<strong><code>fd[0]</code></strong>、<strong><code>fd[1]</code></strong>，管道有一个读端 <strong><code>fd[0]</code></strong> 用来读， <strong><code>fd[1]</code></strong> 用来写。</p><p><strong>返回值</strong>：成功 0，失败 -1</p><h4 id="2-2-pipe-函数使用"><a href="#2-2-pipe-函数使用" class="headerlink" title="2.2 pipe 函数使用"></a>2.2 <code>pipe</code> 函数使用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> writebuf[] = <span class="string">"hello linux!"</span>;</span><br><span class="line">    <span class="keyword">char</span> readbuf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create pipe failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create pipe sucess fd[0] = %d, fd[1] = %d\n"</span>, fd[<span class="number">0</span>], fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">write</span>(fd[<span class="number">1</span>], writebuf, <span class="keyword">sizeof</span>(writebuf));</span><br><span class="line">    <span class="built_in">read</span>(fd[<span class="number">0</span>], readbuf, <span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"readbuf = %s\n"</span>, readbuf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>管道是创建在内存中的，<strong>进程结束，空间释放，管道就不再了</strong>；</li><li>管道中的东西，<strong>读完了就删除了</strong>；</li><li>如果管道没有东西可读，就会<strong>阻塞</strong>。</li></ul><h4 id="2-3-验证读阻塞"><a href="#2-3-验证读阻塞" class="headerlink" title="2.3 验证读阻塞"></a>2.3 验证读阻塞</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> writebuf[] = <span class="string">"hello linux!"</span>;</span><br><span class="line">    <span class="keyword">char</span> readbuf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create pipe failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create pipe sucess fd[0] = %d, fd[1] = %d\n"</span>, fd[<span class="number">0</span>], fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">write</span>(fd[<span class="number">1</span>], writebuf, <span class="keyword">sizeof</span>(writebuf));</span><br><span class="line">    <span class="built_in">read</span>(fd[<span class="number">0</span>], readbuf, <span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"readbuf = %s\n"</span>, readbuf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// second read from pipe</span></span><br><span class="line">    <span class="comment">// 会阻塞</span></span><br><span class="line">    <span class="built_in">memset</span>(readbuf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">    <span class="built_in">read</span>(fd[<span class="number">0</span>], readbuf, <span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"readbuf = %s\n"</span>, readbuf);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/读阻塞.png" alt></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/阻塞_睡眠状态.png" alt="image-20210422190256281"></p><h4 id="2-4-验证写阻塞"><a href="#2-4-验证写阻塞" class="headerlink" title="2.4 验证写阻塞"></a>2.4 验证写阻塞</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> writebuf[] = <span class="string">"hello linux!"</span>;</span><br><span class="line">    <span class="keyword">char</span> readbuf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create pipe failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create pipe sucess fd[0] = %d, fd[1] = %d\n"</span>, fd[<span class="number">0</span>], fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 可以通过 i 的设定，计算管道的大小</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">5500</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>], writebuf, <span class="keyword">sizeof</span>(writebuf));</span><br><span class="line">        i++;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"write pipe end\n"</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/写阻塞.png" alt></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/写阻塞_睡眠状态.png" alt></p><h4 id="2-5-实现进程通信。"><a href="#2-5-实现进程通信。" class="headerlink" title="2.5 实现进程通信。"></a>2.5 实现进程通信。</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> process_inter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create pipe failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create pipe success\n"</span>);</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// child process code second</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// if pipe empty  sleep</span></span><br><span class="line">        <span class="comment">//需要注意该process与父进程process同名而已</span></span><br><span class="line">        <span class="keyword">while</span> (process_inter == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"this is child process i = %d"</span>, i);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">// parent process code first</span></span><br><span class="line">    	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"this iparent process i = %d"</span>, i);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        process_inter = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>], &amp;process_inter, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现进程间通信</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/管道_进程通信.png" style="zoom:80%"></p><h3 id="三、有名管道"><a href="#三、有名管道" class="headerlink" title="三、有名管道"></a>三、有名管道</h3><p>无名管道的<strong><font color="FF000">缺点</font></strong>：<strong>不能实现不是父子进程（亲缘关系）之间的通信。</strong></p><p>正由于这无名管道的缺点，对于无名管道进行改进，<strong>有名管道。</strong></p><p>所谓的<strong>有名</strong>，即文件系统中存在这个一样文件节点，每一个文件节点都有一个 <strong><code>inode</code></strong> 号，而且这是一个特殊的文件类型： <strong><code>p</code></strong> 管道类型。</p><ol><li><p><strong><font color="FF000">创建</font></strong>这个文件节点，不可以通过 <strong><code>open</code></strong> 函数，<strong><code>open</code></strong> 函数只能创建普通文件，不能创建特殊文件（管道- <strong><code>mkfifo</code></strong> ，套接字- <strong><code>socket</code></strong> ，字符设备文件- <strong><code>mknod</code></strong> ，块设备文件- <strong><code>mknod</code></strong> ，符号链接文件-<strong><code>ln -s</code></strong>，目录文件- <strong><code>mkdir</code></strong> ）</p></li><li><p>管道文件只有 <strong><code>inode</code></strong> 号，不占磁盘块空间，和套接字、字符设备文件、块设备文件一样。普通文件和符号链接文件及目录文件，不仅有 <strong><code>inode</code></strong> 号，还占有磁盘块空间</p></li><li><p><strong><code>mkfifo</code></strong> : 用来<strong>创建</strong>管道文件的<strong>节点</strong>，<strong>没有在内核中创建管道</strong>。只有通过 <strong><code>open</code></strong> 函数<strong>打开这个文件时才会在内核空间创建管道</strong>。</p></li></ol><h4 id="3-1-有名管道的创建"><a href="#3-1-有名管道的创建" class="headerlink" title="3.1 有名管道的创建"></a>3.1 有名管道的创建</h4><p><strong><code>mkfifo</code> 的用法</strong></p><p><strong>函数形式: <code>int mkfifo(const char* filename, mode_t mode);</code></strong> 创建管道文件。</p><p><strong>参数</strong>：管道文件名，权限，创建的文件权限任然和 <strong><code>umask</code></strong> 有关系</p><p><strong>返回值</strong>：创建成功返回 0，失败返回 -1。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = mkfifo(<span class="string">"./myfifo"</span>, <span class="number">0777</span>); <span class="comment">// 权限 0777</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create myfifo failure \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create myfifo success \n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-通过管道实现无亲缘关系进程间通信"><a href="#3-2-通过管道实现无亲缘关系进程间通信" class="headerlink" title="3.2 通过管道实现无亲缘关系进程间通信"></a>3.2 通过管道实现无亲缘关系进程间通信</h4><p><strong><code>first.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fcntl.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> process_inter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 打开之前创建的管道类型文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"./myfifo"</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open myfifo failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open myfifo success \n"</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this is first process i = %d\n"</span>, i);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    process_inter = <span class="number">1</span>;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 向管道中写</span></span><br><span class="line">    <span class="built_in">write</span>(fd, &amp;process_inter, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>second.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fcntl.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> process_inter = <span class="number">0</span>;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"./myfifo"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open myfifo failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open myfifo success \n"</span>);</span><br><span class="line">    <span class="comment">// 从管道中读</span></span><br><span class="line">    <span class="built_in">read</span>(fd, &amp;process_inter, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (process_inter == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this is second process i = %d\n"</span>, i);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行 <strong><code>first</code></strong> <strong>open</strong> 管道文件：<strong><code>myfifo</code></strong></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/开启first.png" style="zoom:80%"></p><p>运行 <strong><code>second</code></strong> ，此时两端开始通信，<strong><code>first</code></strong> 先运行，<strong><code>second</code></strong> 后运行</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/first_after_second.png" style="zoom:80%"> <img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/second.png" style="zoom:80%"></p><h3 id="四、信号通信"><a href="#四、信号通信" class="headerlink" title="四、信号通信"></a>四、信号通信</h3><p>信号通信，其实就是内核向用户空间进程<strong><font color="FF0000">发送信号</font></strong>，只有<strong><font color="FF0000">内核才能发信号</font></strong>，用户空间进程不能发信号。</p><p>内核可以发送<strong>多少种</strong>信号？<strong><code>kill -l</code></strong> : <strong>64 种</strong>，常见命令：<strong><code>kill 9 pid</code></strong> (杀死进程)</p><p>信号通信的框架</p><ul><li>信号的发送（发送信号进程）： <strong><code>kill</code> <font color="FF0000"><code>raise</code></font> <code>alarm</code></strong></li><li>信号的接收（接收信号进程）： <strong><code>pause()</code> <code>sleep</code> <code>while(1)</code></strong></li><li>信号的处理（接收信号进程）： <strong><code>signal</code></strong></li></ul><h4 id="4-1-信号的发送（发送信号进程）"><a href="#4-1-信号的发送（发送信号进程）" class="headerlink" title="4.1 信号的发送（发送信号进程）"></a>4.1 信号的发送（发送信号进程）</h4><h5 id="4-1-1-kill"><a href="#4-1-1-kill" class="headerlink" title="4.1.1 kill"></a>4.1.1 <strong><code>kill</code></strong></h5><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/kill操作.png" style="zoom:50%"></p><p><strong>例子：编写自己的kill函数</strong></p><p>创建一个简单的进程 <strong><code>test.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后系统死循环<br><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20210423171228323.png" alt="image-20210423171228323"></p><p><strong><code>mykill.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sig;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"please input param\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sig = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    pid = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sig = %d, pid = %d \n"</span>, sig, pid);</span><br><span class="line">    <span class="comment">// 调用系统函数</span></span><br><span class="line">    kill(pid, sig);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <strong>9</strong> 号信号量 <strong><code>SIGKILL</code></strong> 来 <strong>kill</strong> 掉 <strong><code>./test</code></strong> 进程</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20210423171719834.png" alt="image-20210423171719834" style="zoom:80%"></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20210423171538416.png" alt="image-20210423171538416" style="zoom:80%"></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image-20210423171817097.png" alt="image-20210423171817097"></p><h5 id="4-1-2-raise"><a href="#4-1-2-raise" class="headerlink" title="4.1.2 raise"></a>4.1.2 raise</h5><p><strong><code>raise</code></strong> : 发信号给自己，等价于 <strong><code>kill(getpid(), sig)</code></strong></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/raise函数.png" style="zoom:67%"></p><p><strong>例子：raise 函数</strong></p><p><strong><code>raise.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"raise before"</span>);   <span class="comment">// 输出结果见1图，它只是将该语句写入库函数缓存，没有写入内核</span></span><br><span class="line">    <span class="comment">// printf("raise before\n");  // 输出结果见2图</span></span><br><span class="line">    raise(<span class="number">9</span>); <span class="comment">// 相当于_exit()，而非exit();</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"raise after\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/raise_01.png" alt="raise_01"></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/raise_02.png" alt></p><p><strong><code>raise_2.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"raise function before\n"</span>);</span><br><span class="line">        raise(SIGTSTP); <span class="comment">// 进程进入暂停状态（T）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"raise function after\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后，首先子进程输出语句</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/raise_05.png" style="zoom:80%"></p><p>之后调用 <strong><code>raise</code></strong> 函数进入暂停状态，此时父进程睡眠状态 <strong><code>S</code></strong>，子进程暂停状态 <strong><code>T</code></strong></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/raise_03.png" style="zoom:80%"></p><p>父进程睡眠 8 秒后，父进程进入运行状态 <strong><code>R</code></strong> ，此时子进程仍然是暂停状态 <strong><code>T</code></strong></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/raise_04.png" style="zoom:80%"></p><p>稍微修改一下 <strong><code>raise_2.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, WNOHANG) == <span class="number">0</span>) &#123;</span><br><span class="line">            kill(pid, <span class="number">9</span>); <span class="comment">// 杀死子进程，此时父进程没有对其进行回收资源(wait)</span></span><br><span class="line">            			  <span class="comment">// 子进程会变成僵尸进程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// wait(NULL); // 加上 wait 函数回收子进程资源，子进程就不会变成僵尸进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"raise function before\n"</span>);</span><br><span class="line">        raise(SIGTSTP); <span class="comment">// 进程进入暂停状态（T）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"raise function after\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后，首先子进程输出语句</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/raise_05.png" style="zoom:67%"></p><p>之后调用 <strong><code>raise</code></strong> 函数进入暂停状态，此时父进程睡眠状态 <strong><code>S</code></strong>，子进程暂停状态 <strong><code>T</code></strong></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/raise_06.png" style="zoom:80%"></p><p>父进程睡眠 8 秒后，父进程进入运行状态 <strong><code>R</code></strong> ，此时子进程进入僵尸状态 <strong><code>Z</code></strong></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/raise_07.png" style="zoom:80%"></p><p>加上 <strong><code>wait()</code></strong> 子进程被 <strong><code>kill</code></strong> 后不会变成僵尸进程</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/raise_08.png" style="zoom:80%"></p><h5 id="4-1-3-alarm"><a href="#4-1-3-alarm" class="headerlink" title="4.1.3 alarm"></a>4.1.3 <code>alarm</code></h5><p><strong><code>alarm</code></strong> 与 <strong><code>raise</code></strong> 的比较：</p><ul><li><p><strong>相同点</strong>：让内核发送信号给当前进程</p></li><li><p><strong>不同点</strong>：</p><ul><li><p><strong><code>alarm</code></strong> 只会发送 <strong><code>SIGALARM</code></strong> 信号 (<strong>14</strong> 号信号)</p></li><li><p><strong><code>alarm</code></strong> 会让内核<strong>定时</strong>一段时间之后发送信号， <strong><code>raise</code></strong> 会让内核<strong>立刻</strong>发信号</p></li></ul></li></ul><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/alarm函数.png" style="zoom:67%"></p><p><strong>例子：alarm</strong></p><p><strong><code>alarm.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"alarm before\n"</span>);   </span><br><span class="line">    alarm(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"alarm before\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"process things, i = %d \n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下所示，<strong><code>alarm</code></strong> 在 9 秒后终止操作</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/alarm_01.png" style="zoom:80%"></p><h4 id="4-2-信号的接收（接收信号进程）"><a href="#4-2-信号的接收（接收信号进程）" class="headerlink" title="4.2 信号的接收（接收信号进程）"></a>4.2 信号的接收（接收信号进程）</h4><p>接收信号的进程的条件：要想使接收的进程能接收信号，这个进程不能结束</p><ul><li><p><strong><code>sleep</code></strong></p></li><li><p><strong><code>while(1)</code></strong></p></li><li><strong><code>pause</code></strong> 进程状态为 <strong><code>S</code></strong></li></ul><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/pause函数.png" style="zoom:67%"></p><p><strong><code>pause.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pause before \n"</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pause after \n"</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"process things, i = %d"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，进程处于睡眠状态 <strong><code>S</code></strong></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/pause_01.png" style="zoom:80%"></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/pause_02.png" style="zoom:80%"></p><h4 id="4-3-信号的处理（接收信号进程）"><a href="#4-3-信号的处理（接收信号进程）" class="headerlink" title="4.3 信号的处理（接收信号进程）"></a>4.3 信号的处理（接收信号进程）</h4><p>收到信号的进程，应该怎样处理？处理的方式：</p><p>（1）进程的<strong>默认</strong>处理方式（内核为用户进程设置的默认处理方式）：</p><ul><li>忽略</li><li>终止进程</li><li>暂停</li></ul><p>（2）自定义的处理方式：自定义处理信号的方法告诉内核，这样线程收到了这个信号就会采用自定义的处理方式</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/signal函数.png" style="zoom:67%"></p><p><strong><code>signal</code></strong> 函数有两个参数，</p><ul><li><p>第一个参数是一个整形变量（信号值），</p></li><li><p>第二个参数是一个函数指针，是自定义的处理函数，这个函数的返回值是一个函数指针。</p></li></ul><h5 id="4-3-1-自定义处理"><a href="#4-3-1-自定义处理" class="headerlink" title="4.3.1 自定义处理"></a>4.3.1 自定义处理</h5><p><strong><code>signal.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"process signal signum = %d, i = %d\n"</span>, signum);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// return main</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    signal(<span class="number">14</span>, myfun);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"alarm before \n"</span>);</span><br><span class="line">    alarm(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"alarm after \n"</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"process things, i = %d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>signal(14, myfun);</code></strong> 表示接收到 14 号信号，进行自定义的一些处理（<strong>14号信号 —&gt; alarm</strong>）</p><p>程序运行，9秒后发送 <strong><code>alarm</code></strong> 信号，期间进程一直运行</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/signal_01.png" style="zoom:80%"></p><p>接收到 <strong><code>alarm</code></strong> 信号后，处理 <strong><code>myfun</code></strong></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/signal_02.png" style="zoom:80%"></p><p>处理 <strong><code>myfun</code></strong> 结束后，重新回到 <strong><code>main</code></strong> 中继续进行剩下的操作</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/signal_03.png" style="zoom:80%"></p><h5 id="4-3-2-SIG-IGN-SIG-DFL"><a href="#4-3-2-SIG-IGN-SIG-DFL" class="headerlink" title="4.3.2 SIG_IGN ,  SIG_DFL"></a>4.3.2 <code>SIG_IGN</code> , <code>SIG_DFL</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"process signal signum = %d"</span>, signum);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// return main</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    signal(<span class="number">14</span>, myfun);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"alarm before \n"</span>);</span><br><span class="line">    alarm(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"alarm after \n"</span>);</span><br><span class="line">    signal(<span class="number">14</span>, SIG_IGN);  <span class="comment">// 又一次接收到信号，忽略它，不会处理myfun，也不会终止运行</span></span><br><span class="line">    <span class="comment">// signal(14, SIG_DFL);  // 默认处理，9秒后终止</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"process things, i = %d"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>SIG_IGN</code></strong> , <strong><code>SIG_DFL</code></strong><br><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/signal_04.png" style="zoom:67%"><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/signal_05.png" style="zoom:80%"></p><h4 id="4-4-signal-处理进程间通信"><a href="#4-4-signal-处理进程间通信" class="headerlink" title="4.4 signal 处理进程间通信"></a>4.4 signal 处理进程间通信</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"receive signum = %d, i = %d\n"</span>, signum, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        signal(<span class="number">10</span>, myfun);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"parent process things, i = %d\n"</span>, i);</span><br><span class="line">            sleep(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    	sleep(<span class="number">10</span>);</span><br><span class="line">        kill(getppid(), <span class="number">10</span>);    <span class="comment">// SIGUSER1  10 信号</span></span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父进程死循环打印输出，子进程睡眠 10 s 后发送 10 号 <strong><code>SIGUSER1</code></strong> 信号，父进程接收到信号就会跳入处理自定义函数 <strong><code>myfun</code></strong> ，处理结束后基于死循环打印输出。结果如下：</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/signal_06.png" style="zoom:67%"></p><p>此时进程状态如下，父进程运行状态( <strong><code>R</code></strong> )，子进程僵尸状态 ( <strong><code>Z</code></strong> ) ，需要父进程进行资源回收处理。</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/signal_07.png" style="zoom:80%"></p><p>因为 <strong><code>wait()</code></strong> 操作为阻塞操作，不能直接放在处理函数之上，这会导致处理函数不会进行下去。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        signal(<span class="number">10</span>, myfun);</span><br><span class="line">    	wait(<span class="literal">NULL</span>); <span class="comment">// 放在这里会阻塞后续处理。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"parent process things, i = %d\n"</span>, i);</span><br><span class="line">            sleep(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由结果可以知道，父进程开始会处于 <strong><font color="FF000">阻塞状态</font></strong> ，只有接收 10 号信号后才会处理 <strong><code>myfun</code></strong> ，之后<strong><font color="FF000">等子进程退出</font></strong>，之后才会处理 <strong><code>printf</code></strong> 操作</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/signal_08.png" alt></p><p>因为 <strong><code>exit(0)</code></strong> 发送了 <strong><code>kill SIGCHLD</code></strong> 信号，<strong>17 号信号</strong>，所以父进程可以接收 17 信号后处理 <strong><code>wait</code></strong> 即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun1</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"receive signum = %d\n"</span>,signum);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        signal(<span class="number">10</span>, mufun);</span><br><span class="line">    	signal(<span class="number">17</span>, myfun1);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"parent process things, i = %d\n"</span>, i);</span><br><span class="line">            sleep(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样的话，在子进程结束之后，就不会产生僵尸进程</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/signal_09.png" style="zoom:80%"></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/signal_10.png" style="zoom:80%"></p><h3 id="五、IPC-通信"><a href="#五、IPC-通信" class="headerlink" title="五、IPC 通信"></a>五、IPC 通信</h3><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/IPC对象.png" style="zoom:50%"></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/IPC与IO对比.png" style="zoom:67%"></p><p>常用的 IPC 相关的 <strong><code>shell</code></strong> 命令</p><p>查看 IPC 对象 ： <strong><code>ipcs</code> <code>-m</code></strong> (共享内存) <strong><code>-q</code></strong> (消息队列) <strong><code>-s</code></strong> (信号灯)</p><p>删除 IPC 对象：<strong><code>ipcrm</code> <code>-m</code></strong> (共享内存) \ <strong><code>-q</code></strong> (消息队列) \ <strong><code>-s</code></strong> (信号灯) <strong><code>id</code></strong></p><p>返回值：<strong>共享内存</strong>，<strong>消息队列</strong>，<strong>信号灯</strong>标识符，IPC 的 ID 号</p><p>每次用 <strong><code>IPC_PRIVATE</code></strong> 操作时， <strong><code>key</code></strong> 都是一样的，都是 0</p><h3 id="六、共享内存"><a href="#六、共享内存" class="headerlink" title="六、共享内存"></a>六、共享内存</h3><h4 id="6-1-创建和打开共享内存"><a href="#6-1-创建和打开共享内存" class="headerlink" title="6.1 创建和打开共享内存"></a>6.1 创建和打开共享内存</h4><p><strong><code>shmget</code></strong> 函数</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/shmget函数.png" style="zoom:67%"><br>出错：返回 - 1</p><p><strong><code>shmget.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/shm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    shmid = shmget(IPC_PRIVATE, <span class="number">128</span>, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create share memory failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"creat share memory success shmid = %d\n"</span>, shmid);</span><br><span class="line">    system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">    <span class="comment">// system("ipcrm -m shmid");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次运行一次，创建一个共享内存，下图运行三次后。</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/shmget_01.png" style="zoom:80%"></p><p>使用 <strong><code>ipcrm -m id</code></strong> 删除后两个共享内存</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/shmget_02.png" style="zoom:80%"></p><h4 id="6-2-ftok-函数，创建-key-值"><a href="#6-2-ftok-函数，创建-key-值" class="headerlink" title="6.2 ftok 函数，创建 key 值"></a>6.2 ftok 函数，创建 key 值</h4><p><strong><code>char ftok(const char* path, char key)</code></strong></p><ul><li><p><strong>参数</strong>：第一个参数：文件路径和文件名；第二个参数：一个字符</p></li><li><p><strong>返回值</strong>：正确返回一个 key 值，出错返回 -1</p></li></ul><p><strong><code>IPC_PRIVATE</code></strong> 操作时，共享内存的 key 值都是一样，都是 <strong>0</strong>， 所以对于非亲缘关系进程使用 <strong><code>ftok</code></strong> 来创建 key 值。只要 key 值是一样的，用户空间的进程通过这个函数打开，则会对内核的同一个 IPC 对象操作。</p><p><strong><code>shmget.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/shm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    key = ftok(<span class="string">"./a.c"</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create key failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create key success, key = %X\n"</span>, key);</span><br><span class="line">    shmid = shmget(key, <span class="number">128</span>, IPC_CREAT | <span class="number">0777</span>);  <span class="comment">// 需要在权限处加上宏 TPC_CREAT</span></span><br><span class="line">    <span class="comment">// shmid = shmget(IPC_PRIVATE, 128, 0777); 对比</span></span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create share memory failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"creat share memory success shmid = %d\n"</span>, shmid);</span><br><span class="line">    system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">    <span class="comment">// system("ipcrm -m shmid");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：之前用 <strong><code>IPC_PRIVATE</code></strong> 创建的 key = 0，现在用自定义的 key</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/shmget_03.png" style="zoom:80%"></p><h4 id="6-3-将共享内存映射到用户空间中"><a href="#6-3-将共享内存映射到用户空间中" class="headerlink" title="6.3 将共享内存映射到用户空间中"></a>6.3 将共享内存映射到用户空间中</h4><p>为了方便用户空间对共享内存的操作，使用地址映射的方式。利用 <strong><code>shmat</code></strong> 函数。</p><p><strong><code>void *shmat (int shmid, const void * shmaddr, int shmflg);</code></strong></p><p><strong>参数</strong>：</p><ul><li><p>第一个参数：ID号；</p></li><li><p>第二个参数：映射到的地址，<strong>NULL</strong> 为系统自动完成的映射；</p></li><li><p>第三个参数：<code>shmflg</code></p><ul><li><strong><code>SHM_RDONLY</code></strong>共享内存只读</li><li>默认 0，表示共享内存可读写</li></ul></li></ul><p>返回值： 成功：映射后的地址；失败：<strong>NULL</strong></p><p><strong><code>shmat.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/shm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    key = ftok(<span class="string">"./a.c"</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create key failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create key success, key = %X\n"</span>, key);</span><br><span class="line">    shmid = shmget(key, <span class="number">128</span>, IPC_CREAT | <span class="number">0777</span>); </span><br><span class="line">    <span class="comment">// shmid = shmget(IPC_PRIVATE, 128, 0777); 对比</span></span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create share memory failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"creat share memory success shmid = %d\n"</span>, shmid);</span><br><span class="line">    system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">    </span><br><span class="line">    p = (<span class="keyword">char</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"shmat function failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// write share memory</span></span><br><span class="line">    <span class="comment">// stdin:键盘输入，128字节，写入 p 中</span></span><br><span class="line">    fgets(p, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// start read share memory</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"share memory data: %s\n"</span>, p);</span><br><span class="line">    <span class="comment">// printf("share memory data: %s\n", p);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后，键盘输入: test 进共享内存，后读数据输出</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/shmat01.png" style="zoom:80%"></p><p><strong>与管道不同</strong>，共享内存中的数据在读取后<strong>并没有被删除</strong>，两条输出语句的结果如下：</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/shmat02.png" style="zoom:80%"></p><p><strong>共享内存特点：</strong></p><ul><li>共享内存创建后，一直存在于内核中，知道被删除或系统关闭；</li><li>共享内存和管道不一样，读取后，内容仍在其共享内存中。</li></ul><h4 id="6-4-删除进程里的地址映射"><a href="#6-4-删除进程里的地址映射" class="headerlink" title="6.4 删除进程里的地址映射"></a>6.4 删除进程里的地址映射</h4><p>使用 <strong><code>shmdt</code></strong> 函数，删除用户空间的地址映射</p><p><strong><code>int shmdt(const void* shmaddr);</code></strong></p><p><strong>参数</strong>：<strong><code>shmaddr</code></strong> ：共享内存映射后的地址（用户空间）</p><p><strong>返回值</strong>：成功：0； 失败： -1</p><p><strong><code>shmdt.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/shm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    key = ftok(<span class="string">"./a.c"</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create key failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create key success, key = %X\n"</span>, key);</span><br><span class="line">    shmid = shmget(key, <span class="number">128</span>, IPC_CREAT | <span class="number">0777</span>); </span><br><span class="line">    <span class="comment">// shmid = shmget(IPC_PRIVATE, 128, 0777); 对比</span></span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create share memory failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"creat share memory success shmid = %d\n"</span>, shmid);</span><br><span class="line">    system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">    </span><br><span class="line">    p = (<span class="keyword">char</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"shmat function failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// write share memory</span></span><br><span class="line">    <span class="comment">// stdin:键盘输入，128字节，写入 p 中</span></span><br><span class="line">    fgets(p, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// start read share memory</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"share memory data: %s\n"</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"share memory data: %s\n"</span>, p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放用户空间共享内存</span></span><br><span class="line">    shmdt(p);</span><br><span class="line">    <span class="built_in">memcpy</span>(p, <span class="string">"abcd"</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享内存释放后，不能再次使用它，所以 <strong><code>memcpy</code></strong> 函数操作会出现段错误。</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/shmdt_01.png" style="zoom:80%"></p><h4 id="6-5-shmctl：删除共享内存对象"><a href="#6-5-shmctl：删除共享内存对象" class="headerlink" title="6.5 shmctl：删除共享内存对象"></a>6.5 shmctl：删除共享内存对象</h4><p><strong><code>int shmctl(int shmid, int cmd, struct shmid_ds *buf)</code></strong></p><p><strong>参数</strong>：</p><ul><li><strong><code>shmid</code></strong> ：要操作的共享内存标识符</li><li><p><strong><code>cmd</code></strong> ：</p><ul><li><strong><code>IPC_STAT</code></strong> (获取对象属性) — 实现了 <strong><code>ipcs - m</code></strong></li><li><strong><code>IPC_SET</code></strong> （设置对象属性）</li><li><strong><code>IPC_RMID</code></strong> (删除对象) — 实现了 <strong><code>ipcrm -m id</code></strong></li></ul></li><li><p><strong><code>buf</code></strong> : 指定 <strong><code>IPC_STAT/IPC_SET</code></strong> 时可以保存 / 设置属性。</p></li></ul><p><strong>返回值</strong>：成功：0； 失败：-1；</p><p><strong><code>shmctl.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/shm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    key = ftok(<span class="string">"./a.c"</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create key failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create key success, key = %X\n"</span>, key);</span><br><span class="line">    shmid = shmget(key, <span class="number">128</span>, IPC_CREAT | <span class="number">0777</span>); </span><br><span class="line">    <span class="comment">// shmid = shmget(IPC_PRIVATE, 128, 0777); 对比</span></span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create share memory failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"creat share memory success shmid = %d\n"</span>, shmid);</span><br><span class="line">    system(<span class="string">"ipcs -m"</span>);</span><br><span class="line">    </span><br><span class="line">    p = (<span class="keyword">char</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"shmat function failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// write share memory</span></span><br><span class="line">    <span class="comment">// stdin:键盘输入，128字节，写入 p 中</span></span><br><span class="line">    fgets(p, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// start read share memory</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"share memory data: %s\n"</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"share memory data: %s\n"</span>, p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放用户空间共享内存</span></span><br><span class="line">    shmdt(p);</span><br><span class="line">    <span class="built_in">memcpy</span>(p, <span class="string">"abcd"</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除共享内存对象</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">"ipcs -m"</span>);<span class="comment">// 查看共享内存还在不在</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，键盘输入 test ，结果打印两遍后删除共享内存对象，发现 <strong><code>shmid = 3</code></strong> 的共享内存被删除。</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/shmctl_01.png" style="zoom:80%"></p><p><strong><code>myipcrm.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/shm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"please input param\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-m"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"delete share memory\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    shmid = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shmid = %d\n"</span>, shmid);</span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    system(<span class="string">"ipcs -m"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己创建的 <strong><code>ipcrm -m id</code></strong> 操作，成功的删除了 <strong><code>shmid = 0</code></strong> 的共享内存</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/shmctl_02.png" style="zoom:80%"></p><h4 id="6-6-有亲缘关系的进程（IPC-PRIVATE）"><a href="#6-6-有亲缘关系的进程（IPC-PRIVATE）" class="headerlink" title="6.6 有亲缘关系的进程（IPC_PRIVATE）"></a>6.6 有亲缘关系的进程（IPC_PRIVATE）</h4><p><strong><code>shmctl_2.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/shm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数，不需要任何处理，主要为了唤醒 pause 函数，且避免 sigusr1/2终止函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">char</span>* p;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    shmid = shmget(IPC_PRIVATE, <span class="number">128</span>, IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"creat share memory failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"creat memory success shmid = %d\n"</span>, shmid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// shmget 在 fork 之前</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        signal(SIGUSR2, myfun);</span><br><span class="line">        p = (<span class="keyword">char</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"shmat function failure\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// write share memory</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"parent process start write share memory: \n"</span>);</span><br><span class="line">            fgets(p, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">            kill(pid, SIGUSR1); <span class="comment">// 通知子进程去读</span></span><br><span class="line">            pause(); <span class="comment">// 等待子进程去读</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        signal(SIGUSR1, myfun);</span><br><span class="line">        p = (<span class="keyword">char</span> *) shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"shmat function failure\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            pause(); <span class="comment">// 等待父进程去写</span></span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">"share memory data: %s\n"</span>, p);</span><br><span class="line">            kill(getppid(), SIGUSR2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行，父进程写，子进程读取，两个进程状态都是睡眠状态 （<strong><code>S</code></strong>）</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/shmctl_03.png" style="zoom:80%"></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/shmctl_04.png" style="zoom:80%"></p><h4 id="6-7-无亲缘关系的进程（key）"><a href="#6-7-无亲缘关系的进程（key）" class="headerlink" title="6.7 无亲缘关系的进程（key）"></a>6.7 无亲缘关系的进程（key）</h4><p><strong><code>server.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/shm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">124</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数，不需要任何处理，主要为了唤醒 pause 函数，且避免 sigusr1/2终止函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span>* <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="comment">// 创建 key</span></span><br><span class="line">    key = ftok(<span class="string">"./a.c"</span>,<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create key failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create key success, key = %X\n"</span>, key);</span><br><span class="line">    <span class="comment">// 创建 share memory</span></span><br><span class="line">    shmid = shmget(key, <span class="number">128</span>, IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"creat share memory failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"creat memory success shmid = %d\n"</span>, shmid);</span><br><span class="line">	<span class="comment">// 信号处理</span></span><br><span class="line">    signal(SIGUSR2, myfun);</span><br><span class="line">    <span class="comment">// 地址映射</span></span><br><span class="line">    p = (struct mybuf*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"shmat function failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get client pid</span></span><br><span class="line">    p-&gt;pid = getpid(); <span class="comment">// write server pid to share memory</span></span><br><span class="line">    pause(); <span class="comment">//wait client read server pid;</span></span><br><span class="line">    pid = p-&gt;pid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// write share memory</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" process start write share memory: \n"</span>);</span><br><span class="line">        fgets(p-&gt;buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        kill(pid, SIGUSR1); <span class="comment">// 通知client进程去读</span></span><br><span class="line">        pause(); <span class="comment">// 等待client 进程去读</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>client.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/shm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">124</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数，不需要任何处理，主要为了唤醒 pause 函数，且避免 sigusr1/2终止函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mybuf</span>* <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="comment">// 创建 key</span></span><br><span class="line">    key = ftok(<span class="string">"./a.c"</span>,<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create key failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create key success, key = %X\n"</span>, key);</span><br><span class="line">    <span class="comment">// 创建 share memory</span></span><br><span class="line">    shmid = shmget(key, <span class="number">128</span>, IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"creat share memory failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"creat memory success shmid = %d\n"</span>, shmid);  </span><br><span class="line">    <span class="comment">// 信号处理</span></span><br><span class="line">    signal(SIGUSR1, myfun);</span><br><span class="line">    <span class="comment">// 地址映射</span></span><br><span class="line">    p = (struct mybuf*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"shmat function failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// get server pid</span></span><br><span class="line">    <span class="comment">// read share memory</span></span><br><span class="line">    pid = p-&gt;pid;</span><br><span class="line">    <span class="comment">// write client pid to share memory</span></span><br><span class="line">    p-&gt;pid = getpid();</span><br><span class="line">    kill(pid, SIGUSR2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// client start read data from share memory</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pause(); <span class="comment">// wait server write data to share memory;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client process receive data from share memory: %s"</span>, p-&gt;buf);</span><br><span class="line">        kill(pid, SIGUSR2); <span class="comment">// server may write share memory</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的关键是：要先通过共享内存交互双方的 <strong><code>pid</code></strong>;</p><p>运行服务器，客户端程序，可以发现双方都可以操作 <strong><code>shmid = 8</code></strong> 的共享内存，服务器端发送多次发送数据，客户端多次接受数据；服务器每次发送完，等待下一次输入；客户端每次接受，等待下一次服务器的消息发送。</p><p>结果如下：</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/shm_server.png" alt></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/shm_client.png" alt></p><h3 id="七、消息队列"><a href="#七、消息队列" class="headerlink" title="七、消息队列"></a>七、消息队列</h3><p>链式队列</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/消息队列数据结构.png" style="zoom:80%"></p><p><strong><code>msqid_ds</code></strong> 内核维护消息队列的结构体，队列的第一个消息指针 <strong><code>msg_first</code></strong>，最后一个消息指针 <strong><code>msg_last</code></strong> ，消息中有一个成员指针 <strong><code>next</code></strong></p><p>每一个消息中包含有哪些内容：</p><ul><li>Data ：数据</li><li>Length：数据的长度</li><li>Type：数据的类型</li></ul><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/消息函数.png" style="zoom:80%"></p><h4 id="7-1-消息队列的创建和打开"><a href="#7-1-消息队列的创建和打开" class="headerlink" title="7.1 消息队列的创建和打开"></a>7.1 消息队列的创建和打开</h4><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/msgget函数.png" style="zoom:80%"></p><p><strong><code>msgget.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/msg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    msgid = msgget(IPC_PRIVATE,<span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create message queue failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create message queue success, msgid = %d\n"</span>, msgid);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三次运行程序创建了三个消息队列</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/msgget_01.png" style="zoom:80%"></p><h4 id="7-2-消息队列控制"><a href="#7-2-消息队列控制" class="headerlink" title="7.2 消息队列控制"></a>7.2 消息队列控制</h4><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/msgctl函数.png" style="zoom:67%"></p><p><strong><code>msgctl.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/msg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    msgid = msgget(IPC_PRIVATE,<span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create message queue failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create message queue success, msgid = %d\n"</span>, msgid);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// delete message queue</span></span><br><span class="line">    msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行，先创建一个 <strong><code>msgid = 3</code></strong> 消息队列，之后删除它</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/msgctl_01.png" style="zoom:80%"></p><h4 id="7-3-消息发送"><a href="#7-3-消息发送" class="headerlink" title="7.3 消息发送"></a>7.3 消息发送</h4><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/msgsnd函数.png" style="zoom:67%"></p><p><strong><code>msgsnd.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/msg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> type;</span><br><span class="line">    <span class="keyword">char</span> voltage[<span class="number">124</span>];</span><br><span class="line">    <span class="keyword">char</span> ID[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>;</span></span><br><span class="line">    msgid = msgget(IPC_PRIVATE,<span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create message queue failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create message queue success, msgid = %d\n"</span>, msgid);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// init sendbuf</span></span><br><span class="line">    sendbuf.type = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input message:\n"</span>);</span><br><span class="line">    fgets(sendbuf.voltage, <span class="number">124</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// start write message to message queue</span></span><br><span class="line">    msgsnd(msgid, (<span class="keyword">void</span> *)&amp;sendbuf, <span class="built_in">strlen</span>(sendbuf.voltage), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// delete message queue</span></span><br><span class="line">    msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-消息接收"><a href="#7-4-消息接收" class="headerlink" title="7.4 消息接收"></a>7.4 消息接收</h4><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/msgrcv函数.png" style="zoom:67%"></p><p><strong><code>msgrcv.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/msg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> type;</span><br><span class="line">    <span class="keyword">char</span> voltage[<span class="number">124</span>];</span><br><span class="line">    <span class="keyword">char</span> ID[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">recvbuf</span>;</span></span><br><span class="line">    <span class="keyword">int</span> readret;</span><br><span class="line">    msgid = msgget(IPC_PRIVATE,<span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create message queue failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create message queue success, msgid = %d\n"</span>, msgid);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// init sendbuf</span></span><br><span class="line">    sendbuf.type = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input message:\n"</span>);</span><br><span class="line">    fgets(sendbuf.voltage, <span class="number">124</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// start write message to message queue</span></span><br><span class="line">    msgsnd(msgid, (<span class="keyword">void</span> *)&amp;sendbuf, <span class="built_in">strlen</span>(sendbuf.voltage), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// start read message from message queue</span></span><br><span class="line">    <span class="built_in">memset</span>(recvbuf.voltage, <span class="number">0</span>, <span class="number">124</span>);</span><br><span class="line">    readret = msgrcv(msgid, (<span class="keyword">void</span> *)&amp;recvbuf, <span class="number">124</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"recv: %s, readret = %d\n"</span>, recvbuf.voltage, readret);</span><br><span class="line">    <span class="comment">// 第二次读</span></span><br><span class="line">    <span class="comment">// msgrcv(msgid, (void *)&amp;recvbuf, 124, 100, 0);</span></span><br><span class="line">    <span class="comment">// printf("recv: %s\n", recvbuf.voltage);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// delete message queue </span></span><br><span class="line">    msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行，键盘写入消息，然后在读取消息打印输出</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/msgrcv_01.png" style="zoom:80%"></p><p>如果两次读取则会发生错误，程序或阻塞，因为读取后消息被删除，读函数阻塞等待</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/msgrcv_02.png" style="zoom:80%"></p><h4 id="7-5-单向读写操作"><a href="#7-5-单向读写操作" class="headerlink" title="7.5 单向读写操作"></a>7.5 单向读写操作</h4><p><strong><code>write.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/msg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> type;</span><br><span class="line">    <span class="keyword">char</span> voltage[<span class="number">124</span>];</span><br><span class="line">    <span class="keyword">char</span> ID[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">recvbuf</span>;</span></span><br><span class="line">    <span class="keyword">int</span> readret;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    key = ftok(<span class="string">"./a.c"</span>, <span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"creat key failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    msgid = msgget(key,IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create message queue failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create message queue success, msgid = %d\n"</span>, msgid);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">    </span><br><span class="line">    sendbuf.type = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// write message queue</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// init sendbuf</span></span><br><span class="line">        <span class="built_in">memset</span>(sendbuf.voltage, <span class="number">0</span>, <span class="number">124</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"please input message:\n"</span>);</span><br><span class="line">        fgets(sendbuf.voltage, <span class="number">124</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// start write message to message queue</span></span><br><span class="line">    	msgsnd(msgid, (<span class="keyword">void</span> *)&amp;sendbuf, <span class="built_in">strlen</span>(sendbuf.voltage), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// delete message queue </span></span><br><span class="line">    msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>read.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/msg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> type;</span><br><span class="line">    <span class="keyword">char</span> voltage[<span class="number">124</span>];</span><br><span class="line">    <span class="keyword">char</span> ID[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">recvbuf</span>;</span></span><br><span class="line">    <span class="keyword">int</span> readret;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    key = ftok(<span class="string">"./a.c"</span>, <span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"creat key failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    msgid = msgget(key,IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create message queue failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create message queue success, msgid = %d\n"</span>, msgid);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// read message queue</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// init recvbuf</span></span><br><span class="line">        <span class="built_in">memset</span>(recvbuf.voltage, <span class="number">0</span>, <span class="number">124</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// start read message to message queue</span></span><br><span class="line">    	msgrcv(msgid, (<span class="keyword">void</span> *)&amp;recvbuf, <span class="number">124</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"receive data from message queue: %s\n"</span>, recvbuf.voltage);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// delete message queue </span></span><br><span class="line">    msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后，<strong><code>write.c</code></strong> 写消息，<strong><code>read.c</code></strong> 读消息 (该例子与上一章最后一个例子相似)</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/msgwrite_01.png" alt="msgwrite_01"></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/msgread_01.png" alt></p><h4 id="7-6-双向通信"><a href="#7-6-双向通信" class="headerlink" title="7.6 双向通信"></a>7.6 双向通信</h4><p><strong><code>server.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/msg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> type;</span><br><span class="line">    <span class="keyword">char</span> voltage[<span class="number">124</span>];</span><br><span class="line">    <span class="keyword">char</span> ID[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">recvbuf</span>;</span></span><br><span class="line">    <span class="keyword">int</span> readret;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    key = ftok(<span class="string">"./b.c"</span>, <span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"creat key failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    msgid = msgget(key,IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create message queue failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create message queue success, msgid = %d\n"</span>, msgid);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在消息队列创建之后，使用 fork 函数</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">// parent process write type:100 Data</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sendbuf.type = <span class="number">100</span>;</span><br><span class="line">    	<span class="comment">// write message queue</span></span><br><span class="line">   		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        	<span class="comment">// init sendbuf</span></span><br><span class="line">        	<span class="built_in">memset</span>(sendbuf.voltage, <span class="number">0</span>, <span class="number">124</span>);</span><br><span class="line">        </span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">"please input message:\n"</span>);</span><br><span class="line">        	fgets(sendbuf.voltage, <span class="number">124</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        </span><br><span class="line">        	<span class="comment">// start write message to message queue</span></span><br><span class="line">    		msgsnd(msgid, (<span class="keyword">void</span> *)&amp;sendbuf, <span class="built_in">strlen</span>(sendbuf.voltage), <span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// child process read type:200 Data</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        	<span class="built_in">memset</span>(recvbuf.voltage, <span class="number">0</span>, <span class="number">124</span>);</span><br><span class="line">       	 	msgrcv(msgid, (<span class="keyword">void</span> *)&amp;recvbuf, <span class="number">124</span>, <span class="number">200</span>, <span class="number">0</span>);</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">"receive from message queue: %s\n"</span>, recvbuf.voltage); </span><br><span class="line">            <span class="comment">// 可以打印输出后，当前行仍然提示可以输入数据，而不是没有提示</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"please input message:\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// delete message queue </span></span><br><span class="line">    msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>client.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/msg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> type;</span><br><span class="line">    <span class="keyword">char</span> voltage[<span class="number">124</span>];</span><br><span class="line">    <span class="keyword">char</span> ID[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">recvbuf</span>;</span></span><br><span class="line">    <span class="keyword">int</span> readret;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    key = ftok(<span class="string">"./b.c"</span>, <span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"creat key failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    msgid = msgget(key,IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create message queue failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create message queue success, msgid = %d\n"</span>, msgid);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// 在消息队列创建之后，使用 fork 函数</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">// parent process read type:100 Data</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">          	<span class="built_in">memset</span>(recvbuf.voltage, <span class="number">0</span>, <span class="number">124</span>);</span><br><span class="line">        	msgrcv(msgid, (<span class="keyword">void</span> *)&amp;recvbuf, <span class="number">124</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">"receive data from message queue: %s\n"</span>, recvbuf.voltage); </span><br><span class="line">            <span class="comment">// 可以打印输出后，当前行仍然提示可以输入数据，而不是没有提示</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"please input message:\n"</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// child process write type:200 Data</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sendbuf.type = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(sendbuf.voltage, <span class="number">0</span>, <span class="number">124</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"please input message:\n"</span>);</span><br><span class="line">            fgets(sendbuf.voltage, <span class="number">124</span>, <span class="built_in">stdin</span>);</span><br><span class="line">            msgsnd(msgid, (<span class="keyword">void</span> *)&amp;sendbuf, <span class="built_in">strlen</span>(sendbuf.voltage), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// delete message queue </span></span><br><span class="line">    msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    system(<span class="string">"ipcs -q"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序：<strong><code>server</code></strong>，<strong><code>client</code></strong> 可以实现双方同时通信，皆可以收发</p><p>测试如下，双方交替通信三次。</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/msgserver.png" style="zoom:80%"></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/msgclient.png" style="zoom:80%"></p><h3 id="八、信号灯"><a href="#八、信号灯" class="headerlink" title="八、信号灯"></a>八、信号灯</h3><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/信号灯结构.png" style="zoom:67%"></p><p>所有函数是对一个集合的操作：</p><h4 id="8-1-创建和打开信号灯"><a href="#8-1-创建和打开信号灯" class="headerlink" title="8.1 创建和打开信号灯"></a>8.1 创建和打开信号灯</h4><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/semget函数.png" style="zoom:67%"></p><p><strong><code>semget.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/sem.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> semid;</span><br><span class="line">    semid = semget(IPC_PRIVATE, <span class="number">3</span>, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (semid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create semaphore failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create semaphore success, semid = %d\n"</span>, semid);</span><br><span class="line">    system(<span class="string">"ipcs -s"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由内核给我们创建拥有三个信号量，权限是 777 的信号灯，因为使用 <strong><code>IPC_PRIVATE</code></strong> key，所以键值是 0</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/semget_01.png" style="zoom:80%"></p><h4 id="8-2-信号灯的控制"><a href="#8-2-信号灯的控制" class="headerlink" title="8.2 信号灯的控制"></a>8.2 信号灯的控制</h4><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/semctl函数.png" style="zoom:67%"></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/semctl_setval.png" style="zoom:67%"></p><p><strong><code>semctl.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/sem.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> semid;</span><br><span class="line">    semid = semget(IPC_PRIVATE, <span class="number">3</span>, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (semid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create semaphore failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create semaphore success, semid = %d\n"</span>, semid);</span><br><span class="line">    system(<span class="string">"ipcs -s"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// delete semaphore</span></span><br><span class="line">    semctl(semid, <span class="number">0</span>, IPC_RMID);</span><br><span class="line">    system(<span class="string">"ipcs -s"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现被创建的 <strong><code>semid = 4</code></strong> 的信号灯被删除</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/semctl.png" style="zoom:80%"></p><h4 id="8-3-线程同步"><a href="#8-3-线程同步" class="headerlink" title="8.3 线程同步"></a>8.3 线程同步</h4><h5 id="8-3-1-posix-实现方法"><a href="#8-3-1-posix-实现方法" class="headerlink" title="8.3.1 posix 实现方法"></a>8.3.1 posix 实现方法</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// child thread code</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun</span><span class="params">(<span class="keyword">char</span>* var)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;  <span class="comment">// second</span></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this is fun j = %d\n"</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main thread code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"hello linux\n"</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, (<span class="keyword">void</span> *)str);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create thread failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// first</span></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this is main fun, i = %d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：<strong><code>gcc -o posix posix.c -lpthread</code></strong></p><p>因为没有加 <strong><code>PV</code></strong> 操作，所以每次程序进行的顺序都是乱的。</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/posix_01.png" style="zoom:67%"><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/posix_02.png" style="zoom:67%"></p><p>使用 posix 信号量来实现两个线程之间的同步</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"semaphore.h"</span></span></span><br><span class="line"><span class="comment">// 定义信号量</span></span><br><span class="line"><span class="keyword">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// child thread code</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun</span><span class="params">(<span class="keyword">char</span>* var)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">// p wait</span></span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;  <span class="comment">// second</span></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this is fun j = %d\n"</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main thread code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"hello linux\n"</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    sem_init(&amp;sem, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// sem = 0;</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, (<span class="keyword">void</span> *)str);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create thread failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// first</span></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this is main fun, i = %d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// v</span></span><br><span class="line">    sem_post(&amp;sem);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用信号量，可以实现线程之间的同步，主线程完成后子线程操作</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/posix_03.png" style="zoom:80%"></p><h5 id="8-3-2-信号灯实现方法"><a href="#8-3-2-信号灯实现方法" class="headerlink" title="8.3.2 信号灯实现方法"></a>8.3.2 信号灯实现方法</h5><p><strong><code>semop</code></strong>函数</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/semop函数1.png" style="zoom:67%"></p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/semop函数2.png" style="zoom:67%"></p><p><strong><code>sem.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/ipc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/sem.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义信号量</span></span><br><span class="line"><span class="comment">// sem_t sem;</span></span><br><span class="line"><span class="comment">// 定于信号灯联合体</span></span><br><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span>              val;    <span class="comment">/* Value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>    <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;  <span class="comment">/* Array for GETALL, SETALL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>  *__<span class="title">buf</span>;</span>  <span class="comment">/* Buffer for IPC_INFO (Linux-specific) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> semid;</span><br><span class="line"><span class="keyword">union</span> semun mysemun;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">mysembuf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// child thread code</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun</span><span class="params">(<span class="keyword">char</span>* var)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">// p wait</span></span><br><span class="line">    <span class="comment">// sem_wait(&amp;sem);</span></span><br><span class="line">    mysembuf.sem_op = <span class="number">-1</span>;</span><br><span class="line">    semop(semid, &amp;mysembuf, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;  <span class="comment">// second</span></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this is fun j = %d\n"</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main thread code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"hello linux\n"</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">// 创建信号灯</span></span><br><span class="line">    semid = semget(IPC_PRIVATE, <span class="number">3</span>, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (semid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create semaphore failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create semaphore success\n"</span>);</span><br><span class="line">    system(<span class="string">"ipcs -s"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sem_init(&amp;sem, 0, 0); // sem = 0;</span></span><br><span class="line">    <span class="comment">// 信号量的初始化</span></span><br><span class="line">    mysemun.val = <span class="number">0</span>;</span><br><span class="line">    semctl(semid, <span class="number">0</span>, SETVAL, mysemun);</span><br><span class="line">    mysembuf.sem_num = <span class="number">0</span>;</span><br><span class="line">    mysembuf.sem_flg = <span class="number">0</span>; <span class="comment">// 阻塞操作</span></span><br><span class="line">    </span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, (<span class="keyword">void</span> *)str);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create thread failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// first</span></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this is main fun, i = %d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// v</span></span><br><span class="line">    <span class="comment">// sem_post(&amp;sem);</span></span><br><span class="line">    mysembuf.sem_op = <span class="number">1</span>;</span><br><span class="line">    semop(semid, &amp;mysembuf, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现结果与 posix 实现方法相同</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/sem_posix.png" style="zoom:80%"></p><h4 id="8-4-进程同步"><a href="#8-4-进程同步" class="headerlink" title="8.4 进程同步"></a>8.4 进程同步</h4><p><strong><code>server.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/ipc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/sem.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义信号量</span></span><br><span class="line"><span class="comment">// sem_t sem;</span></span><br><span class="line"><span class="comment">// 定于信号灯联合体</span></span><br><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span>              val;    <span class="comment">/* Value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>    <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;  <span class="comment">/* Array for GETALL, SETALL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>  *__<span class="title">buf</span>;</span>  <span class="comment">/* Buffer for IPC_INFO (Linux-specific) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> semid;</span><br><span class="line"><span class="keyword">union</span> semun mysemun;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">mysembuf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main thread code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 key</span></span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">    key = ftok(<span class="string">"./a.c"</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create key failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create key success\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建信号灯</span></span><br><span class="line">    semid = semget(key, <span class="number">3</span>, IPC_CREAT | <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (semid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create semaphore failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create semaphore success, semid = %d\n"</span>, semid);</span><br><span class="line">    system(<span class="string">"ipcs -s"</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 初始化信号  让client先运行，让client完成初始化即可，client 会使用 P 操作</span></span><br><span class="line">    <span class="comment">// mysemun.val = 0;</span></span><br><span class="line">    <span class="comment">// semctl(semid, 0, SETVAL, mysemun);</span></span><br><span class="line">    mysembuf.sem_num = <span class="number">0</span>;</span><br><span class="line">    mysembuf.sem_flg = <span class="number">0</span>; <span class="comment">// 阻塞操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// first</span></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server fun, i = %d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// v</span></span><br><span class="line">    mysembuf.sem_op = <span class="number">1</span>;</span><br><span class="line">    semop(semid, &amp;mysembuf, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>client.c</code></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pthread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/ipc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys/sem.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义信号量</span></span><br><span class="line"><span class="comment">// sem_t sem;</span></span><br><span class="line"><span class="comment">// 定于信号灯联合体</span></span><br><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span>              val;    <span class="comment">/* Value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>    <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;  <span class="comment">/* Array for GETALL, SETALL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>  *__<span class="title">buf</span>;</span>  <span class="comment">/* Buffer for IPC_INFO (Linux-specific) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> semid;</span><br><span class="line"><span class="keyword">union</span> semun mysemun;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">mysembuf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main thread code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 key</span></span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">    key = ftok(<span class="string">"./a.c"</span>, <span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create key failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create key success\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建信号灯</span></span><br><span class="line">    semid = semget(key, <span class="number">3</span>, IPC_CREATE | <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (semid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create semaphore failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create semaphore success, semid = %d\n"</span>, semid);</span><br><span class="line">    system(<span class="string">"ipcs -s"</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 初始化信号</span></span><br><span class="line">    mysemun.val = <span class="number">0</span>;</span><br><span class="line">    semctl(semid, <span class="number">0</span>, SETVAL, mysemun);</span><br><span class="line">    mysembuf.sem_num = <span class="number">0</span>;</span><br><span class="line">    mysembuf.sem_flg = <span class="number">0</span>; <span class="comment">// 阻塞操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// P</span></span><br><span class="line">    mysembuf.sem_op = <span class="number">-1</span>;</span><br><span class="line">    semop(semid, &amp;mysembuf, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// first</span></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client fun, i = %d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个进程之间的逻辑如下：</p><p>首先打开 <strong><code>client</code></strong> 进程，创建信号灯，初始化信号灯，之后 P 操作，处于阻塞状态</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/sem_pv01.png" style="zoom:80%"></p><p>打开 <strong><code>server</code></strong> 进程，打开信号灯，执行程序代码，打印输出，睡眠 3 秒后，执行 V 操作</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/sem_pv02.png" style="zoom:80%"></p><p><strong><code>client</code></strong> 执行 P 操作之后的代码，打印输出</p><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/sem_pv03.png" style="zoom:80%"></p><h3 id="函数分布图："><a href="#函数分布图：" class="headerlink" title="函数分布图："></a>函数分布图：</h3><p><img src="/Network_Communications/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/IPC流程图.png" alt></p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><blockquote><p><a href="https://www.bilibili.com/video/BV1tJ41117ty?p=1" target="_blank" rel="noopener">linux进程间通信_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Network_Communications</category>
      </categories>
      <tags>
        <tag>Network_Communications</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL常用命令</title>
    <url>/Database/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h3 id="1-操作数据库"><a href="#1-操作数据库" class="headerlink" title="1  操作数据库"></a>1 操作数据库</h3><h4 id="1-1-创建数据库"><a href="#1-1-创建数据库" class="headerlink" title="1.1 创建数据库"></a>1.1 创建数据库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE mydb1;</span><br><span class="line"></span><br><span class="line">CREATE DATABASE mydb2 CHARACTER SET utf8; # 定义编码集</span><br><span class="line"></span><br><span class="line">CREATE DATABASE mydb3 CHARACTER SET utf8 COLLATE utf8_bin; # 定义校对规则</span><br></pre></td></tr></table></figure><h4 id="1-2-查看数据库"><a href="#1-2-查看数据库" class="headerlink" title="1.2 查看数据库"></a>1.2 查看数据库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES # 查看当前数据库服务器中所有数据库</span><br><span class="line"></span><br><span class="line">SHOW CREATE DATABASE mydb1; # 查看前面创建的mydb1数据库的定义信息</span><br></pre></td></tr></table></figure><h4 id="1-3-修改数据库"><a href="#1-3-修改数据库" class="headerlink" title="1.3 修改数据库"></a>1.3 修改数据库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE mydb1 CHARACTER SET utf8; # 修改编码集</span><br><span class="line"></span><br><span class="line">ALTER DATABASE mydb1 COLLATE utf8_bin; # 修改校对规则</span><br></pre></td></tr></table></figure><h4 id="1-4-删除数据库"><a href="#1-4-删除数据库" class="headerlink" title="1.4 删除数据库"></a>1.4 删除数据库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP DATABASE mydb1; # 删除</span><br></pre></td></tr></table></figure><h4 id="1-5-选择数据库"><a href="#1-5-选择数据库" class="headerlink" title="1.5 选择数据库"></a>1.5 选择数据库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mydb1;  # 进入，没有退出操作</span><br><span class="line"></span><br><span class="line">SELECT DATABASE(); # 查看当前所选的数据库</span><br></pre></td></tr></table></figure><h3 id="2-表"><a href="#2-表" class="headerlink" title="2  表"></a>2 表</h3><h4 id="2-1-增加表"><a href="#2-1-增加表" class="headerlink" title="2.1 增加表"></a>2.1 增加表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t1</span><br><span class="line">(</span><br><span class="line">    id INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    gender CHAR(1),</span><br><span class="line">    worktime DATE,</span><br><span class="line">    money DOUBLE</span><br><span class="line">) CHARACTER SET utf8 COLLATE utf8_bin;</span><br></pre></td></tr></table></figure><h4 id="2-2-查找表"><a href="#2-2-查找表" class="headerlink" title="2.2 查找表"></a>2.2 查找表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW TABLES; # 查看表</span><br><span class="line"></span><br><span class="line">SHOW CREATE TABLE mytable； # 查看表的建表语句</span><br><span class="line"></span><br><span class="line">DESC mytable;  # 查看表结构</span><br></pre></td></tr></table></figure><h4 id="2-3-修改表"><a href="#2-3-修改表" class="headerlink" title="2.3 修改表"></a>2.3 修改表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE mytable1 ADD image BLOB; # 新增列</span><br><span class="line"></span><br><span class="line">ALTER TABLE mytable1 MODIFY name VARCHAR(25); # 修改列的类型</span><br><span class="line"></span><br><span class="line">ALTER TABLE mytable1 DROP gender; # 删除某列</span><br><span class="line"></span><br><span class="line">ALTER TABLE mytable1 CHARACTER SET utf8; # 修改表的字符集</span><br><span class="line"></span><br><span class="line">ALTER TABLE mytable1 CHANGE name username VARCHAR(20); # 修改列名</span><br><span class="line"></span><br><span class="line">RENAME TABLE mytable1 TO mytable2; # 修改表名 mytable1 -&gt; mytable2</span><br></pre></td></tr></table></figure><h4 id="2-4-删除表"><a href="#2-4-删除表" class="headerlink" title="2.4 删除表"></a>2.4 删除表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE mytable1;</span><br></pre></td></tr></table></figure><h4 id="2-5-各种约束"><a href="#2-5-各种约束" class="headerlink" title="2.5 各种约束"></a>2.5 各种约束</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t1</span><br><span class="line">(</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT, # 主键约束,自动增长</span><br><span class="line">    name VARCHAR(20) UNIQUE,  # 唯一约束   </span><br><span class="line">    gender CHAR(1) NOT NULL,  # 非空约束</span><br><span class="line">    worktime DATE,</span><br><span class="line">    money DOUBLE DEFAULT 10000.0  # 默认值约束</span><br><span class="line">) CHARACTER SET utf8 COLLATE utf8_bin;</span><br><span class="line"></span><br><span class="line">FOREIGN KEY &#x2F;&#x2F; 外键约束</span><br></pre></td></tr></table></figure><h4 id="2-6-索引"><a href="#2-6-索引" class="headerlink" title="2.6 索引"></a>2.6 索引</h4><h5 id="2-6-1-创建索引"><a href="#2-6-1-创建索引" class="headerlink" title="2.6.1 创建索引"></a>2.6.1 创建索引</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">#&#x2F;&#x2F; 方式一 ： 建表时候创建索引</span><br><span class="line">#&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line"># 创建普通索引</span><br><span class="line">CREATE TABLE t1</span><br><span class="line">(</span><br><span class="line">    id INT, </span><br><span class="line">    INDEX bieming(id) </span><br><span class="line">)；</span><br><span class="line"></span><br><span class="line"># 创建唯一索引,升序</span><br><span class="line">CREATE TABLE t2</span><br><span class="line">(</span><br><span class="line">    id INT, </span><br><span class="line">    UNIQUE INDEX bieming(id, ASC) </span><br><span class="line">)；</span><br><span class="line"></span><br><span class="line"># 创建全文索引</span><br><span class="line">CREATE TABLE t3</span><br><span class="line">(</span><br><span class="line">    name VARCHAR(20), </span><br><span class="line">    FULLTEXT INDEX bieming(name) </span><br><span class="line">)ENGINE&#x3D;MyISAM; # 必须使用 myisam引擎</span><br><span class="line"></span><br><span class="line"># 创建多列索引</span><br><span class="line">CREATE TABLE t4</span><br><span class="line">(</span><br><span class="line">    id INT, </span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    INDEX bieming(id,name(20)) </span><br><span class="line">)；</span><br><span class="line"></span><br><span class="line"># 创建空间索引</span><br><span class="line">CREATE TABLE t5</span><br><span class="line">(</span><br><span class="line">    a1 GEOMETRY,</span><br><span class="line">    a2 POINT,</span><br><span class="line">    a3 LINESTRING,</span><br><span class="line">    a4 POLYGON</span><br><span class="line">    SPATIAL INDEX bieming(a1) </span><br><span class="line">)ENGINE&#x3D;MyISAM; # 必须使用 myisam引擎</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">#&#x2F;&#x2F; 方式二： 在已经存在的表上创建索引</span><br><span class="line">#&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE t1</span><br><span class="line">(</span><br><span class="line">    id INT, &#x2F;&#x2F; 主键约束,自动增长</span><br><span class="line">    name VARCHAR(20), &#x2F;&#x2F; 唯一约束   </span><br><span class="line">    gender CHAR(1),  &#x2F;&#x2F; 非空约束</span><br><span class="line">    worktime DATE,</span><br><span class="line">    money DOUBLE  &#x2F;&#x2F; 默认值约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE INDEX bieming on t1(id);          	# 创建普通索引</span><br><span class="line">CREATE UNIQUE INDEX bieming on t1(id, ASC); # 创建唯一索引</span><br><span class="line">CREATE FULLTEXT INDEX bieming on t1(id); 	# 创建全文索引</span><br><span class="line">CREATE INDEX bieming on t1(id, gender(1));  # 创建多列索引</span><br><span class="line">CREATE SPATIAL INDEX bieming on t1(id);  	# 创建空间索引</span><br></pre></td></tr></table></figure><h5 id="2-6-2-删除索引"><a href="#2-6-2-删除索引" class="headerlink" title="2.6.2 删除索引"></a>2.6.2 删除索引</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t1 DROP INDEX bieming;</span><br><span class="line"></span><br><span class="line">DROP INDEX beiming ON t1;</span><br></pre></td></tr></table></figure><h3 id="3-操作表记录"><a href="#3-操作表记录" class="headerlink" title="3 操作表记录"></a>3 操作表记录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc test2;</span><br><span class="line">#+--------+----------+------+-----+---------+-------+</span><br><span class="line">#| Field  | Type     | Null | Key | Default | Extra |</span><br><span class="line">#+--------+----------+------+-----+---------+-------+</span><br><span class="line">#| id     | int      | YES  |     | NULL    |       |</span><br><span class="line">#| name   | char(50) | YES  |     | NULL    |       |</span><br><span class="line">#| gender | char(1)  | YES  |     | NULL    |       |</span><br><span class="line">#| salary | double   | YES  |     | NULL    |       |</span><br><span class="line">#+--------+----------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure><h4 id="4-1-insert"><a href="#4-1-insert" class="headerlink" title="4.1 insert"></a>4.1 insert</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO test1(id, name, gender) VALUES(10, &#39;JACK&#39;, &#39;M&#39;); # 可以缺省</span><br><span class="line"></span><br><span class="line">INSERT INTO test1 VALUES(11, &#39;MAC&#39;, &#39;M&#39;, 123.245); # 省去field 必须满足列数相同</span><br><span class="line">												   # 且可以一次性添加多条</span><br><span class="line">INSERT INTO test1 VALUES(11, &#39;MAC&#39;, &#39;M&#39;, 123.245), (12, &#39;MAcC&#39;, &#39;M&#39;, 123.5245);</span><br></pre></td></tr></table></figure><h4 id="4-2-update"><a href="#4-2-update" class="headerlink" title="4.2 update"></a>4.2 update</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE test1 SET salary &#x3D; 5000; # 表内所有人工资变成 5000</span><br><span class="line"></span><br><span class="line">UPDATE test1 SET salary &#x3D; 3000 WHERE name &#x3D; &#39;A&#39;; # 表内名为 A 的工资更新为 3000</span><br><span class="line"></span><br><span class="line">UPDATE test1 SET salary &#x3D; 4000, gender &#x3D; &#39;f&#39; WHERE &#x3D; &#39;B&#39;; # B 改为4000， 女</span><br><span class="line"></span><br><span class="line">UPDATE test1 SET salary &#x3D; salary + 1000 WHERE name &#x3D; &#39;C&#39;; # 支持表达式运算</span><br></pre></td></tr></table></figure><h4 id="4-3-delete，truncate"><a href="#4-3-delete，truncate" class="headerlink" title="4.3 delete，truncate"></a>4.3 delete，truncate</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM test1 WHERE name &#x3D; &#39;C&#39;; # 删除 C 的数据</span><br><span class="line"></span><br><span class="line">DELETE FROM test1;  # 删除表中所有数据</span><br><span class="line"></span><br><span class="line">TRUNCATE test1;     # 删除表中所有数据 -&gt; 摧毁表并创建新的表格</span><br></pre></td></tr></table></figure><h3 id="4-单表查询"><a href="#4-单表查询" class="headerlink" title="4 单表查询"></a>4 单表查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#+----+-------+--------+--------+-----------+</span><br><span class="line">#| id | name  | gender | salary | allowance |</span><br><span class="line">#+----+-------+--------+--------+-----------+</span><br><span class="line">#|  1 | Alice | M      |   5000 |       500 |</span><br><span class="line">#|  2 | Bob   | M      |   4500 |       400 |</span><br><span class="line">#|  3 | Cc    | F      |   6000 |       600 |</span><br><span class="line">#+----+-------+--------+--------+-----------+</span><br></pre></td></tr></table></figure><h4 id="4-1-简单查询"><a href="#4-1-简单查询" class="headerlink" title="4.1 简单查询"></a><strong>4.1 简单查询</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test2;  # 查询所有内容</span><br><span class="line"></span><br><span class="line">SELECT id, name FROM test2;  # 查询 id 和 name , 注意 逗号</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT gender FROM test2;  # 过滤表中重复的数据</span><br><span class="line"></span><br><span class="line">SELECT name, salary + 1200 FROM test2;  # 查询税前薪水（+1200） 数据库底层数据没有改变</span><br><span class="line"></span><br><span class="line">SELECT name, salary + allowance FROM test2;  # 统计薪水 + 津贴</span><br><span class="line"></span><br><span class="line">SELECT name AS 姓名, salary + allowance AS 总工资 FROM test2;  # 使用别名</span><br><span class="line">SELECT name 序号, salary + allowance 总工资 FROM test2; 		  # as 用空格代替</span><br></pre></td></tr></table></figure><h4 id="4-2-带有过滤的查询"><a href="#4-2-带有过滤的查询" class="headerlink" title="4.2 带有过滤的查询"></a><strong>4.2 带有过滤的查询</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test2 WHERE name &#x3D; &#39;A&#39;;  # 查询 A 的所有数据</span><br><span class="line"></span><br><span class="line">SELECT * FROM test2 WHERE salary &gt; 5000;  # 查询 薪水大于 5000 的用户</span><br><span class="line"></span><br><span class="line">SELECT * FROM test2 WHERE salary + allowance &gt; 4000;  # 查询薪水 + 津贴大于 4000 的用户 </span><br><span class="line"></span><br><span class="line">SELECT * FROM test2 WHERE salary BETWEEN 3500 AND 6500;  # 查询薪水在 3500- 6500 之间</span><br><span class="line"></span><br><span class="line">SELECT * FROM test2 WHERE salary IN (4000, 6000);  # 查询薪水在 4000 和 6000 </span><br><span class="line"></span><br><span class="line">SELECT * FROM test2 WHERE name like &#39;A%&#39;;   # 模糊查找名字有A （% -&gt; 0-n 个， _ -&gt;0-1个）</span><br><span class="line">SELECT * FROM test2 WHERE name like &#39;A____&#39;;  #&#x2F; _ 数量对应</span><br><span class="line"></span><br><span class="line">SELECT * FROM test2 WHERE salary &gt; 4000 and allowance &gt; 500;</span><br></pre></td></tr></table></figure><h4 id="4-3-聚合函数"><a href="#4-3-聚合函数" class="headerlink" title="4.3 聚合函数"></a><strong>4.3 聚合函数</strong></h4><ol><li>count 聚合函数，用来统计行数</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) FROM test2;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) FROM test2 WHERE salary + allowance &gt; 4000; # 查薪水津贴大于4000的用户数</span><br></pre></td></tr></table></figure><ol><li>sum 聚合函数，求符合条件的某列的和值</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(salary) FROM test1;  # 所有人的总薪水</span><br><span class="line"></span><br><span class="line">SELECT SUM(salary + allowance) FROM test1;  # 所有人的总收入（薪水+津贴）</span><br><span class="line"></span><br><span class="line">SELECT SUM(salary + allowance) &#x2F; COUNT(*) FROM test1;  # 收入的平均水平</span><br></pre></td></tr></table></figure><ol><li>avg 聚合函数，求符合条件的列的平均值</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT AVG(salary) FROM test1;  # 求薪水的平均值</span><br></pre></td></tr></table></figure><ol><li>max / min ，求符合条件的列的最大最小值</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(salary) FROM test1;  # 最大值</span><br><span class="line">SELECT MIN(salary) FROM test1;  # 最小值</span><br></pre></td></tr></table></figure><h4 id="4-4-排序查询"><a href="#4-4-排序查询" class="headerlink" title="4.4 排序查询"></a><strong>4.4 排序查询</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name, salary FROM test1 ORDER BY salary;  # 按照薪水大小排序 升序</span><br><span class="line">SELECT name, salary FROM test1 ORDER BY salary DESC; # 降序</span><br><span class="line"></span><br><span class="line">SELECT name 姓名, salary + allowance 总收入 FROM test1 ORDER BY 总收入 DESC;  # 按照总收入降序排序</span><br><span class="line"></span><br><span class="line">SELECT name 姓名, salary + allowance 总收入 FROM test1 WHERE id &lt; 3 ORDER BY 总收入 DESC;  # 按照id&lt;3 总收入降序排序（使用别名）</span><br></pre></td></tr></table></figure><h4 id="4-5-分组查询"><a href="#4-5-分组查询" class="headerlink" title="4.5 分组查询"></a><strong>4.5 分组查询</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE ORDERS(</span><br><span class="line">	id int,</span><br><span class="line">    product varchar(20),</span><br><span class="line">    price float</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *FROM orders GROUP BY product;  # 按照商品分组查找</span><br><span class="line"></span><br><span class="line">SELECT product, SUM(price) FROM orders GROUP BY product;  # 分组合并价格总数</span><br><span class="line"></span><br><span class="line"># 查询总价大于100的商品名称，含组合</span><br><span class="line"></span><br><span class="line"># WHERE 在分组之前过滤 不满足条件 且不允许使用聚合语句</span><br><span class="line">SELECT product, SUM(price) FROM orders WHERE price &gt; 100 GROUP BY product;  √ 一半</span><br><span class="line">SELECT product, SUM(price) FROM orders WHERE SUM(price) &gt; 100 GROUP BY product;  x</span><br><span class="line"></span><br><span class="line"># HAVING 分组之后</span><br><span class="line">SELECT product, SUM(price) FROM orders GROUP BY product HAVING SUM(price) &gt; 100;</span><br><span class="line"></span><br><span class="line"># 总价大于100，单价小于100</span><br><span class="line">SELECT product, SUM(price) FROM orders WHERE price &lt; 100 GROUP BY product HAVING sum(price) &gt; 100;</span><br></pre></td></tr></table></figure><h4 id="4-6-limit"><a href="#4-6-limit" class="headerlink" title="4.6 limit "></a><strong>4.6 limit</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM cast LIMIT 5;    # 从第1条开始取5条</span><br><span class="line">SELECT * FROM cast LIMIT 5, 5; # 从第6条开始取5条</span><br></pre></td></tr></table></figure><h4 id="4-7-别名"><a href="#4-7-别名" class="headerlink" title="4.7 别名"></a><strong>4.7 别名</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tableName AS otherName;  # 给表明取别名  AS 可以省略</span><br><span class="line"></span><br><span class="line">SELECT * FROM student AS s WHERE s.gender &#x3D; &#39;F&#39;;</span><br><span class="line"></span><br><span class="line">SELECT name AS 姓名 FROM tablename;  # 字段别名</span><br></pre></td></tr></table></figure><h3 id="5-多表查询"><a href="#5-多表查询" class="headerlink" title="5 多表查询"></a>5 多表查询</h3><h4 id="5-1-添加外键约束"><a href="#5-1-添加外键约束" class="headerlink" title="5.1 添加外键约束"></a><strong>5.1 添加外键约束</strong></h4><h5 id="5-1-1-声明表的时候添加外键"><a href="#5-1-1-声明表的时候添加外键" class="headerlink" title="5.1.1 声明表的时候添加外键"></a><strong>5.1.1 声明表的时候添加外键</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FOREIGN KEY(dept_id) REFERENCES dept(id) </span><br><span class="line"></span><br><span class="line">CREATE TABLE dept (</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(50)</span><br><span class="line">);</span><br><span class="line">INSERT INTO dept VALUES(NULL,&#39;财务部&#39;),(NULL,&#39;人事部&#39;),(NULL,&#39;行政部&#39;),(NULL,&#39;科技部&#39;);</span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    dept_id INT,</span><br><span class="line">    FOREIGN KEY(dept_id) REFERENCES dept(id)  # 创建表的时候添加外键约束</span><br><span class="line">);</span><br><span class="line">INSERT INTO emp VALUES(NULL,&#39;奥巴马&#39;,1),(NULL,&#39;拜登&#39;,3),(NULL,&#39;林肯&#39;,4),(NULL,&#39;特朗普&#39;,2);</span><br></pre></td></tr></table></figure><h5 id="5-5-2-表已经存在"><a href="#5-5-2-表已经存在" class="headerlink" title="5.5.2 表已经存在"></a><strong>5.5.2 表已经存在</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TALBE 表名 ADD CONSTRAINT fk_id FOREIGN KEY (外键字段名) REFERENCES 外表表名（主键字段名）</span><br><span class="line"></span><br><span class="line">ALTER TABLE emp ADD CONSTRAINT aaa_fk FOREIGN KEY (dept_id) REFERENCES dept(id);</span><br></pre></td></tr></table></figure><h5 id="5-5-3-删除外键"><a href="#5-5-3-删除外键" class="headerlink" title="5.5.3 删除外键"></a>5.5.3 删除外键</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE emp DROP FOREIGN KEY aaa_fk;  # 删除外键名</span><br></pre></td></tr></table></figure><h4 id="5-2-操作关联表"><a href="#5-2-操作关联表" class="headerlink" title="5.2 操作关联表"></a>5.2 操作关联表</h4><h5 id="5-2-1-添加数据"><a href="#5-2-1-添加数据" class="headerlink" title="5.2.1 添加数据"></a>5.2.1 添加数据</h5><h5 id="5-2-2-删除数据"><a href="#5-2-2-删除数据" class="headerlink" title="5.2.2 删除数据"></a>5.2.2 删除数据</h5><h4 id="5-3-连接查询"><a href="#5-3-连接查询" class="headerlink" title="5.3 连接查询"></a>5.3 连接查询</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#+----+--------+</span><br><span class="line">#| id | name   |</span><br><span class="line">#+----+--------+</span><br><span class="line">#|  1 | 财务部 |</span><br><span class="line">#|  2 | 人事部 |</span><br><span class="line">#|  3 | 行政部 |</span><br><span class="line">#|  4 | 科技部 |</span><br><span class="line">#|  5 | 商务部 |</span><br><span class="line">#+----+--------+</span><br><span class="line">#+----+--------+---------+</span><br><span class="line">#| id | name   | dept_id |</span><br><span class="line">#+----+--------+---------+</span><br><span class="line">#|  1 | 奥巴马 |       1 |</span><br><span class="line">#|  2 | 拜登   |       3 |</span><br><span class="line">#|  3 | 林肯   |       4 |</span><br><span class="line">#|  4 | 特朗普 |       4 |</span><br><span class="line">#|  5 | 克林顿 |       6 |</span><br><span class="line">#+----+--------+---------+</span><br><span class="line"></span><br><span class="line"># 笛卡尔积查询  -&gt; 两张表相乘的结果</span><br><span class="line">SELECT * FROM dept, emp;   </span><br><span class="line"></span><br><span class="line"># 内连接查询    -&gt; 查询两张表都有的记录</span><br><span class="line">SELECT * FROM dept, emp WHERE dept.id &#x3D; emp.dept_id;</span><br><span class="line">SELECT * FROM dept INNER JOIN emp ON dept.id &#x3D; emp.dept_id;</span><br><span class="line"></span><br><span class="line"># 左外连接查询  -&gt; 在内连接的基础上增加左有右无的记录</span><br><span class="line">SELECT * FROM dept LEFT JOIN emp ON dept.id &#x3D; emp.dept_id;</span><br><span class="line"></span><br><span class="line"># 左外连接查询  -&gt; 在内连接的基础上增加右有左无的记录</span><br><span class="line">SELECT * FROM dept RIGHT JOIN emp ON dept.id &#x3D; emp.dept_id;</span><br><span class="line"></span><br><span class="line"># 全外连接查询   mysql #不支持#</span><br><span class="line">SELECT * FROM dept FULL JOIN emp ON dept.id &#x3D; emp.dept_id;</span><br><span class="line"></span><br><span class="line"># 全外连接查询  mysql 方式 利用 union 操作</span><br><span class="line">SELECT * FROM dept LEFT JOIN emp ON dept.id &#x3D; emp.dept_id</span><br><span class="line">union</span><br><span class="line">SELECT * FROM dept RIGHT JOIN emp ON dept.id &#x3D; emp.dept_id;</span><br><span class="line"></span><br><span class="line"># 查询 dept_id &#x3D; 4 的部门名称和其中的员工的姓名（包含id）</span><br><span class="line">SELECT * FROM dept INNER JOIN emp ON dept.id &#x3D; emp.dept_id WHERE dept.id &#x3D; 4;</span><br><span class="line"></span><br><span class="line"># 查询 dept_id &#x3D; 4 的部门名称和其中的员工的姓名（不包含id）</span><br><span class="line">SELECT dept.name AS 部门, emp.name AS 姓名 FROM dept INNER JOIN emp ON dept.id &#x3D; emp.dept_id WHERE dept.id &#x3D; 4;</span><br></pre></td></tr></table></figure><h4 id="5-4-子查询"><a href="#5-4-子查询" class="headerlink" title="5.4 子查询"></a>5.4 子查询</h4><h5 id="5-4-1-带-in-关键字的子查询"><a href="#5-4-1-带-in-关键字的子查询" class="headerlink" title="5.4.1 带 in 关键字的子查询"></a>5.4.1 带 in 关键字的子查询</h5><p><em>使用 in 关键字进行子查询时，内层查询语句仅仅返回一个数据列，这个数据列中的值将供外层查询语句进行比较操作。</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 建立表格</span><br><span class="line">CREATE TABLE department (</span><br><span class="line">	did INT,</span><br><span class="line">    dname VARCHAR(50)</span><br><span class="line">);</span><br><span class="line">INSERT INTO department VALUES(1,&#39;网络部&#39;),(2,&#39;媒体部&#39;),(3,&#39;研发部&#39;),(5,&#39;人事部&#39;);</span><br><span class="line"></span><br><span class="line">#+------+--------+</span><br><span class="line">#| did  | dname  |</span><br><span class="line">#+------+--------+</span><br><span class="line">#|    1 | 网络部 |</span><br><span class="line">#|    2 | 媒体部 |</span><br><span class="line">#|    3 | 研发部 |</span><br><span class="line">#|    5 | 人事部 |</span><br><span class="line">#+------+--------+</span><br><span class="line"></span><br><span class="line">CREATE TABLE employee (</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age INT,</span><br><span class="line">    did INT</span><br><span class="line">);</span><br><span class="line">INSERT INTO employee VALUES(NULL, &#39;张三&#39;, 20, 1),(NULL, &#39;李四&#39;, 22, 1),(NULL, &#39;王五&#39;, 20, 2),(NULL, &#39;刘六&#39;, 20, 4);</span><br><span class="line"></span><br><span class="line">#+----+------+------+------+</span><br><span class="line">#| id | name | age  | did  |</span><br><span class="line">#+----+------+------+------+</span><br><span class="line">#|  1 | 张三 |   20 |    1 |</span><br><span class="line">#|  2 | 李四 |   22 |    1 |</span><br><span class="line">#|  3 | 王五 |   20 |    2 |</span><br><span class="line">#|  4 | 刘六 |   20 |    4 |</span><br><span class="line">#+----+------+------+------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查询存在年龄为20的员工的部门</span><br><span class="line"></span><br><span class="line"># 1. 查询年龄为20的员工信息</span><br><span class="line">SELECT did FROM employee WHERE age &#x3D; 20;</span><br><span class="line"># 2. 查询他们的部门,将 1 作为嵌套语句</span><br><span class="line">SELECT dname FROM department WHERE did IN (SELECT did FROM employee WHERE age &#x3D; 20);</span><br></pre></td></tr></table></figure><h5 id="5-4-2-带-not-in-关键字的子查询"><a href="#5-4-2-带-not-in-关键字的子查询" class="headerlink" title="5.4.2 带 not in 关键字的子查询"></a>5.4.2 带 not in 关键字的子查询</h5><p><em>与 in 关键词 相反</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询存在年龄不是20的员工的部门</span><br><span class="line"></span><br><span class="line"># 1. 查询年龄为20的员工信息</span><br><span class="line">SELECT did FROM employee WHERE age &#x3D; 20;</span><br><span class="line"># 2. 查询他们的部门,将 1 作为嵌套语句</span><br><span class="line">SELECT dname FROM department WHERE did NOT IN (SELECT did FROM employee WHERE age &#x3D; 20);</span><br></pre></td></tr></table></figure><h5 id="5-4-3-带-exists-关键字的子查询"><a href="#5-4-3-带-exists-关键字的子查询" class="headerlink" title="5.4.3 带 exists 关键字的子查询"></a>5.4.3 带 exists 关键字的子查询</h5><p><em>关键词后面的参数可以时任意一个子查询，这个子查询的作用相当于测试，他不产生任何数据，只返回 TRUE , FALSE。</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询employee中是否有年龄大于20的员工，如果存在，则查询department表中的所有记录</span><br><span class="line"></span><br><span class="line"># 1. 查询年龄大于20的员工</span><br><span class="line">SELECT * FROM employee WHERE age &gt; 20;</span><br><span class="line"># 2. 嵌套</span><br><span class="line">SELECT * FROM department WHERE EXISTS (SELECT * FROM employee WHERE age &gt; 20);</span><br></pre></td></tr></table></figure><h5 id="5-4-4-带-any-关键字的子查询"><a href="#5-4-4-带-any-关键字的子查询" class="headerlink" title="5.4.4 带 any 关键字的子查询"></a>5.4.4 带 any 关键字的子查询</h5><p><em>any 关键字表示满足其中任意一个条件，它允许创建一个表达式对子查询的返回值列表进行比较，只要满足内层子查询中的任意一个比较条件，就返回一个结果作为查询条件。</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询 department.did &gt; employee.did 的部门名称</span><br><span class="line"># 1. 查询 employee 所有 did</span><br><span class="line">SELECT did FROM employee;</span><br><span class="line"># 2. 嵌套比较</span><br><span class="line">SELECT * FROM department WHERE did &gt; ANY(SELECT did FROM employee);</span><br></pre></td></tr></table></figure><h5 id="5-4-5-带-all-关键字的子查询"><a href="#5-4-5-带-all-关键字的子查询" class="headerlink" title="5.4.5 带 all 关键字的子查询"></a>5.4.5 带 all 关键字的子查询</h5><p><em>相较于 any 需要满足所有条件</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询 department.did &gt; 所有 employee.did 的部门名称</span><br><span class="line"># 1. 查询 employee 所有 did</span><br><span class="line">SELECT did FROM employee;</span><br><span class="line"># 2. 嵌套比较</span><br><span class="line">SELECT * FROM department WHERE did &gt; ALL(SELECT did FROM employee);</span><br></pre></td></tr></table></figure><h5 id="5-4-6-带比较运算符的子查询"><a href="#5-4-6-带比较运算符的子查询" class="headerlink" title="5.4.6 带比较运算符的子查询"></a>5.4.6 带比较运算符的子查询</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询 王五 是哪个部门</span><br><span class="line"># 1. 查询王五的did</span><br><span class="line">SELECT did FROM employee WHERE name &#x3D; &#39;王五&#39;;</span><br><span class="line"># 2. 嵌套比较</span><br><span class="line">SELECT dname FROM department WHERE did &#x3D; (SELECT did FROM employee WHERE name &#x3D; &#39;王五&#39;);</span><br></pre></td></tr></table></figure><h3 id="6-事务"><a href="#6-事务" class="headerlink" title="6 事务"></a>6 事务</h3><h4 id="6-1-事务控制"><a href="#6-1-事务控制" class="headerlink" title="6.1 事务控制"></a>6.1 事务控制</h4><h5 id="6-1-1-基本概念"><a href="#6-1-1-基本概念" class="headerlink" title="6.1.1 基本概念"></a>6.1.1 基本概念</h5><p>事务：逻辑上的一组操作，要么同时完成要么同时不完成</p><p>mysql 默认就自带事务，但是mysql自带的事务是一条语句独占一个事务</p><p>我们也可以自己来通知事务：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;  #开启事务</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">COMMIT;   # 提交事务</span><br><span class="line">ROLLBACK; # 回滚事务，也就是取消上述 (放在事务内部...后面)</span><br><span class="line"></span><br><span class="line">CREATE TABLE account (</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    money DOUBLE</span><br><span class="line">);</span><br><span class="line">INSERT INTO account VALUES(NULL,&#39;A&#39;,1000),(NULL,&#39;B&#39;,1200);</span><br><span class="line"></span><br><span class="line">## 转账 ##</span><br><span class="line"># 方式一</span><br><span class="line">UPDATE account SET money &#x3D; money - 100 WHERE name &#x3D; &#39;A&#39;;</span><br><span class="line"># 如果不在事务里面，第一条运行，第二条失败会导致转账出现问题</span><br><span class="line">UPDATE account SET money &#x3D; money + 100 WHERE name &#x3D; &#39;B&#39;; </span><br><span class="line"></span><br><span class="line"># 方式二</span><br><span class="line"></span><br><span class="line">START TRANSACTION;  #开启事务</span><br><span class="line">UPDATE account SET money &#x3D; money - 100 WHERE name &#x3D; &#39;A&#39;;</span><br><span class="line">UPDATE account SET money &#x3D; money + 100 WHERE name &#x3D; &#39;B&#39;; </span><br><span class="line">COMMIT;   # 提交事务</span><br></pre></td></tr></table></figure><h5 id="6-1-2-事务的特性-ACID"><a href="#6-1-2-事务的特性-ACID" class="headerlink" title="6.1.2 事务的特性 ACID"></a>6.1.2 事务的特性 ACID</h5><p><strong>原子性：</strong>(Atomicity)</p><ul><li>事务是一组不可分割的单位，要么同时成功，要么同时失败。</li></ul><p><strong>一致性：</strong>(Consistency)</p><ul><li>事务前后的数据完整性应该保持一致。（数据库的完整性：如果事务在某个时间点下，所有的数据都符合所有的约束，则称数据库为符合完整性的状态） 也就是说数据库中的数据并不会因为执行了一半而导致不同。</li></ul><p><strong>隔离性：</strong>(Isolation)</p><ul><li>多个用户并发访问数据库时，一个用户的事务不能被其他用户的事物所干扰，多个并发事务之间数据要相互隔离。</li></ul><p><strong>持久性：</strong>(Durability)</p><ul><li>一个事务一旦被提交，他对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。（也就是 commit 后 不能 rollback）</li></ul><h5 id="6-1-3-事务的隔离级别"><a href="#6-1-3-事务的隔离级别" class="headerlink" title="6.1.3 事务的隔离级别"></a>6.1.3 事务的隔离级别</h5><p>隔离性：本质就是多个线程操作同一个资源早成的多线程并发安全问题。加锁可以完美保证隔离性，但是影响性能。</p><p><strong>两个事务并发的修改</strong>：<em>必须隔离</em></p><p><strong>两个事务并发的查询</strong>：<em>完全不用隔离</em></p><p><strong>一个事务修改，一个事务查询</strong>：？</p><p>（脏读：一个事务读取到另一个事务<strong>未提交</strong>的数据）</p><p>（不可重复读：一个事务多次读取<strong>同一条记录</strong>，读取的结果不相同）</p><p>（虚读，幻读：一个事务多次查询<strong>整表的数据</strong>，由于其他事务新增（删除）记录造成多次查询出的记录条数不同）</p><p>四大隔离级别：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">READ UNCOMMITTED;   # 不做任何隔离问题</span><br><span class="line"></span><br><span class="line">READ COMMITTED;		# 可以防止脏读</span><br><span class="line"></span><br><span class="line">REPEATABLE READ;    # 可以防止 脏读 不可重复读   mysql 默认</span><br><span class="line"></span><br><span class="line">SERIALIZABLE;       # 数据库运行在串行化为实现 解决所有问题，单性能低</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SET [SESSION &#x2F; GLOBAL] TRANSACTION ISOLATION LEVEL ...; # 修改隔离级别</span><br><span class="line">SELECT @@TRANSACTION_ISOLATION;  # 查询当前数据库的隔离级别</span><br></pre></td></tr></table></figure><h4 id="6-2-存储过程的创建"><a href="#6-2-存储过程的创建" class="headerlink" title="6.2 存储过程的创建"></a>6.2 存储过程的创建</h4><p>存储过程类似于一个函数。</p><p>创建存储过程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建表</span><br><span class="line">CREATE DATABASE chapter06；</span><br><span class="line">USE chapter06;</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">	id INT(3) PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(20) NOT NULL,</span><br><span class="line">    grade FLOAT,</span><br><span class="line">    gender CHAR(2)</span><br><span class="line">);</span><br><span class="line">INSERT INTO student(name, grade, gender) VALUES(&#39;tom&#39;, 60, &#39;男&#39;),(&#39;jack&#39;, 70, &#39;男&#39;),(&#39;rose&#39;, 90, &#39;女&#39;),(&#39;lucy&#39;, 100, &#39;女&#39;);</span><br><span class="line"></span><br><span class="line">#+----+------+-------+--------+</span><br><span class="line">#| id | name | grade | gender |</span><br><span class="line">#+----+------+-------+--------+</span><br><span class="line">#|  1 | tom  |    60 | 男     |</span><br><span class="line">#|  2 | jack |    70 | 男     |</span><br><span class="line">#|  3 | rose |    90 | 女     |</span><br><span class="line">#|  4 | lucy |   100 | 女     |</span><br><span class="line">#+----+------+-------+--------+</span><br><span class="line"></span><br><span class="line"># 创建查看student表的存储过程</span><br><span class="line"></span><br><span class="line"># 将 mysql 结束语句改为 &#x2F;&#x2F;</span><br><span class="line">DELIMITER &#x2F;&#x2F; </span><br><span class="line">CREATE PROCEDURE Proc()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT * FROM student;</span><br><span class="line">END &#x2F;&#x2F;</span><br><span class="line"># 存储过程结束之后将分号改回来</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">CALL Proc; # 使用</span><br><span class="line"></span><br><span class="line">DROP PROCEDURE Proc; # 删除</span><br></pre></td></tr></table></figure><h4 id="6-3-存储过程的使用"><a href="#6-3-存储过程的使用" class="headerlink" title="6.3 存储过程的使用"></a>6.3 存储过程的使用</h4><h5 id="6-3-1-定义一个变量"><a href="#6-3-1-定义一个变量" class="headerlink" title="6.3.1 定义一个变量"></a>6.3.1 定义一个变量</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 注意 变量的声明一定要在存储过程中，且作用域为存储过程</span><br><span class="line">DECLARE var_name[, varname]...date_type[DEFAULT value];</span><br><span class="line"></span><br><span class="line"># 定义一个名称为 myvariable 的变量，类型为 INT 类型，默认值为 100</span><br><span class="line">DECLARE my_name INT DEFAULT 100;  # 没有在存储过程中</span><br><span class="line"></span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE proc2() </span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE myvariable INT DEFAULT 100;</span><br><span class="line">	SELECT myvariable;</span><br><span class="line">END &#x2F;&#x2F;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h5 id="6-3-2-修改一个变量的值"><a href="#6-3-2-修改一个变量的值" class="headerlink" title="6.3.2 修改一个变量的值"></a>6.3.2 修改一个变量的值</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方式一：</span><br><span class="line">SET var_name &#x3D; expr[, var_name &#x3D; expr]...;</span><br><span class="line"></span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE proc2() </span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE myvariable INT DEFAULT 100;</span><br><span class="line">	SET myvariable &#x3D; myvariavle + 20;</span><br><span class="line">	SELECT myvariable;</span><br><span class="line">END &#x2F;&#x2F;</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 方式二：</span><br><span class="line">SELECT col_name[...] INTO var_name[...] table_expr;</span><br><span class="line"></span><br><span class="line"># 定义变量，保存学生表中查询到的班级信息和性别信息</span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE proc2() </span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE s_grade FLOAT;</span><br><span class="line">	DECLARE s_gender CHAR(2);</span><br><span class="line">	SELECT grade, gender INTO s_grade, s_gender FROM student WHERE id &#x3D; 3;</span><br><span class="line">	SELECT s_grade, s_gender;</span><br><span class="line">END &#x2F;&#x2F;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h5 id="6-3-3-定义条件和处理程序"><a href="#6-3-3-定义条件和处理程序" class="headerlink" title="6.3.3 定义条件和处理程序"></a>6.3.3 定义条件和处理程序</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义一个 ERROR1148(42000)错误，名称为 command_not_allowed</span><br><span class="line"></span><br><span class="line">DECLARE command_not_allowed CONDITION FOR SQLSTATE 42000;</span><br><span class="line"></span><br><span class="line">DECLARE command_not_allowed CONDITION FOR 1148;</span><br><span class="line"></span><br><span class="line"># 定义处理程序</span><br><span class="line">DECLARE handler_type HANDLER FRO condition_value[,...] sp_statement</span><br><span class="line"># handler_type:</span><br><span class="line">CONTINUE, EXIT, UNDO</span><br><span class="line">#condition_value:</span><br><span class="line">	SQLSTATE[VALUE]</span><br><span class="line">	condition_name</span><br><span class="line">	SQLWARNING   #匹配所有01开头的SQLSTATE错误代码</span><br><span class="line">	NOT FOUND    #匹配所有02开头的SQLSTATE错误代码</span><br><span class="line">	SQLEXCEPTION #其他</span><br><span class="line">	mysql_error_code</span><br></pre></td></tr></table></figure><h5 id="6-3-4-光标（游标）的使用"><a href="#6-3-4-光标（游标）的使用" class="headerlink" title="6.3.4 光标（游标）的使用"></a>6.3.4 光标（游标）的使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 光标的声明 ##</span><br><span class="line">DECLARE cursor_name CURSOR FOR select_statement</span><br><span class="line"># 声明一个名为 cursor_student 的光标</span><br><span class="line">DECLARE cursor_student CURSOR FOR SELECT a_name, a_gender FROM student;</span><br><span class="line"></span><br><span class="line">## 光标的使用 ##</span><br><span class="line"># 先打开光标</span><br><span class="line">	 OPEN cursor_name;</span><br><span class="line">	 FETCH cursor_name INTO var_name[...]... # 这里的变量要在游标之前定义好。</span><br><span class="line"></span><br><span class="line"># 使用名称为 cursor_student 的光标。将查询出来的信息存入 s_name, s_grade中</span><br><span class="line">FETCH cursor_student INTO s_name, s_grade;</span><br><span class="line"></span><br><span class="line">## 光标的关闭 ##</span><br><span class="line">CLOSE cursor_name;</span><br><span class="line"># 关闭名称为 cursor_student 的光标。</span><br><span class="line">CLOSE cursor_student;</span><br></pre></td></tr></table></figure><h5 id="6-3-5-流程控制的使用"><a href="#6-3-5-流程控制的使用" class="headerlink" title="6.3.5 流程控制的使用"></a>6.3.5 流程控制的使用</h5><h6 id="6-3-5-1-if-语句"><a href="#6-3-5-1-if-语句" class="headerlink" title="6.3.5.1 if 语句"></a>6.3.5.1 if 语句</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. if 语句</span><br><span class="line">IF expr_condition THEN statemen_list</span><br><span class="line">	[ELSEIF expr_condition THEN statement_list]..</span><br><span class="line">	[ELSE statement_list]</span><br><span class="line">END IF</span><br><span class="line"></span><br><span class="line"># 创建一个存储过程判断变量 v 是否是一个 null,输出对应的提示信息</span><br><span class="line"></span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE proc4()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE v VARCHAR(2);</span><br><span class="line">	SET v &#x3D; &#39;a&#39;;</span><br><span class="line">	IF V IS NULL THEN SELECT &#39;IS NULL&#39;;</span><br><span class="line">	ELSE SELECT &#39;NOT NULL&#39;;</span><br><span class="line">	END IF;</span><br><span class="line">END &#x2F;&#x2F;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h6 id="6-3-5-2-case-语句"><a href="#6-3-5-2-case-语句" class="headerlink" title="6.3.5.2 case 语句"></a>6.3.5.2 case 语句</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 2. case 语句</span><br><span class="line">CASE case_expr</span><br><span class="line">	WHEN when_value THEN statement_list</span><br><span class="line">	[WHEN when_value THEN statemen_list]...</span><br><span class="line">	[ELSE statement_list]</span><br><span class="line">END CASE;</span><br><span class="line"></span><br><span class="line"># 创建存储过程</span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE proc5()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE v INT;</span><br><span class="line">	SET v &#x3D; 1;</span><br><span class="line">	CASE v</span><br><span class="line">		WHEN 1 THEN SELECT &#39;VALUE IS 1&#39;;</span><br><span class="line">		WHEN 2 THEN SELECT &#39;VALUE IS 1&#39;;</span><br><span class="line">		ELSE SELECT &#39;IS NOT 1 OR 2&#39;;</span><br><span class="line">	END CASE;</span><br><span class="line">END &#x2F;&#x2F;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h6 id="6-3-5-3-loop-语句"><a href="#6-3-5-3-loop-语句" class="headerlink" title="6.3.5.3 loop 语句"></a>6.3.5.3 loop 语句</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 3. loop 语句</span><br><span class="line">[loop_lable:] LOOP STATEMENT_LIST END [loop_lable]</span><br><span class="line"></span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE proc6()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE id INT DEFAULT 0;</span><br><span class="line">	add_loop : LOOP</span><br><span class="line">		SET id &#x3D; id + 1;</span><br><span class="line">		IF id &gt;&#x3D; 10 THEN LEAVE add_loop; &#x2F;&#x2F; 跳出循环</span><br><span class="line">		END IF;</span><br><span class="line">		SELECT id;</span><br><span class="line">	END LOOP add_loop;</span><br><span class="line">END &#x2F;&#x2F;</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">LEAVE # 跳出循环  break</span><br><span class="line">ITERATE # 再次循环 contionue</span><br><span class="line"></span><br><span class="line"># 案例</span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE doiterate()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE p1 INT DEFAULT 0;</span><br><span class="line">	my_loop : LOOP</span><br><span class="line">		SET p1 &#x3D; p1 + 1;</span><br><span class="line">		IF p1 &lt; 10 THEN ITERATE my_loop;</span><br><span class="line">		ELSE IF p1 &gt; 20 THEN LEAVE my_loop;</span><br><span class="line">		END IF;</span><br><span class="line">		SELECT &#39;p1 is between 10 and 20&#39;;</span><br><span class="line">	END LOOP my_loop;</span><br><span class="line">END &#x2F;&#x2F;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h6 id="6-3-5-4-repeat-语句-while-语句"><a href="#6-3-5-4-repeat-语句-while-语句" class="headerlink" title="6.3.5.4 repeat 语句 while 语句"></a>6.3.5.4 repeat 语句 while 语句</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 案例 repeat</span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE proc7()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE p1 INT DEFAULT 0;</span><br><span class="line">	REPEAT</span><br><span class="line">		SET p1 &#x3D; p1 + 1;</span><br><span class="line">		UNTIL p1 &gt;&#x3D; 10;</span><br><span class="line">	END REPEAT;</span><br><span class="line">END &#x2F;&#x2F;</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 案例 while</span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE proc8()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE p1 INT DEFAULT 0;</span><br><span class="line">	WHILE P1 &lt; 10 DO</span><br><span class="line">		SET p1 &#x3D; p1 + 1;</span><br><span class="line">		SELECT p1;</span><br><span class="line">	END WHILE;</span><br><span class="line">END &#x2F;&#x2F;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h4 id="6-4-操作存储过程"><a href="#6-4-操作存储过程" class="headerlink" title="6.4 操作存储过程"></a>6.4 操作存储过程</h4><h5 id="6-4-1-执行存储过程"><a href="#6-4-1-执行存储过程" class="headerlink" title="6.4.1 执行存储过程"></a>6.4.1 执行存储过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL SP_NAME(parameter...);</span><br><span class="line"></span><br><span class="line"># 案例</span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br><span class="line">CREATE PROCEDURE proc01(IN s_gender VARCHAR(50), OUT num INT)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT COUNT(*) INTO num FROM student WHERE gender &#x3D; s_gender;</span><br><span class="line">END &#x2F;&#x2F;</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 执行存储过程</span><br><span class="line">CALL proc01(&quot;f&quot;,@num);</span><br><span class="line"># 查看 num</span><br><span class="line">SELECT @num</span><br></pre></td></tr></table></figure><h5 id="6-4-2-查看存储过程"><a href="#6-4-2-查看存储过程" class="headerlink" title="6.4.2 查看存储过程"></a>6.4.2 查看存储过程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW PROCEDURE STATUS;</span><br><span class="line">SHOW PROCEDURE STATUS LIKE &#39;%2&#39;;</span><br><span class="line">SHOW CREATE PROCEDURE PROC4;</span><br><span class="line"># 查询 information_schema.routines 表中查看存储过程的信息</span><br><span class="line">SELECT * FROM information_schema.Routines；</span><br></pre></td></tr></table></figure><h4 id="6-5-修改存储过程"><a href="#6-5-修改存储过程" class="headerlink" title="6.5 修改存储过程"></a>6.5 修改存储过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 可以修改存储过程的特性，但是不能修改存储过程的内容</span><br><span class="line"># 如果要修改内容，先删除在重新创建</span><br></pre></td></tr></table></figure><h4 id="6-6-删除存储过程"><a href="#6-6-删除存储过程" class="headerlink" title="6.6 删除存储过程"></a>6.6 删除存储过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE sp_name;</span><br></pre></td></tr></table></figure><h3 id="7-视图"><a href="#7-视图" class="headerlink" title="7 视图"></a>7 视图</h3><h4 id="7-1-创建视图"><a href="#7-1-创建视图" class="headerlink" title="7.1 创建视图"></a>7.1 创建视图</h4><h5 id="7-1-1-在单表上创建视图"><a href="#7-1-1-在单表上创建视图" class="headerlink" title="7.1.1 在单表上创建视图"></a>7.1.1 在单表上创建视图</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建单表 in chapter07 数据库</span><br><span class="line"></span><br><span class="line">CREATE TABLE student(</span><br><span class="line">	s_id INT(3),</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    math FLOAT,</span><br><span class="line">    chinese FLOAT</span><br><span class="line">);</span><br><span class="line">INSERT INTO student VALUES(1, &#39;TOM&#39;, 80, 78),(2, &#39;JACK&#39;, 70, 80),(3, &#39;LUCY&#39;, 97, 95);</span><br><span class="line">#+------+------+------+---------+</span><br><span class="line">#| s_id | name | math | chinese |</span><br><span class="line">#+------+------+------+---------+</span><br><span class="line">#|    1 | TOM  |   80 |      78 |</span><br><span class="line">#|    2 | JACK |   70 |      80 |</span><br><span class="line">#|    3 | LUCY |   97 |      95 |</span><br><span class="line">#+------+------+------+---------+</span><br><span class="line"></span><br><span class="line"># 创建 student 表的视图，保存数学成绩，语文成绩，总成绩</span><br><span class="line">CREATE VIEW view_stu AS SELECT math, chinese FROM student;</span><br><span class="line"># 可替代</span><br><span class="line">CREATE (OR REPLEASE) VIEW view_stu AS SELECT math, chinese, math + chinese FROM student;</span><br><span class="line">SELECT * FORM view_stu;</span><br><span class="line"></span><br><span class="line"># 添加别名 (可选列名)</span><br><span class="line">CREATE VIEW view_stu2 (数学,语文,总分) AS SELECT math, chinese, math + chinese FROM student;</span><br><span class="line">SELECT * FroM view_stu2;</span><br></pre></td></tr></table></figure><p><strong>7.1.2 在多表上创建视图</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在创建一张表格</span><br><span class="line">CREATE TABLE stu_info(</span><br><span class="line">	s_id INT(3),</span><br><span class="line">    class VARCHAR(50),</span><br><span class="line">	addr VARCHAR(50)</span><br><span class="line">);</span><br><span class="line">INSERT INTO stu_info VALUES(1, &#39;#2&#39;, &#39;202&#39;),(2, &#39;#3&#39;, &#39;203&#39;),(3, &#39;#1&#39;, &#39;201&#39;);</span><br><span class="line"></span><br><span class="line">#+------+-------+------+</span><br><span class="line">#| s_id | class | addr |</span><br><span class="line">#+------+-------+------+</span><br><span class="line">#|    1 | #2    | 202  |</span><br><span class="line">#|    2 | #3    | 203  |</span><br><span class="line">#|    3 | #1    | 201  |</span><br><span class="line">#+------+-------+------+</span><br><span class="line"></span><br><span class="line"># 创建视图包含 学生的编号 学生的姓名 班级名称</span><br><span class="line"></span><br><span class="line">CREATE VIEW stu_class (编号, 学生, 班级) </span><br><span class="line">AS </span><br><span class="line">SELECT student.s_id,student.name,stu_info.class FROM student,stu_info WHERE student.s_id &#x3D; stu_info.s_id;</span><br></pre></td></tr></table></figure><h4 id="7-2-查看视图"><a href="#7-2-查看视图" class="headerlink" title="7.2 查看视图"></a>7.2 查看视图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用 describe   --- 查看视图结构</span><br><span class="line">DESCRIBE stu_class;</span><br><span class="line">DESC stu_class;</span><br><span class="line"></span><br><span class="line"># 使用 SHOW TABLE STATUS LIKE &#39;视图名&#39;  --- 查看视图信息</span><br><span class="line">SHOW TABLE STATUS LIKE &#39;stu_class&#39;;</span><br><span class="line"></span><br><span class="line"># 查看视图的创建语句    --- 查看视图的创建语句</span><br><span class="line">SHOW CREATE VIEW stu_class;</span><br></pre></td></tr></table></figure><h4 id="7-3-修改视图"><a href="#7-3-修改视图" class="headerlink" title="7.3 修改视图"></a>7.3 修改视图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. OR REPLACE 覆盖</span><br><span class="line"># 修改 view_stu</span><br><span class="line">CREATE OR REPLACE VIEW view_stu AS SELECT * FROM student;</span><br><span class="line"></span><br><span class="line"># 2. 使用alter语句</span><br><span class="line">ALTER VIEW view_stu AS SELECT Chinese FROM student;</span><br></pre></td></tr></table></figure><h4 id="7-4-更新视图"><a href="#7-4-更新视图" class="headerlink" title="7.4 更新视图"></a>7.4 更新视图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 更新视图会导致基本表中的数据也会修改</span><br><span class="line"># 使用 update</span><br><span class="line">UPDATE view_stu SET chinese &#x3D; 100;</span><br><span class="line"></span><br><span class="line"># 变化基本表中的数据同样也会改变视图中的数据</span><br><span class="line"># 使用 insert 语句</span><br><span class="line">INSERT INTO student VALUES(4, &#39;LILY&#39;, 98, 99);</span><br><span class="line"></span><br><span class="line"># 使用 delete</span><br><span class="line">DELETE FROM view_stu WHERE chinese &#x3D;  99;</span><br></pre></td></tr></table></figure><h4 id="7-5-删除视图"><a href="#7-5-删除视图" class="headerlink" title="7.5 删除视图"></a>7.5 删除视图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP VIEW view_name;</span><br></pre></td></tr></table></figure><h3 id="8-数据库的高级操作"><a href="#8-数据库的高级操作" class="headerlink" title="8 数据库的高级操作"></a>8 数据库的高级操作</h3><h4 id="8-1-数据备份与还原"><a href="#8-1-数据备份与还原" class="headerlink" title="8.1 数据备份与还原"></a>8.1 数据备份与还原</h4><h5 id="8-1-1-数据的备份"><a href="#8-1-1-数据的备份" class="headerlink" title="8.1.1 数据的备份"></a>8.1.1 数据的备份</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 命令行内</span><br><span class="line">mysqldump -u root -p mydb1 &gt; d:\1.sql</span><br></pre></td></tr></table></figure><h5 id="8-1-2-数据的还原"><a href="#8-1-2-数据的还原" class="headerlink" title="8.1.2 数据的还原"></a>8.1.2 数据的还原</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方法一   --- 命令行内</span><br><span class="line">mysql -u root -p mydb1 &lt; d:\1.sql  # 前提是先创建空数据库 mydb1</span><br><span class="line"></span><br><span class="line"># 方法二   --- mysql内</span><br><span class="line">CREATE DATABASE mydb1;</span><br><span class="line">USE mydb1;</span><br><span class="line">SOURCE D:\1.sql  # 载入数据</span><br></pre></td></tr></table></figure><h4 id="8-2-用户管理"><a href="#8-2-用户管理" class="headerlink" title="8.2 用户管理"></a>8.2 用户管理</h4><h5 id="8-2-1-user-表"><a href="#8-2-1-user-表" class="headerlink" title="8.2.1 user 表"></a>8.2.1 user 表</h5><h5 id="8-2-1-创建普通用户"><a href="#8-2-1-创建普通用户" class="headerlink" title="8.2.1 创建普通用户"></a>8.2.1 创建普通用户</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grant 语句</span><br><span class="line"># 对于 localhost 主机，创建用户 USER01，选择 mydb1内的所有所有数据，密码为123456</span><br><span class="line">GRANT SELECT ON mydb1.* TO &#39;USER01&#39;@localhost IDENTIFIED BY &#39;abc123&#39;;</span><br><span class="line"></span><br><span class="line"># create 语句</span><br><span class="line">CREATE USER &#39;USER02&#39;@localhost IDENTIFIED BY &#39;abc123&#39;;</span><br><span class="line"></span><br><span class="line"># insert 语句</span><br><span class="line">INSERT INTO mysql.user(Host, User, Password, ssl_cipher, x509issuer, x509_subject)</span><br><span class="line">VALUES(local, &#39;USER03&#39;, PASSWORD(&#39;abc123&#39;),&#39;&#39;,&#39;&#39;,&#39;&#39;);</span><br><span class="line">FLUSH PRIVILEGES;  # 刷新权限</span><br></pre></td></tr></table></figure><h5 id="8-2-1-删除普通用户"><a href="#8-2-1-删除普通用户" class="headerlink" title="8.2.1 删除普通用户"></a>8.2.1 删除普通用户</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># drop 语句</span><br><span class="line">DROP USER &#39;USER02&#39;@localhost;</span><br><span class="line"></span><br><span class="line"># delete 语句</span><br><span class="line">DELETE FROM mysql.user WHERE Host &#x3D; &#39;localhost&#39; AND User &#x3D; &#39;USER02&#39;;</span><br><span class="line">FLUSH PRIVILEGES;  # 刷新权限</span><br></pre></td></tr></table></figure><h5 id="8-2-1-修改用户密码"><a href="#8-2-1-修改用户密码" class="headerlink" title="8.2.1 修改用户密码"></a>8.2.1 修改用户密码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 修改root用户密码</span><br><span class="line"># 命令行</span><br><span class="line">mysqladmin -u root -p password rootroot;</span><br><span class="line"></span><br><span class="line"># update 语句</span><br><span class="line">UPDATE mysql.user SET PASSWORD &#x3D; PASSWORD(&#39;rootroot&#39;)</span><br><span class="line">WHERE User &#x3D; &#39;username&#39; AND Host &#x3D; &#39;hostname&#39;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"># SET 语句 必须 root 用户本身</span><br><span class="line">SET PASSWORD &#x3D; PASSWORD(&#39;rootroot&#39;);</span><br><span class="line"></span><br><span class="line"># 2. root 用户修改普通用户密码</span><br><span class="line"># grant 语句</span><br><span class="line"># update 语句</span><br><span class="line"># set 语句</span><br><span class="line"></span><br><span class="line">#3. 普通用户修改自己密码</span><br><span class="line"># set 语句</span><br><span class="line">SET PASSWORD &#x3D; PASSWORD(&#39;password&#39;);</span><br></pre></td></tr></table></figure><h4 id="8-3-权限管理"><a href="#8-3-权限管理" class="headerlink" title="8.3 权限管理"></a>8.3 权限管理</h4><h5 id="8-3-1-Mysql-的权限"><a href="#8-3-1-Mysql-的权限" class="headerlink" title="8.3.1 Mysql 的权限"></a>8.3.1 Mysql 的权限</h5><h5 id="8-3-2-授予权限"><a href="#8-3-2-授予权限" class="headerlink" title="8.3.2 授予权限"></a>8.3.2 授予权限</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 赋予 insert select 权限 给 user04 ，密码为 123</span><br><span class="line">GRANT INSERT,SELECT ON *.* TO &#39;USER04&#39;@localhost IDENTIFIED BY &#39;123&#39; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><h5 id="8-3-3-查看权限"><a href="#8-3-3-查看权限" class="headerlink" title="8.3.3 查看权限"></a>8.3.3 查看权限</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR &#39;root&#39;@localhost;</span><br></pre></td></tr></table></figure><h5 id="8-3-4-收回权限"><a href="#8-3-4-收回权限" class="headerlink" title="8.3.4 收回权限"></a>8.3.4 收回权限</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REVOKE insert on *.* FROM &#39;USER04&#39;@localhost; # 回收 user04 的 insert 权限</span><br><span class="line">REVOKE ALL PRIVILEGES, GRANT OPTION FROM &#39;USER04&#39;@localhost; # 回收 user04 的所有权限</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ vscode 编译环境</title>
    <url>/Complie_and_Debug/cpp_vscode/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="c-vscode-编译环境"><a href="#c-vscode-编译环境" class="headerlink" title="c++ vscode 编译环境"></a>c++ vscode 编译环境</h1><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0 说明"></a>0 说明</h2><p>以一个例子来说明 cpp 在 vscode （window）下编译，其中需要</p><blockquote><p>vscode — IDE</p><p>MinGW64 — g++，gdb …</p><p>CMake — cmake</p></blockquote><p>注：其中 MinGW64 以及 CMake 需要添加到环境变量path</p><p>vscode 需要 <strong><code>插件</code></strong> 如下：</p><blockquote><p>c/c++</p><p>CMake</p><p>CMake Tools</p></blockquote><p>以下以例子说明整个编译调试过程，文件夹 example，创建 main.cpp 函数，其主要作用是 swap 。先从单文件编译，到多文件编译，最后通过 cmake 来进行多文件的编译。</p><h2 id="1-单文件编译"><a href="#1-单文件编译" class="headerlink" title="1 单文件编译"></a>1 单文件编译</h2><p>打开 example 文件下，创建 main.cpp 函数：</p><p><img src="/Complie_and_Debug/cpp_vscode/example_folder.png" style="zoom:67%"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"before swap:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    swap(val1,val2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-利用终端命令行来生成可编译文件"><a href="#1-1-利用终端命令行来生成可编译文件" class="headerlink" title="1.1 利用终端命令行来生成可编译文件"></a>1.1 利用终端命令行来生成可编译文件</h3><p>命令行如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -g ./main.cpp -o out1</span><br></pre></td></tr></table></figure><ul><li>g++</li><li>-g ：可编译调试</li><li>./main.cpp ：待编译文件 （单）</li><li>-o out1：输出 out1.exe 可执行文件</li></ul><p><img src="/Complie_and_Debug/cpp_vscode/out1_exe.png" style="zoom:67%"></p><p>通过命令行来执行 out1.exe，结果如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./out1</span><br></pre></td></tr></table></figure><p><img src="/Complie_and_Debug/cpp_vscode/e_out1.png" style="zoom:80%"></p><h3 id="1-2-调试"><a href="#1-2-调试" class="headerlink" title="1.2 调试"></a>1.2 调试</h3><p>在 main.cpp 19 行打上断点，通过按 ==F5==，在弹出的窗口中依次选择 c++ GDB，g++ exe，系统自动生成 ==launch.json==，==tasks.json== 并置于 .vscode 文件夹下，同时还有自动生成的 main.exe 文件。</p><p><img src="/Complie_and_Debug/cpp_vscode/cpp_gdb.png" style="zoom:67%"></p><p><img src="/Complie_and_Debug/cpp_vscode/gpp_exe.png" style="zoom:67%"></p><p><img src="/Complie_and_Debug/cpp_vscode/_vscode_main_exe.png" style="zoom:67%"></p><p>可以发现编辑窗口，程序已经击中断点，并可以单步调试，需要注意的是此时的调用的 exe 文件是 ==main.exe==。</p><p><img src="/Complie_and_Debug/cpp_vscode/hit_break.png" style="zoom:50%"></p><p><img src="/Complie_and_Debug/cpp_vscode/single_step_debug.png" style="zoom:55%"><img src="/Complie_and_Debug/cpp_vscode/single_step_debug2.png" style="zoom:80%"></p><h3 id="1-2-json-文件配置"><a href="#1-2-json-文件配置" class="headerlink" title="1.2 json 文件配置"></a>1.2 json 文件配置</h3><p>上文为什么调用 main.exe 文件，而不是使用之前生成的 out1.exe ，这是因为自动生成的 launch.json 和 tasks.json 决定的。</p><ul><li>launch.json 中 program 使用的 main.exe （由 tasks.json 来生成）</li><li>tasks.json <strong>command</strong> ： g++，<strong>args</strong>： -g ./main.cpp -o main （恰好与1.1节命令行相类似）</li></ul><p><img src="/Complie_and_Debug/cpp_vscode/launch_json_main.png" style="zoom:50%"></p><p><img src="/Complie_and_Debug/cpp_vscode/tasks_main.png" style="zoom:50%"></p><p>launch.json 之所以可以使用 tasks.json ，是因为 ==preLauchTask== 标签值与 tasks.json 的 label 相同。</p><p><img src="/Complie_and_Debug/cpp_vscode/preLaunchTask.png" style="zoom:67%"></p><p>如果注释掉 launch.json 中 preLaunchTask 并修改 program 为 out1.exe ，即可使用之前生成的 out1.exe 来调试。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">"program": "$&#123;fileDirname&#125;\\out1.exe",</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="comment">//"preLaunchTask": "C/C++: g++.exe build active file"</span></span><br></pre></td></tr></table></figure><p>但是，这样的操作会有一个非常麻烦的问题，如果对 main.cpp 函数进行修改，则需要重新使用命令行生成可调式编译文件，这样才重更新调试，否则只是调试之前生成的 exe 而已。</p><p>所以 tasks.json 的作用就是可以简化这个过程，每次可以通过调用 task.json 的参数来重新生成 exe 文件。</p><h2 id="2-多文件编译"><a href="#2-多文件编译" class="headerlink" title="2. 多文件编译"></a>2. 多文件编译</h2><p>修改 main.cpp 函数，拆分成 main.cpp swap.cpp swap.h，如下所示：</p><p>main.cpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"before swap:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    swap(val1,val2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swap.cpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"swap.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swap.h</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-1-利用终端命令行来生成可编译文件"><a href="#2-1-利用终端命令行来生成可编译文件" class="headerlink" title="2.1 利用终端命令行来生成可编译文件"></a>2.1 利用终端命令行来生成可编译文件</h3><p>命令行如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -g ./main.cpp ./swap.cpp -o out2.exe</span><br></pre></td></tr></table></figure><ul><li>g++</li><li>-g ：可编译调试</li><li>./main.cpp ./swap.cpp：待编译文件 （多）</li><li>-o out2：输出 out2.exe 可执行文件</li></ul><p>通过命令行来执行 out2.exe，结果相同。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./out2</span><br></pre></td></tr></table></figure><h3 id="2-2-调试"><a href="#2-2-调试" class="headerlink" title="2.2 调试"></a>2.2 调试</h3><p>此时如果按照之前的步骤调试会报错，需要修改 tasks.json ，将其改成多文件。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"args": [</span><br><span class="line">    "-g",</span><br><span class="line">    "main.cpp",</span><br><span class="line">    "swap.cpp",</span><br><span class="line">    "-o",</span><br><span class="line">    <span class="string">"out2.exe"</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>需要注意的是，launch.json 的 program 也要更改到 out2.exe 的路径。</p><p>经过修改，同样可以击中断点并且可以调试。</p><h2 id="3-CMake-使用"><a href="#3-CMake-使用" class="headerlink" title="3. CMake 使用"></a>3. CMake 使用</h2><p>编写 CMakeLists.txt</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project(MYCmake)</span><br><span class="line"></span><br><span class="line">add_executable(out3 main.cpp swap.cpp) &#x2F;&#x2F; 生成 out3.exe</span><br></pre></td></tr></table></figure><h3 id="3-1-方法一"><a href="#3-1-方法一" class="headerlink" title="3.1 方法一"></a>3.1 方法一</h3><p>之后按 shift+ctrl+p 搜索 cmake configure，后点 GCC 8.1.0 ，会自动生成 build 文件，内部包含makefile文件。</p><p><img src="/Complie_and_Debug/cpp_vscode/cmake_configure.png" style="zoom:67%"></p><p><img src="/Complie_and_Debug/cpp_vscode/GCC810.png" style="zoom:67%"></p><p><img src="/Complie_and_Debug/cpp_vscode/build_folder.png" style="zoom:67%"></p><p>进入 build 文件夹：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure><p>后依次命令行输入，生成可执行文件 out3.exe，置于 build 文件夹下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">mingw32-make.exe</span><br></pre></td></tr></table></figure><p><img src="/Complie_and_Debug/cpp_vscode/cmake_debug.png" style="zoom:67%"></p><p>out3.exe 与之前的 out1.exe，out2.exe 相同，都是可以进行debug的。</p><h3 id="3-2-方法二"><a href="#3-2-方法二" class="headerlink" title="3.2 方法二"></a>3.2 方法二</h3><p>方法二主要就是不使用 shift+ctrl+p 等操作，而是自己创建 build 文件夹，并使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake ..  </span><br><span class="line">mingw32-make.exe</span><br></pre></td></tr></table></figure><p>其中如果存在VS的情况下可能会在cmake .. 阶段报错，需要使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -G <span class="string">"MinGW Makefiles"</span>..</span><br></pre></td></tr></table></figure><p>该命令仅第一次使用即可，后面继续使用 cmake ..</p><p>如果还报错，先清空文件夹在操作以上步骤</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm *</span><br></pre></td></tr></table></figure><h3 id="3-3-方法三"><a href="#3-3-方法三" class="headerlink" title="3.3 方法三"></a>3.3 方法三</h3><p>使用 tasks.json 来完成以上的过程，将命令写入其中：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"options"</span>: &#123;</span><br><span class="line">        <span class="attr">"cwd"</span>: <span class="string">"$&#123;fileDirname&#125;\\build"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"cmake"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"cmake"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">".."</span>,</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"make"</span>,</span><br><span class="line">            <span class="attr">"group"</span>: &#123;</span><br><span class="line">                <span class="attr">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">                <span class="attr">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"command"</span>:<span class="string">"mingw32-make.exe"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line"></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"Build"</span>,</span><br><span class="line">            <span class="attr">"dependsOn"</span>:[</span><br><span class="line">                <span class="string">"cmake"</span>,</span><br><span class="line">                <span class="string">"make"</span>,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照CMakeLists.txt</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project(MYCmake)</span><br><span class="line"></span><br><span class="line">add_executable(out4 main.cpp swap.cpp)</span><br></pre></td></tr></table></figure><p>相应的修改 launch.json 中可执行文件路径。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"program": "$&#123;fileDirname&#125;\\build\\out4.exe",</span><br></pre></td></tr></table></figure><p>最终可以 debug 的 out4.exe 文件。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>launch.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"g++.exe - 生成和调试活动文件"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;fileDirname&#125;\\build\\out4.exe"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [],</span><br><span class="line">            <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"cwd"</span>: <span class="string">"$&#123;fileDirname&#125;"</span>,</span><br><span class="line">            <span class="attr">"environment"</span>: [],</span><br><span class="line">            <span class="attr">"externalConsole"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="attr">"miDebuggerPath"</span>: <span class="string">"D:\\Productivity\\MinGW\\mingw64\\bin\\gdb.exe"</span>,</span><br><span class="line">            <span class="attr">"setupCommands"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"description"</span>: <span class="string">"为 gdb 启用整齐打印"</span>,</span><br><span class="line">                    <span class="attr">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="attr">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"preLaunchTask"</span>: <span class="string">"Build"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tasks.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"options"</span>: &#123;</span><br><span class="line">        <span class="attr">"cwd"</span>: <span class="string">"$&#123;fileDirname&#125;\\build"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"cmake"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"cmake"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">".."</span>,</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"make"</span>,</span><br><span class="line">            <span class="attr">"group"</span>: &#123;</span><br><span class="line">                <span class="attr">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">                <span class="attr">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"command"</span>:<span class="string">"mingw32-make.exe"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line"></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"Build"</span>,</span><br><span class="line">            <span class="attr">"dependsOn"</span>:[</span><br><span class="line">                <span class="string">"cmake"</span>,</span><br><span class="line">                <span class="string">"make"</span>,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">project(MYCmake)</span><br><span class="line"></span><br><span class="line">add_executable(out4 main.cpp swap.cpp)</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"before swap:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    swap(val1,val2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after swap:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swap.cpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"swap.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swap.h</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Complie_and_Debug</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Complie_and_Debug</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>test.md</title>
    <url>/%E6%B5%8B%E8%AF%95/test-md/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h3 id="博客文档格式，各种测试"><a href="#博客文档格式，各种测试" class="headerlink" title="博客文档格式，各种测试"></a>博客文档格式，各种测试</h3><p><strong><code>数学公式渲染测试</code></strong></p><p>行内公式 $E= MC^2$</p><p>行间公式</p><script type="math/tex;mode=display">F = ma \tag{1}</script><p><strong><code>代码块测试</code></strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>图片测试</code></strong></p><p><img src="/%E6%B5%8B%E8%AF%95/test-md/炭治郎2.jpg" style="zoom:67%"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-CSI_Report</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:36 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="CSI-Report"><a href="#CSI-Report" class="headerlink" title="CSI Report"></a>CSI Report</h1><h2 id="1-CSI-测量和上报的配置框架"><a href="#1-CSI-测量和上报的配置框架" class="headerlink" title="1 CSI 测量和上报的配置框架"></a>1 CSI 测量和上报的配置框架</h2><h3 id="1-1-框架"><a href="#1-1-框架" class="headerlink" title="1.1 框架"></a>1.1 框架</h3><p>CSI（channel state information）包括 CQI，RI，LI，PMI，CRI，SSBRI 和 L1-RSRP。终端上报 CSI 给 gNB，gNB 会根据上报的内容进行调度的调整以及波束管理相关的工作，因此 CSI 的上报十分重要。<br>CSI的工作原理是，首先 gNB 给终端配置适当的 CSI-RS 资源，然后终端对 CSI-RS 进行测量并计算出所需要的的 CSI，最后通过 PUCCH/PUSCH 上报给 gNB。</p><p>CSI-RS相关的配置都在RRC参数 <em>CSI-MeasConfig</em> 中定义，见下图（摘自38331）</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p1-measConfig1.png" alt><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p2-measConfig2.png" alt></p><p>借鉴博客作者总结的图片 (公众号：GiveMe5G )</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p3-全局.png" alt></p><p>CSI框架基本配置两个东西，一个是用于配置CSI测量的CSI-RS资源，另一个是配置CSI如何上报。</p><p>分析 <em>CSI-MeasConfig</em> 可以从两个重要的 IE 着于：<em>csi-ResourceConfig</em>， <em>csi-ReportConfig</em></p><h3 id="1-2-csi-ResourceConfig"><a href="#1-2-csi-ResourceConfig" class="headerlink" title="1.2 csi-ResourceConfig"></a>1.2 <em>csi-ResourceConfig</em></h3><p><em>csi-ResourceConfig</em>: 这个 IE 就是告诉你配置的CSI-RS资源的。一个 <em>CSI-ResourceConfig</em> 下面会配置 <em>ResourceSet</em>，<em>ResourceSet</em> 里面包含最基本的 <em>CSI-RS Resource</em>。<em>CSI-RS-Resource</em>包括 <em>nzp-CSI-RS</em>，<em>SSB</em> 和 <em>csi-IM</em> 三种。<br>这些 CSI-RS 的 resource 类型可以是<font color="#0000FF"><strong>周期</strong></font>， <font color="#008000"><strong>半持续</strong></font> 和<font color="#FF0000"><strong>非周期</strong></font>，三种类型。协议里面特意明确了对于周期和半持续的 <em>CSI-RS resource</em>，每个 <em>csi-ResourceConfig</em> 只能配置1个 <em>csi-RS-ResourceSet</em>。</p><h3 id="1-3-csi-ReportConfig"><a href="#1-3-csi-ReportConfig" class="headerlink" title="1.3 csi-ReportConfig"></a>1.3 <em>csi-ReportConfig</em></h3><p><em>csi-ReportConfig</em>: 这个 IE 是用于配置如何 report 的。</p><ul><li><em>resourcesForChannelMeasurement</em> \ <em>csi-IM-ResourcesForInterference</em> \ <em>nzp-CSI-RS-ResourcesForInterference</em>,这三个参数表示用于 Channel Measurement 和 Interference Measurement 的 <em>csi-ResourceConfigId</em>，用得到的 Id 和 <em>csi-ResourceConfig</em> 进行关联，即可获取到用于测量的CSI-RS资源</li><li><em>reportConfigType</em>：这个IE用于配置 <em>CSI report</em>的类型是周期的，非周期的，半持续OnPUCCH还是半持续OnPUSCH的。对于非周期和半持续OnPUSCH还会配置 <em>TriggerState</em> 和 <em>reportTriggerSize</em>，用来配合DCI中的 <em>CSI request</em> 字段来使用。</li></ul><h2 id="2-CSI-测量和上报的触发机制"><a href="#2-CSI-测量和上报的触发机制" class="headerlink" title="2 CSI 测量和上报的触发机制"></a>2 CSI 测量和上报的触发机制</h2><p>通过上面的配置框架，我们知道CSI-RS的 resource 和 report 都各有三种类型，周期，半持续以及非周期。那么resource 和 report的类型是否可以任意两两组合呢？协议给出了明确的要求，由 [TS 38.214 Table 5.2.1.4-1] 给出：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/t1-214-5.2.1.4-1.png" alt></p><p>经过简单的总结下，合理的组合如下：</p><ul><li><p><strong><font color="#0000FF">周期性上报</font></strong>：只能使用<strong><font color="#0000FF">周期性 CSI-RS</font></strong>；</p></li><li><p><strong><font color="#008000">半持续性上报 </font></strong>On Pucch：可以使用<strong><font color="#0000FF">周期性</font></strong>和<strong><font color="#008000">半持续性</font></strong>CSI-RS；</p></li><li><p><strong><font color="#008000">半持续性上报 </font></strong>On Pusch：可以使用<strong><font color="#0000FF">周期性</font></strong>和<strong><font color="#008000">半持续性</font></strong>CSI-RS；</p></li><li><p><strong><font color="#FF0000">非周期性上报</font></strong>：可以使用<strong><font color="#0000FF">周期性</font></strong>，<strong><font color="#008000">半持续性</font></strong>和<strong><font color="#FF0000">非周期性</font></strong>CSI-RS。</p></li></ul><p>很显然，gNB 需要先发 CSI-RS ，然后终端才能接收和测量，并上报 CSI report，也就是先发再报。这里面涉及<strong>两个</strong>大的问题</p><ul><li>首先就是对于每种类型的 CSI-RS，gNB 什么时候发？</li><li>其次测量完 CSI-RS，UE 什么时候报？</li></ul><h3 id="2-1-CSI-RS-何时发送？"><a href="#2-1-CSI-RS-何时发送？" class="headerlink" title="2.1 CSI-RS 何时发送？"></a>2.1 CSI-RS 何时发送？</h3><p>CSI-RS 的发送按照 CSI-RS 的 种类来划分为不同的操作。</p><p><em>csi-ResourceConfig -&gt; resourceType</em> $\in \{Periodic,Semipersistent,Aperiodic\}$</p><p>① <em>csi-ResourceConfig -&gt; resourceType</em> $\in \{Periodic\}$<br>RRC 配置后立即生效，发送的时间按照参数 <em>periodicityAndOffset</em> 使用协议中的公式计算，如下描述。</p><p>② <em>csi-ResourceConfig -&gt; resourceType</em> $\in \{SemiPeriodic\}$<br>RRC配置后需要 MAC CE 激活才能生效，发送时间按照参数 <em>periodicityAndOffset</em> 使用协议中的公式计算，同 ①</p><p>③ <em>csi-ResourceConfig -&gt; resourceType</em> $\in \{Aperiodic\}$<br>非周期的 CSI-RS 只用于非周期上报的场景，与非周期上报的触发紧密相连，依靠 DCI 来触发。</p><p>①② 中的计算公式：</p><script type="math/tex;mode=display">(N_{slot}^{frame,\mu}n_f + n_{s,f}^{\mu}-T_{offset})mod T_{CSI-RS} = 0</script><p>其中：<br>$T_{CSI-RS}$ 和 $T_{offset}$ 由高层参数 <em>CSI-ResourcePeriodicityAndOffset</em> 或者 <em>slotConfig</em> 配置。</p><h3 id="2-2-CSI-Report-何时发送？"><a href="#2-2-CSI-Report-何时发送？" class="headerlink" title="2.2 CSI-Report 何时发送？"></a>2.2 CSI-Report 何时发送？</h3><p>CSI-Report 的发送也是按照 CSI-Report 的种类来划分为不同的操作。<br>CSI report 分为四种：</p><ul><li><strong><font color="#0000FF">周期性上报</font></strong></li><li><strong><font color="#00800">半持续上报</font></strong> <strong>On PUCCH</strong></li><li><strong><font color="#00800">半持续上报</font></strong> <strong>On PUSCH</strong></li><li><strong><font color="#FF0000">非持续上报</font></strong></li></ul><h4 id="2-2-1-周期性上报"><a href="#2-2-1-周期性上报" class="headerlink" title="2.2.1 周期性上报"></a>2.2.1 周期性上报</h4><p>RRC 配置好<strong><font color="#0000FF">周期性</font></strong>的 CSI-RS Resource 和 Report 参数后，就会立即生效，无需 MAC-CE / DCI 去激活或者触发 CSI-RS 的发送和 CSI 的上报；CSI 上报的周期和 slotOffset 按照参数 <em>reportSlotconfit</em> 配置执行，使用PUCCH上报。</p><h4 id="2-2-2-半持续上报"><a href="#2-2-2-半持续上报" class="headerlink" title="2.2.2 半持续上报"></a>2.2.2 半持续上报</h4><p><strong>半持续上报 On PUCCH</strong></p><ul><li>假设 RRC 配置了<strong><font color="#008000">半持续 CSI-RS</font></strong> ，首先需要 MAC CE 1 激活 CSI-RS 的发送，然后再通过 MAC CE 2 激活 CSI report；</li><li>假设 RRC 配置的是 <strong><font color="#0000FF">周期性 CSI-RS</font></strong> ，RRC配置好后会立即生效，则无需 MAC CE 1这一步，CSI 上报的周期和 slotOffset 按照参数 <em>reportSlotConfig</em> 中的配置执行。<br>（注意：其中的MAC CE 1 和 MAC CE 2 代表的是不同的MAC CE）</li></ul><p><strong>半持续上报 On PUSCH</strong></p><ul><li>假设 RRC 配置了<strong><font color="#008000">半持续 CSI-RS</font></strong>，首先需要 MAC CE 1 激活 CSI-RS 的发送，然后通过 DCI 触发 CSI report；</li><li>假设 RRC 配置的是<strong><font color="#0000FF">周期性 CSI-RS</font></strong>，RRC配置好后会立即生效，则无需 MAC CE 1这一步，CSI 上报的周期和 slotOffset 按照参数 <em>CSI-ReportConfig</em> 中的配置执行。</li></ul><p>对于 DCI 的触发 CSI report 细节如下：</p><p>此时的 DCI 的类型为 DCI 0_1，使用 SP-CSI-RNTI 加扰，其次 DCI 中 在触发中涉及到了两个字段：<em>CSI-request</em> ， <em>Time domain resource assignment</em>。<br><strong><em>CSI-request</em></strong>，通过 codepoint 的设置来关联对应的 TriggerState ， TriggerState 里面会定义关联的 CSI-ReportConfig，然后里面可以找到这个 report 相关的 CSI-RS resource Config 以及 report 的周期和 OffsetList。其中周期是通过 reportSlotConfig 直接给出的，OffsetList是通过 <em>reportSlotOffsetList</em> 参数( 这是一个<strong>List</strong> )定义的 。<br><strong><em>Time domain resource assignment</em></strong> 字段的 codepoint 取值再去关联 List 中的值。（例如：codepoint = 0，就取OffsetList中的第一个值；如果是codepoint = i，就取 OffsetList中的第 $i+1$个值。如果取值为 Y ，也就意味着距离 DCI 后面第 Y 个 slot 发送 CSI Report。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p4-半周期1.png" alt></p><h4 id="2-2-3-非周期上报"><a href="#2-2-3-非周期上报" class="headerlink" title="2.2.3 非周期上报"></a>2.2.3 非周期上报</h4><ul><li>假设 RRC 配置了<strong><font color="#008000">半持续 CSI-RS </font></strong>，首先需要 MAC CE 1 激活 CSI-RS 的发送，然后通过 DCI 触发 CSI report；</li><li>假设 RRC 配置的是<strong><font color="#0000FF">周期性 CSI-RS</font></strong>，RRC配置好后会立即生效，则无需 MAC CE 1这一步，然后通过 DCI 触发 CSI report；</li><li>假设 RRC 配置的是<strong><font color="#FF0000">非周期 CSI-RS</font></strong>，非周期的 CSI-RS 发送和非周期的 CSI report 均由 DCI 触发。</li></ul><p>其中 <strong><font color="#FF0000">非周期 CSI-RS 发送 + 非周期 CSI 上报</font></strong> 最为复杂。</p><ol><li>根据 DCI 0_1 中的 <em>CSI request</em> 字段的 codepoint 去关联对应的 TriggerState 。(注意：与半持续 DCI 触发不同，CSI request 如果为 0 ，代表不要求触发 CSI-RS，只有非 0，才触发有效)</li><li>关联到 TriggerState，可以得到两个重要的参数，<em>CSI-ReportConfig</em> , <em>resourceSet</em>。<ul><li><em>CSI-ReportConfig</em>，类似于<u>半周期 On PUSCH</u>，其中的 <em>reportSlotOffsetList</em> 由 DCI 中的 <em>time domain resource assignment</em> 字段指出 List 的索引（参考 <u>半周期 On PUSCH</u>）。</li><li><em>resourceSet</em>，它并不能直接取对应 <em>CSI-measConfig</em> 中的 resourceSet ID。它的作用类似为 List index。在 <em>CSI-ReportConfig</em> 中关联了对应的 <em>CSI-resourceConfigId</em>，通过 <em>CSI-resourceConfigId</em> 可以关联一个 <em>resourceSetList</em> ，这时候需要用 <em>resourceSet</em> 的值去确定 List 中唯一的 resource Set。</li></ul></li></ol><p>以上的描述如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p5-非周期1.png" alt></p><h3 id="2-3-各种场景"><a href="#2-3-各种场景" class="headerlink" title="2.3 各种场景"></a>2.3 各种场景</h3><p>根据之前总结下：</p><ul><li><p><strong><font color="#0000FF">周期性上报</font></strong>：只能使用<strong><font color="#0000FF">周期性 CSI-RS</font></strong>；</p></li><li><p><strong><font color="#008000">半持续性上报 </font></strong>On Pucch：可以使用<strong><font color="#0000FF">周期性</font></strong>和<strong><font color="#008000">半持续性</font></strong>CSI-RS；</p></li><li><p><strong><font color="#008000">半持续性上报 </font></strong>On Pusch：可以使用<strong><font color="#0000FF">周期性</font></strong>和<strong><font color="#008000">半持续性</font></strong>CSI-RS；</p></li><li><p><strong><font color="#FF0000">非周期性上报</font></strong>：可以使用<strong><font color="#0000FF">周期性</font></strong>，<strong><font color="#008000">半持续性</font></strong>和<strong><font color="#FF0000">非周期性</font></strong>CSI-RS。</p></li></ul><p>有八种可能的选择。</p><h4 id="2-3-1-周期上报"><a href="#2-3-1-周期上报" class="headerlink" title="2.3.1 周期上报"></a>2.3.1 周期上报</h4><p><strong><font color="#0000FF">周期上报，周期CSI-RS</font></strong>：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p6-周周.png" alt></p><h4 id="2-3-2-半持续上报"><a href="#2-3-2-半持续上报" class="headerlink" title="2.3.2 半持续上报"></a>2.3.2 半持续上报</h4><h5 id="2-3-2-1-半持续上报-On-PUCCH"><a href="#2-3-2-1-半持续上报-On-PUCCH" class="headerlink" title="2.3.2.1 半持续上报 On PUCCH"></a>2.3.2.1 半持续上报 On PUCCH</h5><ul><li><strong><font color="#0000FF">周期</font></strong> <strong>CSI-RS</strong></li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p6-半C周.png" alt></p><ul><li><strong><font color="#008000">半持续</font></strong> <strong>CSI-RS</strong></li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p9-半C半.png" alt></p><h6 id="2-3-2-2-半持续上报-On-PUSCH"><a href="#2-3-2-2-半持续上报-On-PUSCH" class="headerlink" title="2.3.2.2 半持续上报 On PUSCH"></a>2.3.2.2 半持续上报 On PUSCH</h6><ul><li><strong><font color="#0000FF">周期</font></strong> <strong>CSI-RS</strong></li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p8-半S周.png" alt></p><ul><li><strong><font color="#008000">半持续</font></strong> <strong>CSI-RS</strong></li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p10-半S半.png" alt></p><h4 id="2-3-3-非周期上报"><a href="#2-3-3-非周期上报" class="headerlink" title="2.3.3 非周期上报"></a>2.3.3 非周期上报</h4><p><strong><font color="#0000FF">周期</font></strong> <strong>CSI-RS</strong></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p11-非周.png" alt></p><p><strong><font color="#008000">半持续</font></strong> <strong>CSI-RS</strong></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p12-非半.png" alt></p><p><strong><font color="#FF0000">非周期</font></strong> <strong>CSI-RS</strong></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p13-非非.png" alt></p><h2 id="3-CSI-Report-配置"><a href="#3-CSI-Report-配置" class="headerlink" title="3 CSI Report 配置"></a>3 CSI Report 配置</h2><p>配置CSI Report涉及的内容较多，也比较复杂。上面阐述了CSI Report配置的一部分内容，即如何关联要测量的 CSI-RS resource 以及 CSI 上报的类型（<strong><font color="#0000FF">周期</font>，<font color="#FF0000">非周期</font>, <font color="#008000">半持续</font></strong>）。以下阐述剩下的配置内容，如 report quantity，频域的上报粒度（宽带/窄带），Channel/Interference Measument是否时域受限，cqi-table的选择，subbandSize 的选择以及 codebook 的配置。</p><h3 id="3-1-测量与上报"><a href="#3-1-测量与上报" class="headerlink" title="3.1 测量与上报"></a>3.1 测量与上报</h3><p>参考前文</p><h3 id="3-2-上报内容"><a href="#3-2-上报内容" class="headerlink" title="3.2 上报内容"></a>3.2 上报内容</h3><p>主要是关于 reportQuantity 的设置，指明 UE 需要上报哪些测量内容，主要分为两类：</p><ul><li>CSI：CQI，PMI，R1，CRI，i1，主要用于给 gNB 提供调度方面的辅助信息</li><li>L1-RSRP：cri-RSRP，SSB-Index-RSRP，主要为 gNB 提供 Beam 管理的信息</li></ul><h3 id="3-3-频域上报粒度配置"><a href="#3-3-频域上报粒度配置" class="headerlink" title="3.3 频域上报粒度配置"></a>3.3 频域上报粒度配置</h3><p>高层参数：reportFreqConfiguration</p><ul><li><em>csi-ReportingBand</em> 定义一个 CSI reporting band，这个 reporting band是由BWP内划分的subband 组成的子集合，这些 subband可以连续也可以不连续。由一个 bitmap 来指定需要上报哪些 subband。比如这个例子 subbands<strong>12</strong> = <strong>11</strong>00<strong>1111</strong>00<strong>11</strong>。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p15-subbands.png" alt></p><ul><li><em>cqi-FormatIndicator</em> 用于表明 U E需要上报 single(wideband) 还是multiple(subband) 的CQI。CQI是针对每个 TB（codeword）反馈的。如果配置为 subband 的CQI反馈，每个subband上的CQI反馈其实是一个与 wideband CQI的差值，公式如下：</li></ul><blockquote><p>Sub-band Offset level (s) = sub-band CQI index (s) - wideband CQI index</p></blockquote><p>然后再按照[TS 38.214 Table 5.2.2.1-1]] 将offset level转换成要报的 subband differential CQI值：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/t2-214-5.2.2.1-1.png" alt></p><ul><li><em>pmi-FormatIndicator</em> 用于表明 UE 需要上报 single(wideband) 还是 multiple(subband)的 PMI。</li></ul><p>一个CSI Report配置到底是wideband 还是subband的CQI/PMI，这取决于几个RRC参数配置的组合， TS 38.214对 wideband 和 suband 的参数组合有明确规定，可以总结成如下表格:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/p16 wideband subband.png" alt></p><h3 id="3-4-其他"><a href="#3-4-其他" class="headerlink" title="3.4 其他"></a>3.4 其他</h3><ul><li><p><em>timeRestrictionForChannelMeasurements</em> 和 <em>timeRestrictionForInterferenceMeasurements</em> 是用来规定是否在时域上对信道测量和干扰测量进行限制。</p></li><li><p><em>codebookConfig</em>:这个 IE 是里面非常非常重要的，也是非常非常复杂的。它是配置有关MIMO codebook和PMI相关的内容。</p></li><li><p><em>cqi-Table</em>: 是用来配置 UE 应该使用哪张 CQI 表作为 CQI 反馈依据的。38214 里面一共有三张 CQI表。UE 通过 CQI 的测量和上报来影响 gNB 下行调度的 MCS，目标是是适应无线链路的变化，使得BLER 控制在目标值内。其中 table1 和 table2 适用于eMBB场景，目标BLER=0.1；table3 用于URLLC 场景，目标BLER=0.00001</p></li><li><p><em>subbandSize</em>: 协议中规定可以上报 subband CQI/PMI，那么就需要要知道这些 subband 是怎么划分的，他们的<strong>位置</strong>和<strong>大小</strong>是什么样子的。协议里面是有规定的。每个 subband 的大小是与BWP 的大小相关的，限制组合如 [TS 38.214 Table 5.2.1.4-2]。知道了 subband 的大小和 BWP 的大小，就可以确定划分了多少个 subband，然后就可以配置 subband report 的 bitmap了。</p></li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/t3-214-5.2.1.4-2.png" alt></p><h2 id="4-CSI-Report-On-PUCCH-PUSCH"><a href="#4-CSI-Report-On-PUCCH-PUSCH" class="headerlink" title="4 CSI Report On PUCCH / PUSCH"></a>4 CSI Report On PUCCH / PUSCH</h2><h3 id="4-1-CSI-report-on-PUSCH"><a href="#4-1-CSI-report-on-PUSCH" class="headerlink" title="4.1 CSI report on PUSCH"></a>4.1 CSI report on PUSCH</h3><p>非周期 CSI report on pusch支持 TypeI 和 TypeII 的 wideband and subband CSI；</p><p>半持续 on PUSCH支持 TypeI 和 TypeII 的 wideband and subband CSI；</p><p>对于Type I 和 TypeII CSI on PUSCH, Payload可能很大，CSI采用 two parts 的解决方案part1+part2，Part 1的 payload 大小固定而且可以用于判断 part2 的 bit 数。Part1 和 Part2 在不同情况下包含的内容是不同的，具体如下：</p><ul><li><p>Type I<br>Part1：RI, CRI, CQI for 1st codeword<br>Part2：PMI and CQI for the 2nd codeword if RI&gt;4</p></li><li><p>Type II<br>Part1：RI, CQI，每个layer的非0宽带幅度系数<br>Part2：PMI</p></li></ul><p>当reportQuantity 被设置为 ‘cri-RSRP’ or ‘ssb-Index-RSRP’, the CSI feedback consists of a single part.</p><p>由于 PUSCH 可能一次性无法装下要反馈的 CSI，可能需要做取舍，丢掉一些内容。丢掉哪些内容呢，取决于各内容的优先级（如下图）：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/t4-214-5.2.3-1.png" alt></p><h3 id="4-2-CSI-report-on-PUCCH"><a href="#4-2-CSI-report-on-PUCCH" class="headerlink" title="4.2 CSI report on PUCCH"></a>4.2 CSI report on PUCCH</h3><p>周期性 CSI report 可以使用PUCCH format2/3/4 来支持type1 CSI wideband上报；</p><p>半持续 CSI on PUCCH 支持 typeI CSI 和有限制的 Type II</p><ul><li>半持续 CSI on pucch format2 支持 type1 wideband</li><li>半持续 CSI on pucch format 3/4 支持 type1 wideband/subband 和Type II CSI part 1</li></ul><p>UE 在使用 PUCCH format4上报 CSI 时，UCI+CRCbit数应该小于等于115 bit</p><p><strong>总结如下：</strong></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-CSI-Report/表格.png" alt></p><blockquote><p>参考：<br>公众号：GiveMe5G，春天工作室<br>协议：TS 38.214</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>CSI</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-传输流程</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E4%BC%A0%E8%BE%93%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="基于码本传输流程"><a href="#基于码本传输流程" class="headerlink" title="基于码本传输流程"></a>基于码本传输流程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>所谓的码本，主要内容是预编码矩阵索引 (PMI) 和 预编码矩阵 (precoding matrix) 。<br>基于码本的传输流程就是数据传输过程中使用的预编码矩阵采用的是由码本中规定的预编码矩阵。</p><p>对于上行和下行码本的确定，有不同的方式：</p><ul><li>下行：终端测量CSI后，对 PMI 的反馈，基站获知终端推荐的预编码矩阵</li><li>上行：基站测量SRS后，通过 DCI 调度，将 TPMI ,TRI 发送给终端，终端按照索引选取预编码矩阵。</li></ul><h2 id="预编码矩阵的使用"><a href="#预编码矩阵的使用" class="headerlink" title="预编码矩阵的使用"></a>预编码矩阵的使用</h2><p>下行：采取 Transmission scheme 1，基站将数据和 DMRS 一同预编码，之后通过无线信道，发送给终端。终端可以直接通过 DMRS 估计出信道信道矩阵 H’ (终端认为)，实际 𝐻′=𝐻∗𝑊，因此预编码矩阵对终端来说是透明的。</p><p>上行：终端需要知道基站配置给它的预编码矩阵，PUSCH数据在层映射后，或变换预编码 (如果使用) 后，进行预编码操作。</p><h2 id="下行基于码本传输流程"><a href="#下行基于码本传输流程" class="headerlink" title="下行基于码本传输流程"></a>下行基于码本传输流程</h2><p>gNB确定下行预编码矩阵主要通过两个途径：</p><ul><li>基于 PMI 的反馈 → 基于码本</li><li>gNB 通过 SRS 上行参考信号的测量（利用TDD系统的信道互异性）→ 基于非码本</li></ul><h3 id="码本分类"><a href="#码本分类" class="headerlink" title="码本分类"></a>码本分类</h3><p>Type I codebook：主要用于 SU-MIMO 场景，可以提供比较高阶的空间复用，单用户最多可以支持到 8 个 layer。TypeI codebook 又可以分为 single panel和 multiple panel 两种类型。</p><p>Type II codebook: 主要用于 MU-MIMO 场景，由于要在同一时频资源上同时调度多个用户，每个用户限制最多支持到 2 个 layer。比较复杂。</p><p>码本中主要的内容就是 PMI index 和 precoding matrix，每个 PMI 和预编码矩阵一一对应。终端上报 PMI，将自己认为最合适的预编码矩阵 index 发送给基站做参考，基站可以使用终端的建议，也可以不使用，因为基站会站在一个更全局的网络来做一个最优的选择，不但要考虑目标终端的解调性能，还要考虑这个小区内其他用户的感受。</p><h2 id="PMI-如何确定？"><a href="#PMI-如何确定？" class="headerlink" title="PMI 如何确定？"></a>PMI 如何确定？</h2><p>以 Type I Single-Panel，以此为例，来看终端是如何选择 precoding matrix，以及如何确定PMI的。</p><p><strong>① CSI-RS 的端口数量 <em>nrofAntennaPorts</em> = 2：</strong><br>终端根据测量得到的 RI，确定选择 1 or 2 layer，然后从 [TS 38.214 Table 5.2.2.2.1-1] 中的预编码矩阵中选取，并将对应的 index 即 PMI 反馈给基站。此时参数 <em>twoTX-CodebookSubsetRestriction</em> 有 6 bits，与 6 个可用的precoding matrix 一一对应，如果这个 bitmap 中的某一个bit置为0，意味着基站不允许终端使用这个预编码矩阵。 此外 <em>typeI-SinglePanel-ri-Restriction</em> 这个 IE 是用来对 RI 上报做限制的。这是 1 个 8 bits 的 bitmap 对应于 type1-singlepanel 可以支持最高8个layer。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E4%BC%A0%E8%BE%93%E6%B5%81%E7%A8%8B/t1-214-5.2.2.2.1-1.png" alt></p><p><strong>② CSI-RS 的端口数量 <em>nrofAntennaPorts</em> = {4,8,12,16,24,32}:</strong></p><ul><li><p>对于 $v \in \{2,3,4\}$ , PMI 反馈值为 $i_{1,1},i_{1,2},i_{1,3},i_{2}$</p><ul><li>首先根据 RRC 参数中的 <em>n1-n2</em> 的配置，得到 N1 和 N2 的值，然后结合 CSI-RS 的端口数量，以及 [TS 38.214 Table 5.2.2.2.1-2]，得到 O1 和 O2；</li><li>参考 [TS 38.214 Table 5.2.2.2.1-6~8]，终端在选定预编码矩阵后就可以确定它的下标，可以 $i_{1,1}, i_{1,2}, i_2, k_1和k_2$；</li><li>参考 [TS 38.214 Table 5.2.2.2.1-3~4]，可以根据 $i_{1,3}$ 与 $k_1$ 和 $k_2$ 的关系，得到 $i_{1, 3}$；</li><li>最终得到终端要反馈的 PMI = {$i_{1,1},i_{1,2},i_{1,3},i_{2}$}</li></ul></li><li><p>对于 $v \notin \{2,3,4\}$ , PMI 反馈值为 $i_{1,1},i_{1,2},i_{2}$ (与前者类似)</p><ul><li>首先根据 RRC 参数中的 <em>n1-n2</em> 的配置，得到 N1 和 N2 的值，然后结合 CSI-RS 的端口数量，以及 [TS 38.214 Table 5.2.2.2.1-2]，得到 O1 和 O2；</li><li>参考 [TS 38.214 Table 5.2.2.2.1-5,9~12]，终端在选定预编码矩阵后就可以确定它的下标，可以 $i_{1,1}, i_{1,2}, i_2, k_1和k_2$；</li><li>最终得到终端要反馈的 PMI = {$i_{1,1},i_{1,2},i_{2}$}</li></ul></li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E4%BC%A0%E8%BE%93%E6%B5%81%E7%A8%8B/t2-214-5.2.2.2.1-2.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E4%BC%A0%E8%BE%93%E6%B5%81%E7%A8%8B/t3-214-5.2.2.2.1-3~4.png" alt></p><p>表格很多，选取了一个示例：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E4%BC%A0%E8%BE%93%E6%B5%81%E7%A8%8B/t4-214-5.2.2.2.1-6.png" alt></p><h2 id="上行基于码本传输流程"><a href="#上行基于码本传输流程" class="headerlink" title="上行基于码本传输流程"></a>上行基于码本传输流程</h2><p>基站基于 TDD 模式的下行链路测量，或探测参考信号的上行链路测量来确定预编码矩阵。然后基站在 DCI 中指示预编码信息 (TMPI , TRI) 发送给 UE，UE 通过搜索一系列预定义的表格数据得到预编码矩阵。[TS 38.211 Table 6.3.1.5-1~7]</p><p>表格很多，选取了一个示例：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E4%BC%A0%E8%BE%93%E6%B5%81%E7%A8%8B/t5-211-6.3.1.5-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E4%BC%A0%E8%BE%93%E6%B5%81%E7%A8%8B/t6-211-6.3.1.5-2.png" alt></p><h1 id="基于非码本的传输流程"><a href="#基于非码本的传输流程" class="headerlink" title="基于非码本的传输流程"></a>基于非码本的传输流程</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>下行：gNB 通过SRS上行参考信号的测量（利用TDD系统的信道互异性），基站通过奇异值分解，获得预编码矩阵。<br>上行：UE 通过测量 CSI-RS 信号来确定合适的预编码矩阵，然后把使用这个预编码矩阵用于发射SRS信号。之后，gNB 通知 UE 使用波束赋形矢量的哪个子集。最后，UE可以将选择的波束赋形矢量用于PUSCH传输）。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>CSI</tag>
        <tag>SRS</tag>
        <tag>codebook / non-codebook</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-214协议补充</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:36 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="上行传输模式"><a href="#上行传输模式" class="headerlink" title="上行传输模式"></a>上行传输模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>下行方向：NR中仅支持一种下行传输模式，即基于闭环 DMRS 的空分复用 PDSCH传输。单 UE 最多支持 8 个正交端口，8层传输 (1-4：单码字/5-8层：两码字)。PDSCH 的 DMRS 和 PDSCH 采用相同的预编码矩阵；基站调度 PDSCH 资源时，无需指示码本信息，也称为非码本 <em>Non-Codebook</em> 传输。<br>上行方向：NR 支持两种传输模式：基于码本和非码本的 PUSCH 传输。单层 UE 最多 4 层传输，单码字 (Transform Precoding，即DFT-S-OFDM，仅支持单层传输)。</p><ul><li>基于码本传输时，基站在 DCI 中指示预编码矩阵中的索引</li><li>基于非码本传输时，基站在 DCI 中通过 SRI (SRS 资源索引) 来表示 PUSCH 的预编码码字</li></ul><p>PUSCH 传输模式：码本和非码本<br>在RRC高层信令中 <em>PUSCH-Config</em> 配置 (UE-Specific)<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txconfig	ENUMERATED &#123;codebook,nonCodebook&#125;	OPTIONAL, -- Need S</span><br></pre></td></tr></table></figure><p></p><p>如果不配置 <em>txConfig</em> 的情况下，不能使用 DCI 0_1 格式调度 (单天线端口，在使用DCI 0_0 调度时，PUSCH 只能基于单天线端口传输)；<br>当配置为 <em>codebook</em> 传输时，NR 系统允许基站为 UE 最多配置一个用于基于码本上行传输 CSI 获取的 SRS 资源集，该 SRS 资源集内最多可配置两个 SRS 资源包含相同的 SRS 天线端口数。SRI的字段长度为 $\lceil log_2 (N_{SRS}) \rceil$。</p><h2 id="基于码本传输"><a href="#基于码本传输" class="headerlink" title="基于码本传输"></a>基于码本传输</h2><p>上行 PUSCH ，基于码本传输的总体流程示意，如下图所示：</p><ol><li>基站给UE配置 1 或 2 个 (根据UE能力) SRS 资源，UE 向基站发送用于基于码本的上行传输方案 CSI 获取 的 SRS ，基站进行上行 CSI 测量；</li><li>基站根据测量结果，确定 CSI 参数，包括选择的 SRS 资源 (SRI, SRS Resource Indicator) ，传输的预编码矩阵索引 (TPMI, Transmit Precoding Marrix Indicator) 和传输 Rank (TRI, Transmit Rank Indicator)，即上行传输的层数；进一步根据预编码矩阵和信道信息，确定出上行传输的 MCS 等级。</li><li>基站通过 DCI 信令，指示 UE 的CSI 参数，以及相应的 MCS 。</li><li>UE 根据基站指示的 MCS 对数据进行调制编码，并利用所指示的 SRI、TPMI 和 TRI 确定发送时使用的预编码矩阵和传输层数，进而对数据进行预编码及发送。PUSCH 的解调参考信号与PUSCH 的数据采用相同的预编码方式。</li><li>基站根据解调参考信号估计上行信道，并进行数据检测。</li></ol><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p2-码本传输.png" alt></p><h2 id="基于非码本传输"><a href="#基于非码本传输" class="headerlink" title="基于非码本传输"></a>基于非码本传输</h2><p>非码本传输方案与基于码本的上行传输方案的区别在于其预编码不在限定于基于固定码本的有限候选集，UE 基于信道互易性确定上行预编码矩阵。若信道互易性足够好，UE 可以获得较优的上行预编码，相对于基于码本的传输方案，可以节省预编码指示的开销，同时获得更好的性能。</p><p>上行 PUSCH ，基于非码本传输的总体流程示意，如下图所示：</p><ol><li>UE测量下行参考信号，获得候选的上行预编码矩阵，利用他们对用于非码本上行传输方案的 SRS 进行预编码后将其发送给基站。</li><li>基站根据 UE 发送 的SRS 进行上行信道检测，对 UE 进行资源调度，确定出上行传输对应的 SRS 资源和上行传输的 MCS 等级等，并通知 UE。其中上行传输对应的 SRS 资源通过 SRI 指示给 UE。</li><li>UE 根据基站发送的 MSC 对数据进行调制编码，并利用 SRI 确定数据的预编码和传输层数，对数据进行预编码后进行数据的发送。非码本上行传输方案下的 PUSCH 解调惨老信号 于PUSCH 的数据采用相同的预编码方式。</li><li>基站根据解调参考信号估计上行信道，进行数据检测。</li></ol><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p3-非码本传输.png" alt></p><p>对于非码本上行传输方案，基站可以为 UE 配置 1 个用于上行 CSI 获取的 SRS 资源集，包含 1~4 个 SRS 资源，每个 SRS 资源包含 1 个SRS 端口。SRI 可以指示一个或多个 SRS 资源，用于 PUSCH 预编码的确定。SRI 指示的 SRS 资源数即为 PUSCH 传输的流数，PUSCH 的传输层于 SRI 指示的 SRS 资源一一对应。<br>SRS 资源集配置中，关联一个 NZP CSI-RS 资源的 ID。</p><h2 id="PUSCH-信道预编码"><a href="#PUSCH-信道预编码" class="headerlink" title="PUSCH 信道预编码"></a>PUSCH 信道预编码</h2><p>根据如下公式对向量块$[y^{(0)}(i),…,y^{(v-1)}(i)]^{T},i = 0,1,…,M_{symb}^{layer}-1$ 进行预编码处理：</p><script type="math/tex;mode=display">\left[\begin{matrix} z^{(0)}(i)\\ \vdots\\ z^{(p-1)}(i) \end{matrix} \right]=W\left[\begin{matrix} y^{(0)}(i)\\ \vdots \\ y^{(p-1)}(i) \end{matrix} \right]</script><p>其中 $i = 0,1,…,M_{symb}^{ap} -1, M_{symb}^{ap} =M_{symb}^{layer}$ 。</p><p>RRC 参数如下：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txConfig				ENUMERATED &#123;codebook,nonCodebook&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于基于非码本的传输，预编码矩阵<strong>W</strong> 为单位矩阵。<br>对于基于码本的传输，预编码矩阵<strong>W</strong>：</p><ul><li><p>When number of layer = 1, number of antenna port = 1，<strong>W</strong> = 1。</p></li><li><p>When number of layer $\geq$ 1 and number of antenna port $\geq$ 2 ，</p><p>根据DCI 0-1中的 “Precoding information and number of layers” 确定预编码矩阵<strong>W</strong>(参考如下表格)：</p><blockquote><p>[TS 38.211 Table 6.3.1.5-1]<br>[TS 38.211 Table 6.3.1.5-2]<br>[TS 38.211 Table 6.3.1.5-3]<br>[TS 38.211 Table 6.3.1.5-4]<br>[TS 38.211 Table 6.3.1.5-5]<br>[TS 38.211 Table 6.3.1.5-6]<br>[TS 38.211 Table 6.3.1.5-7]</p></blockquote></li></ul><p>按照层数，天线端口数，是否配置变换预编码，三者的参数，选取预编码矩阵，总结成如下表格：</p><div class="table-container"><table><thead><tr><th>Number of Layers</th><th>Number of Antenna</th><th>Transform Precoding</th><th>Precoding Matrix</th></tr></thead><tbody><tr><td>1</td><td>2</td><td></td><td>211 Table 6.3.1.5-1</td></tr><tr><td>1</td><td>4</td><td>enabled</td><td>211 Table 6.3.1.5-2</td></tr><tr><td>1</td><td>4</td><td>disabled</td><td>211 Table 6.3.1.5-3</td></tr><tr><td>2</td><td>2</td><td>disabled</td><td>211 Table 6.3.1.5-4</td></tr><tr><td>2</td><td>4</td><td>disabled</td><td>211 Table 6.3.1.5-5</td></tr><tr><td>3</td><td>4</td><td>disabled</td><td>211 Table 6.3.1.5-6</td></tr><tr><td>4</td><td>4</td><td>disabled</td><td>211 Table 6.3.1.5-7</td></tr></tbody></table></div><h1 id="TS-38-214协议补充"><a href="#TS-38-214协议补充" class="headerlink" title="TS 38.214协议补充"></a>TS 38.214协议补充</h1><h2 id="1-下行链路的功率分配"><a href="#1-下行链路的功率分配" class="headerlink" title="1 下行链路的功率分配"></a>1 下行链路的功率分配</h2><p>下行传输的EPRE (Energy per resource element) 由基站确定。</p><ul><li>对于测量SS-RSRP，SS-RSRQ，SS-SINR来说，UE会假定整个带宽上的EPRE是恒定的。</li><li>对于测量SS-RSRP，SS-RSRQ，SS-SINR来说，UE会假定不同的SS/PBCH承载的SSS上的EPRE也是恒定的。</li><li>对于测量SS-RSRP，SS-RSRQ，SS-SINR来说，UE会假定SSS上的EPRE和 PBCH-DMRS上的EPRE之比为0 dB。</li><li>对于CSI-RSRP，CSI-RSRQ，CSI-SINR测量来说，UE会假定同一端口下给CSI所配置的所有下行带宽的EPRE是恒定的；所配置所有OFDM上的EPRE也是恒定的。</li></ul><p>下行SS/PBCH块上SSS 的EPRE可以从高层配置的SS/PBCH下行发送功率参数（<em>SS-PBCH-BlockPower</em>）得到。下行SSS传输功率被定义为系统带宽内所有承载了SSS的RE上的功率的线性平均值（单位[W]）。对于一个小区来讲，UE假定PSS EPRE与SSS EPRE比为0dB或者3dB。</p><p>下行CSI-RS的EPRE可以从高层配置的SS/PBCH下行发送功率参数（<em>SS-PBCH-BlockPower</em>）以及CSI-RS功率偏移参数（<em>powerControlOffsetSS</em>）得到。下行参考信号传输功率被定义为系统带宽内所有承载了CSI-RS的RE上的功率的线性平均值（单位[W]）。</p><p>对于PDSCH的解调参考信DMRS而言，UE会根据DCI配置的DMRS CDM组数量（除去数据）在下表中查找PDSCH EPRE与DMRS EPRE比。DMRS的缩放因子 $\beta_{PDSCH}^{DMRS}$ 由 [4, TS 38.211] 给出：$\beta_{PDSCH}^{DMRS}=10^{-\frac{\beta_{DMRS}}{20}}$。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/t1-214-4.1-1.png" alt></p><p>当使用与PDSCH关联的PT-RS端口调度UE时，</p><ul><li>如果UE配置了高层参数 <em>epro-Ratio</em>，根据epre-Ratio，表4.1-2给出了PT-RS端口的每个RE的每层PT-RS EPRE与PDSCH EPRE的比率（$ρ_{PTRS}$），PTRS的缩放因子由 [4, TS 38.211] 给出：$\beta_{PTRS}=10^{\frac{\rho_{PTRS}}{20}}$；</li><li>否则，如果没有在表4.1-2配置，则UE将假定<em>epro-Ratio</em> 设置为状态 0 ；</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/t2-214-4.1-2.png" alt></p><h2 id="2-物理下行链路共享信道相关流程"><a href="#2-物理下行链路共享信道相关流程" class="headerlink" title="2 物理下行链路共享信道相关流程"></a>2 物理下行链路共享信道相关流程</h2><h3 id="2-1-UE-用于接收物理下行链路共享信道的过程"><a href="#2-1-UE-用于接收物理下行链路共享信道的过程" class="headerlink" title="2.1 UE 用于接收物理下行链路共享信道的过程"></a>2.1 UE 用于接收物理下行链路共享信道的过程</h3><p>对于下行链路，UE 支持每个小区最多16 个HARQ 进程。UE 可以假设的进程的数量最多将用于下行链路，通过更高层参数 <em>nrofHARQ-processesForPDSCH</em> 分别为每个小区配置给UE，并且当没有提供配置时，UE 默认的8 个进程。</p><h4 id="2-1-1-传输方案"><a href="#2-1-1-传输方案" class="headerlink" title="2.1.1 传输方案"></a>2.1.1 传输方案</h4><p>PDSCH仅定义了一种传输方案，并且用于所有的PDSCH传输。<br>对于PDSCH传输方案1，UE可以假设将在天线端口 1000-1011 上多大 8 个传输层执行PDSCH 上的 gNB 传输 [参考 TS 38.211]</p><h3 id="2-1-2-资源分配"><a href="#2-1-2-资源分配" class="headerlink" title="2.1.2 资源分配"></a>2.1.2 资源分配</h3><h4 id="2-1-2-1-时域资源"><a href="#2-1-2-1-时域资源" class="headerlink" title="2.1.2.1 时域资源"></a>2.1.2.1 时域资源</h4><p>PDSCH时域资源的位置参考如下表格，分为mapping Type A 和mapping Type B 两种：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/t3-214-5.1.2.1-1.png" alt></p><p>其中：</p><ul><li><em>S</em> 为PDSCH在时隙中的开始符号</li><li><em>L</em> 为PDSCH在时隙中的持续时间</li></ul><p><strong>PDSCH 信道重复发送</strong>：</p><p>当 UE 配置为 aggregationFactorDL &gt; 1 时，在 aggregationFactotDL 连续时隙上应用相同的符号分配。UE 可以预期在每个 aggregationFactorDL 连续时隙中的每个分配符号内重复发送 TB ，并且 PDSCH 限于单层传输，根据 [TS 38.214 Table 5.1.2.1-2] 确定要应用于 TB 的 $n^{th}$ 传输时刻的冗余版本。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/t4-214-5.1.2.1-2.png" alt></p><p>如果调度 PDSCH 的 PDCCH 在同一个时隙内被接受，并且不在时隙的前三个符号内，则不期望 UE 在时隙中接收 mapping Type A 的 PDSCH。<br>如果调度PDSCH 的 PDCCH 的第一符号是在比 PDSCH 时域资源分配中指示的第一符号晚的符号中接收到的，则不期望UE在时隙中接收 mapping Type A 的 PDSCH。</p><h5 id="2-1-2-1-1-确定用于PDSCH的资源分配表"><a href="#2-1-2-1-1-确定用于PDSCH的资源分配表" class="headerlink" title="2.1.2.1.1 确定用于PDSCH的资源分配表"></a>2.1.2.1.1 确定用于PDSCH的资源分配表</h5><p>[Table 5.1.2.1.1-1~1A] 中定义了要应用的 PDSCH 时域资源分配配置。如果上层参数 <em>pdsch-TimeDomainAllocationList or Pdsch-TimeDomainAllocationList-ForDCIFormat1_2</em> 配置了，则使用相应的资源分配配置；如果为配置则使用[Table 5.1.2.1.1-2~5] 中默认的A B C 三种表格。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/t5-214-5.1.2.1.1-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/t6-214-5.1.2.1.1-2.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/t7-214-5.1.2.1.1-3.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/t8-214-5.1.2.1.1-4.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/t9-214-5.1.2.1.1-4.png" alt></p><h4 id="5-1-2-2-频域资源分配"><a href="#5-1-2-2-频域资源分配" class="headerlink" title="5.1.2.2 频域资源分配"></a>5.1.2.2 频域资源分配</h4><p>和 LTE 类似，NR 的 PDSCH 信道频域资源分配，支持基于位图分配和基于RIV的分配 (Type 0 和 Type 1)，不再支持比较复杂的 LTE Type 1 型支持分配。</p><p>UE 应当假设当接收到具有 DCI 格式 1_0 的调度的 PDSCH，则使用下行链路资源分配 Type 1。</p><p>如果调度DCI 被配置为通过将pdsch-Config 中的更高层参数 <em>resourceAllocation</em> 设置为<em>‘dynamicswitch’</em>来指示下行链路资源分配类型作为频域资源分配字段的一部分，则UE 将根据此DCI 字段定义配置使用下行链路资源分配 Type 0 或 Type 1。否则，UE 将使用由更高层参数<em>resourceAllocation</em> 定义的下行链路频率资源分配类型。</p><p>对于在任何类型的 PDCCH 公共搜索空间中以DCI format 1_0 调度的PDSCH，无论哪个BWP是active BWP，RB 编号从其中接收 DCI 的CORESET 的最低 RB 开始。</p><p>对于其他调度的PDSCH：</p><ul><li>如果在调度DCI 中<strong>未配置</strong>带宽部分指示符字段，则在 UE 的有效带宽部分内确定用于下行链路 Type 0 和 Type 1 资源分配的RB 索引。</li><li>如果在调度DCI 中<strong>配置</strong>带宽部分指示符字段，则在DCI 中由带宽部分指示符字段值指示的UE 的带宽部分内确定用于下行链路Type 0 和 Type 1 资源分配的RB 索引。</li></ul><p>UE 在检测到预期用于UE 的PDCCH 时将首先确定下行链路载波带宽部分，然后确定带宽部分内的资源分配。</p><h5 id="2-1-2-2-1-下行链路资源分配-Type-0-bitmap"><a href="#2-1-2-2-1-下行链路资源分配-Type-0-bitmap" class="headerlink" title="2.1.2.2.1 下行链路资源分配 Type 0 (bitmap)"></a>2.1.2.2.1 下行链路资源分配 Type 0 (bitmap)</h5><p>在 Type 0 的下行链路资源分配中，资源块分配信息包括指示分配给调度的UE的资源块组 (RBG , Resource Block Groups )的bitmap，其中RBG是由较高层参数 <em>rbg-Size</em> 定义的一组连续的虚拟资源块。 由<em>PDSCH-Config</em>配置，BWP的大小如 [Table 5.1.2.2.1-1] 中所定义。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/t10-214-5.1.2.2.1-1.png" alt></p><p>RBG 总数 ($N_{RBG}$) 对于大小为 $N_{BWP,i}^{size}$ 个PRB 的下行BWP i ，由下式给出：</p><script type="math/tex;mode=display">N_{RBG}=\lceil (N_{BWP,i}^{size}+(N_{BWP,i}^{start}modP))/p \rceil</script><p>其中：</p><ul><li>第一个 RBG 的大小是 $RBG_{0}^{size} = P- N_{BWP,i}^{start} mod P$；</li><li>最后一个 RBG 的大小是 $RBG_{last}^{size} = (N_{BWP,i}^{size}+N_{BWP,i}^{start} )mod P$，或者就是恰好为 $P$ ;</li><li>其他的RBG的大小是 <em>P</em> 。</li></ul><p>bitmap 的大小是 $N_{RBG}$ bits，并且每一个 RBG 都有一个bitmap 位，因此每个 RBG 都是可寻址的。RBG 应该是按照频率增加的顺序排序索引的，并从 BWP 的 最低频率开始。RBG bitmap 的映射顺序为：RBG 0 到 $RBG_{N_{RBG}}-1$，按照顺序映射从 bitmap 的 MSB 到 LSB。如果 对应的 bitmap 比特位是 1 ，则代表该 RBG 分配给 UE，否则反之。</p><h5 id="2-1-2-2-2-下行链路资源分配-Type-1-RIV"><a href="#2-1-2-2-2-下行链路资源分配-Type-1-RIV" class="headerlink" title="2.1.2.2.2 下行链路资源分配 Type 1 (RIV)"></a>2.1.2.2.2 下行链路资源分配 Type 1 (RIV)</h5><p>在 Type 1 的下行链路资源分配中，资源块指派信息向调度的 UE 指示在有效带宽部分大小 (三者中的一种情况$N_{BWP}^{size},N_{CORESET}^{size},N_{BWP,initial}^{size}$) 内的一组连续分配的非交织或交织的虚拟资源块。</p><p>下行链路 Type 1 资源分配字段包括与起始虚拟资源块 ($RB_{start}$) 相对应的资源指示值 (RIV , Resource Indication Value)，以及连续分配的资源块的长度 $L_{RBs}$。RIV 的最大长度和BWP带宽相关，由下式给出：</p><p>$if\quad (L_{RBs}-1)\leq \lfloor N_{BWP}^{size}/2 \rfloor \quad then$<br>$\quad RIV=N_{BWP}^{size}(L_{RBs}-1)+RB_{start}$<br>$else$<br>$\quad RIV=N_{BWP}^{size}(N_{BWP}^{size}-L_{RBs}+1)+(N_{BWP}^{size}-1-RB_{start})$</p><p>其中 $L_{RBs} \geq 1$ 并且 不应该超过 $N_{BWP}^{size} - RB_{start}$</p><p>两种频域资源分配方式比较：和 Type 0 相比，Type 1 分配的频域资源比较 “精确” ，最小粒度达到了 RB 级，缺点是只能分配连续的 RB 资源，不利于基于频选资源调度。</p><p><strong>DCI size 对齐后的调度</strong></p><p>当出现 DCI size 对齐操作后，在 USS 中使用DCI 1_0 调度的频域资源 (当前激活BWP中)，但DCI 1_0 长度来自于 CORESET 0 。 在这种情况下，如果当前激活BWP带宽大于CORESET 0 ，调度的频域资源要进行等比例 “放大”，放大系数 <em>K</em> 。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p1-摘抄1.png" alt></p><p>RIV 有如下式子获得：</p><p>$if\quad (L’_{RBs}-1)\leq \lfloor N_{BWP}^{initial}/2 \rfloor \quad then$<br>$\quad RIV=N_{BWP}^{initial}(L’_{RBs}-1)+RB’_{start}$<br>$else$<br>$\quad RIV=N_{BWP}^{initial}(N_{BWP}^{initial}-L’_{RBs}+1)+(N_{BWP}^{initial}-1-RB’_{start})$</p><p>其中：$L’_{RBs}=L_{RBs}/K,RB;_{start}=RB_{start}/k,L’_{RBs} \leq N_{BWP}^{initial}-RB’_{start}$</p><p>实际分配 RB 资源乘以系数 <em>K</em> ：</p><script type="math/tex;mode=display">RB_{start}=0,K,2\cdot K,...,(N_{BWP}^{initial}-1)\cdot K \\L_{RBs} = K,2\cdot K,...,N_{BWP}^{initial}\cdot K</script><h4 id="2-1-2-3-PDSCH信道PRB-bundling"><a href="#2-1-2-3-PDSCH信道PRB-bundling" class="headerlink" title="2.1.2.3 PDSCH信道PRB bundling"></a>2.1.2.3 PDSCH信道PRB bundling</h4><p>LTE中，下行 PDSCH 信道在分配的全部频域上使用相同的预编码；NR 中 ，PDSCH 信道在频域带宽很大，支持频域选择的预编码，即频域上不同的 PRB 范围可以采用不同的预编码矩阵。<br>采用相同预编码矩阵的一组 PRB 称为一个 PRG (Precoding Resource Block Group)，PRG的大小也成为 precoding granularity，第 <em>i</em> 个 BWP 内，预编码粒度用 $P’_{BWP,i}$ 表示；<br>$P’_{BWP,i}$ 通过高层信令配置，范围为 {2，4，wideband}</p><ul><li>$P’_{BWP,i}$ 配置为 wideband 时，UE只能接受连续RB分配，所有资源使用相同预编码；</li><li>$P’_{BWP,i}$ 配置为 2 / 4 时，BWP内按照 $P’_{BWP,i}$ 进行 RB 组分段，类似 BWP内的 RBG 分段</li></ul><p>DCI 1_0 调度时，$P’_{BWP,i} = 2$<br>DCI 1_1 调度时，$P’_{BWP,i}$ 和高层配置以及 DCI 字段相关，参考我之前PDSCH 的 PRB bundling 笔记。</p><h3 id="2-1-3-调制阶数，目标码率，冗余版本，传输块大小确定"><a href="#2-1-3-调制阶数，目标码率，冗余版本，传输块大小确定" class="headerlink" title="2.1.3 调制阶数，目标码率，冗余版本，传输块大小确定"></a>2.1.3 调制阶数，目标码率，冗余版本，传输块大小确定</h3><p>为了确定 PDSCH 的调制阶数，目标码率和传输块的大小，UE 应该<br>首先</p><ul><li>读取 DCI 中 5 bits MCS 字段 ($I_{MCS}$)，根据 [TS 38.214 5.1.3.1] 中定义的过程确定调制阶数 ($Q_m$) 和 目标码率 (R)</li><li>读取 DCI 中的冗余版本字段 (rv) 以确定冗余版本。<br>其次</li><li>UE 应使用层数 (<em>v</em>)，速率匹配之前分配的 PRB 总数 ($n_{PRB}$) ，以根据 [TS 38.214 5.1.3.2] 中定义的过程确定传输块的大小</li></ul><p>如果有效信道码率高于 0.95，则 UE 可以在初始传输中跳过解码传输块，其中有效信道码率被定义为下行链路信息比特 (包括CRC) 的数量除以PDSCH上物理信道比特数。</p><h4 id="2-1-3-1-调制阶数和目标码率确定"><a href="#2-1-3-1-调制阶数和目标码率确定" class="headerlink" title="2.1.3.1 调制阶数和目标码率确定"></a>2.1.3.1 调制阶数和目标码率确定</h4><p>对于由C-RNTI, MCS-C-RNTI, TC-RNTI, CS-RNTI, SI-RNTI, RA-RNTI, MsgB-RNTI, or P-RNTI 加扰的 DCI format 1_0 1_1 1_2 PDCCH 调度的PDSCH，或者对于使用更高层提供的PDSCH配置 <em>SPS-Config</em> 进行调度而没有相应的PDCCH传输的PDSCH。</p><p>如果 <em>PDSCH-Config</em> 给出的高层参数 <em>mcs-Table-ForDCIFormal1_2</em> 设置为 ‘<em>qam256</em>‘，则PDSCH 由 DCI format 1_2 的PDCCH 调度，并且 CRC 由 C-RNTI 加扰</p><ul><li>UE 应使用 <em>$I_{MCS}$</em> 和 [Table 5.1.3.1-2] 来确定PDSCH中使用的调制阶数 ($Q_m$) 和目标码率 (R)。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/t11-214-5.1.3.1-2.png" alt></p><p>再如果 UE 没有配置 MCS-C-RNTI，PDSCH-Config 给出的高层参数 <em>mcs-Table-ForDCIFormal1_2</em> 设置为 ‘<em>qam64LowSE</em>‘，且 PDSCH 由 DCI format 1_2 的PDCCH 调度，并且 CRC 由 C-RNTI 加扰</p><ul><li>UE 应使用 <em>$I_{MCS}$</em> 和 [Table 5.1.3.1-3] 来确定PDSCH中使用的调制阶数 ($Q_m$) 和目标码率 (R)。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/t12-214-5.1.3.1-3.png" alt></p><p>如果 <em>PDSCH-Config</em> 给出的高层参数 <em>mcs-Table</em> 设置为 ‘qam256’，则PDSCH 由 DCI format 1_1 的PDCCH 调度，并且 CRC 由 C-RNTI 加扰</p><ul><li>UE 应使用 <em>$I_{MCS}$</em> 和 [Table 5.1.3.1-2] 来确定PDSCH中使用的调制阶数 ($Q_m$) 和目标码率 (R)。</li></ul><p>再如果 UE 没有配置 MCS-C-RNTI，PDSCH-Config 给出的高层参数 <em>mcs-Table</em> 设置为 ‘<em>qam64LowSE</em>‘，且 PDSCH 由 DCI format 1_2 (UE-specific search space) 的PDCCH 调度，并且 CRC 由 C-RNTI 加扰</p><ul><li>UE 应使用 <em>$I_{MCS}$</em> 和 [Table 5.1.3.1-3] 来确定PDSCH中使用的调制阶数 ($Q_m$) 和目标码率 (R)。</li></ul><p>再如果 UE 配置 MCS-C-RNTI，且 PDSCH 由 PDCCH 调度，并且 CRC 由 MCS-C-RNTI 加扰</p><ul><li>UE 应使用 <em>$I_{MCS}$</em> 和 [Table 5.1.3.1-3] 来确定PDSCH中使用的调制阶数 ($Q_m$) 和目标码率 (R)。</li></ul><p>再如果 UE 未配置由<em>SPS-config</em> 给出的高层参数 <em>mcs-Table</em> ，由<em>PDSCH-Config</em> 给出的高层参数 <em>mcs-Table-ForDCIFormal1_2</em> 设置为 ‘qam256’，则PDSCH 由 DCI format 1_2 的PDCCH 调度，并且 CRC 由 CS-RNTI 加扰</p><ul><li>UE 应使用 <em>$I_{MCS}$</em> 和 [Table 5.1.3.1-2] 来确定PDSCH中使用的调制阶数 ($Q_m$) 和目标码率 (R)。</li></ul><p>再如果 UE 未配置由<em>SPS-config</em> 给出的高层参数 <em>mcs-Table</em> ，由<em>PDSCH-Config</em> 给出的高层参数 <em>mcs-Table</em> 设置为 ‘qam256’，</p><ul><li>如果 PDSCH 由 DCI format 1_1 (CS-RNTI 加扰) 的PDCCH 调度，或者</li><li>PDSCH 调度的没有相关的使用 <em>SPS-Config</em> 的PDSCH 传输<ul><li>UE 应使用 <em>$I_{MCS}$</em> 和 [Table 5.1.3.1-2] 来确定PDSCH中使用的调制阶数 ($Q_m$) 和目标码率 (R)。</li></ul></li></ul><p>再如果 UE 配置由<em>SPS-config</em> 给出的高层参数 <em>mcs-Table</em> ，并且 设置为 ‘<em>qam64LowSE</em>‘</p><ul><li>如果 PDSCH 由 (CS-RNTI 加扰) 的PDCCH调度，或者</li><li>PDSCH 调度的没有相关的使用 <em>SPS-Config</em> 的PDSCH 传输<ul><li>UE 应使用 <em>$I_{MCS}$</em> 和 [Table 5.1.3.1-3] 来确定PDSCH中使用的调制阶数 ($Q_m$) 和目标码率 (R)。</li></ul></li></ul><p>否则，</p><ul><li>UE 应使用 <em>$I_{MCS}$</em> 和 [Table 5.1.3.1-1] 来确定PDSCH中使用的调制阶数 ($Q_m$) 和目标码率 (R)。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-214%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/t13-214-5.1.3.1-1.png" alt></p><p>不期望UE 解码用 P-RNTI，RA-RNTI，SI-RNTI 和 $Q_m&gt; 2$ 调度的PDSCH。</p><h4 id="2-1-3-2-传输块大小确定"><a href="#2-1-3-2-传输块大小确定" class="headerlink" title="2.1.3.2 传输块大小确定"></a>2.1.3.2 传输块大小确定</h4><p>在高层参数 <em>maxNroCodeWordsScheduledByDCI</em> 指示启用两个码字传输的情况下，如果 $I_{MSC}=26，rv_{id}=1$，则DCI format 1_1 禁用传输块，否则传输块启用。如果两个传输块都被启用，则传输块1/2，分别映射到码字 0/1。如果仅启用一个传输块，则启用的传输块映射到第一个码字。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>TS 38.214</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-213协议补充</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:36 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="TS-38-213-部分补充"><a href="#TS-38-213-部分补充" class="headerlink" title="TS 38.213 部分补充"></a>TS 38.213 部分补充</h1><h2 id="1-上行功率控制"><a href="#1-上行功率控制" class="headerlink" title="1. 上行功率控制"></a>1. 上行功率控制</h2><p>上行的主要几个信道/信号</p><ol><li>PUSCH</li><li>PUCCH</li><li>SRS</li><li>PRACH</li></ol><h3 id="1-1-PUSCH"><a href="#1-1-PUSCH" class="headerlink" title="1.1 PUSCH"></a>1.1 PUSCH</h3><p>UE首先需要基于$P_{PUSCH,b,f,c}(i,j,q_{d},l)$ 线性映射一个值 $P‘_{PUSCH,b,f,c}(i,j,q_{d},l)$</p><ul><li><em>b</em>：BWP</li><li><em>f</em>：carrier</li><li><em>c</em>：serving</li><li><em>j</em>：parameter configuration index</li><li><em>i</em> ：transmission occasion</li></ul><p>$P_{PUSCH,b,f,c}(i,j,q_{d},l)$ 取下列两项较小的值</p><ul><li>$P_{CMAX,f,c}(i)$，UE 的最大传输功率，由 [8-1, TS 38.101-1~2] 定义；</li><li>$P_{O_PUSCH,b,f,c}(j)+10log_{10}(2^{\mu}M_{RB,b,f,c}^{PUSCH}(i))+\alpha_{b,f,c}(j)PL_{b,f,c}(q_d)+\Delta_{TF,b,f,c}(i)+f_{b,f,c}(i,l)$</li></ul><p>参数说明：</p><ul><li>$P_{O_PUSCH,b,f,c}(j)$ 是 $P_{O_NOMINAL_PUSCH,f,c}(j)$ 和 $P_{O_UE_PUSCH,b,f,c}(j)$之和，由高层配置，具体见协议(下同)；</li><li>$\alpha_{b,f,c}(j)$ 需要高层配置，否则为1；</li><li>$M_{RB,b,f,c}^{PUSCH}(i))$ 是PUSCH资源的带宽，即RB数目[4,TS 38.211]</li><li>$PL_{b,f,c}(q_d)$ 是下行路径损耗估计；</li><li>$\Delta_{TF,b,f,c}(i)$ 由高层配置。</li></ul><h3 id="1-2-PUCCH"><a href="#1-2-PUCCH" class="headerlink" title="1.2 PUCCH"></a>1.2 PUCCH</h3><p>$P_{PUCCH,b,f,c}(i,q_u,q_{d},l)$ 取下列两项较小的值：</p><ul><li>$P_{CMAX,f,c}(i)$，UE的最大传输功率，由 [8-1, TS 38.101-1~2] 定义；</li><li>$P_{O_PUCCH,b,f,c}(q_u)+10log_{10}(2^{\mu}M_{RB,b,f,c}^{PUCCH}(i))+PL_{b,f,c}(q_d)+\Delta_{F_PUCCH(F)}+\Delta_{TF,b,f,c}(i)+g_{b,f,c}(i,l)$</li></ul><p>PUCCH的参数类似于PUSCH，具体的配置取决协议。</p><h3 id="1-3-SRS"><a href="#1-3-SRS" class="headerlink" title="1.3 SRS"></a>1.3 SRS</h3><p>$P_{SRS,b,f,c}(i,q_s,l)$ 取下列两项较小的值：</p><ul><li>$P_{CMAX,f,c}(i)$，UE的最大传输功率，由 [8-1, TS 38.101-1~2] 定义；</li><li>$P_{O_SRS,b,f,c}(q_s)+10log_{10}(2^{\mu}M_{RB,b,f,c}^{SRS}(i))+\alpha_{b,f,c}(q_s)PL_{b,f,c}(q_d)+h_{b,f,c}(i,l)$</li></ul><p>同上，具体的配置取决协议。</p><h3 id="1-4-PRACH"><a href="#1-4-PRACH" class="headerlink" title="1.4 PRACH"></a>1.4 PRACH</h3><p>$P_{PRACH,b,f,c}(i)=min\{P_{CMAX,f,c}(i),P_{PRACH,target,f,c}+PL_{b,f,c}\}$</p><p>其中：</p><ul><li>$P_{CMAX,f,c}(i)$ 是UE配置的最大输出功率，由 [8-1. TS 38.101-1~2]给出。</li><li>$P_{PRACH,target,f,c}$ 为PRACH 目标接收功率 <em>PREAMBLE_RECEIVED_TARGET_POWER</em> 由[11. TS 38.321] 给出计算公式：<em>PREAMBLE_RECEIVED_TARGET_POWER</em> = <em>preambleReceivedTargetPower</em> + <em>DELTA_PREAMBLE</em> + <em>(PREAMBLE_POWER_RAMPING_COUNTER -1)</em> <em></em>PREAMBLE_POWER_RAMPING_STEP*<ul><li><em>preambleReceivedTargetPower</em> 由参数 <em>preambleReceivedTargetPower</em> 给出</li><li><em>DELTA_PREAMBLE</em>可由[TS 38.321 Table 7.3-1~2] 获得</li><li><em>PREAMBLE_POWER_RAMPING_COUNTER</em> 对初始传输为1，依据重传次数自增一</li><li><em>PREAMBLE_POWER_RAMPING_STEP</em> 由参数 <em>powerRampingStep</em> 给出<br>（以上两条是为了功率攀升而设定的参数）</li></ul></li></ul><h2 id="2-用于监控-Type0-PDCCH-公共搜索空间的UE过程"><a href="#2-用于监控-Type0-PDCCH-公共搜索空间的UE过程" class="headerlink" title="2 用于监控 Type0-PDCCH 公共搜索空间的UE过程"></a>2 用于监控 Type0-PDCCH 公共搜索空间的UE过程</h2><p>其大部分的内容SSB中描述过，以下补充一些内容。</p><h3 id="2-1-简述"><a href="#2-1-简述" class="headerlink" title="2.1 简述"></a>2.1 简述</h3><p>UE获得了SSB信息后，MIB信息有限，还不足以驻留小区和进一步发起初始接入，UE还需要得到一些“必备”的系统信息SIB，这个系统信息在NR中被称为RMSI，可以认为SIB1。<br>NR中的SIB1信息，通过下行PDCCH信道发送，而PDSCH信道需要PDCCH信道的DCI来调度。UE需要在MIB中得到调度RMSI的PDCCH信道信息，在PDCCH上进行盲检，获得RMSI。MIB中通过8bit的<em>pdcch-ConfigSIB1</em>字段，指示UE获取RMSI调度的PDCCH的信息。</p><p>大致的过程如下图所描述：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p1-RMSI.png" alt></p><h3 id="2-2-k-SSB-字段"><a href="#2-2-k-SSB-字段" class="headerlink" title="2.2 $k_{SSB}$ 字段"></a>2.2 $k_{SSB}$ 字段</h3><p>SSB部分学习的描述了$k_{SSB}$，他的主要作用就是标记 SSB #0子载波与最近的CRB n #0 子载波的偏移量。<br>$k_{SSB}$的4bits LSB 由 MIB参数中的 ssb-SubcarrerOffset 给出。<br>对于SSB类型B (FR2)，即（μ= 3 or 4）来说, $k_{SSB}$ = {0,…,11}, 4 bits足够。<br>对于SSB类型A (FR1)，即（μ= 0 or 1）来说, $ k_{SSB}$ = {0,…,23}, 4 bits不够，需要5 bits来表示，因此使用PBCH payload中$a_{\overline A+5}$来表示高比特位。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p2-频移.png" alt></p><p>NR小区中，可以在不同频域位置有多个 SSB (用于终端测量)，而并不需要每个SSB都有其指向的 CORESET 0 。</p><p>如果再空闲状态下，当UE搜索到的SSB (没有指向CORESET 0)，UE期望基站最好能够通知UE下一个的SSB(有指向CORESET 0 )，以便于UE快速监听到。$K_{ssb}$ 字段不只是描述了RE级别的偏移，也起到了这个作用。</p><p>UE根据 $K_{ssb}$ 判定 Type0-PDCCH 公共搜索空间是否存在。若：</p><ul><li>$K_{ssb} &gt; 23,FR1$</li><li>$K_{ssb} &gt; 11,FR1$</li></ul><p>则：当前 SSB对应的Type0-PDCCH公共搜索空间不存在</p><p>UE通过 $K_{ssb}$ 发现当前Type0-PDCCH公共搜索空间不存在时，可以通过 $K_{ssb}$的值，在最近的GSCN上找下一个SSB 上的 RMSI 的搜索空间。当：</p><script type="math/tex;mode=display">24\leq k_{SSB} \leq 29 \quad FR1\quad 12\leq k_{SSB} \leq 13 \quad FR2</script><p>则下一个 SSB 对应的GSCN上频点 $N_{GSCN}^{Reference}+N_{GSCN}^{Offect}$</p><p>其中：<br>$N_{GSCN}^{Reference}$：当前SSB的GSCN上的频点<br>$N_{GSCN}^{Offect}$：下一个SSB的GSCN频点偏移，根据 $k_{SSB}$ 和MIB 中的 <em>pdcch-ConfigSIB1</em>，共同确定。参考以下表格：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/T1-213-13.16.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/T2-213-13.17.png" alt></p><p>如果在第二个SSB 上还是没有提供 RMSI CORESET 0，则UE忽略执行小区搜索的GSCN信息。</p><p>当 $k_{SSB}=31\quad FR1\quad k_{SSB}=15\quad FR2$ ，则表示SSB所在的GSCN一段频点范围(见下)内的SSB，都没有 CORESET 0；</p><script type="math/tex;mode=display">[N_{GSCN}^{Reference}-N_{GSCN}^{Start},N_{GSCN}^{Reference}+N_{GSCN}^{End}]</script><p>其中：<br>$N_{GSCN}^{Start}$ 和 $N_{GSCN}^{End}$ 分别为 <em>pdcch-ConfigSIB1</em> 中的<em>controlResourceSetZero</em> 和 <em>searchSpaceZero</em> 决定，也就是其 4 bits MSB 和 4 bits LSB。</p><p>UE 在一个时间周期内，都没有搜索到带 RMSI 的 CORESET 0 的SSB，则UE忽略执行小区搜索的GSCN信息。</p><h3 id="2-3-CORESET-0"><a href="#2-3-CORESET-0" class="headerlink" title="2.3 CORESET 0"></a>2.3 CORESET 0</h3><h4 id="2-3-1-CORESET-0-的时频域资源"><a href="#2-3-1-CORESET-0-的时频域资源" class="headerlink" title="2.3.1 CORESET 0 的时频域资源"></a>2.3.1 CORESET 0 的时频域资源</h4><p>CORESET 0的物理时频域资源和SSB之间存在三种复用模式： Pattern1/2/3，如下图所示 (摘抄自春天工作室)：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/P4-复用模式.png" alt></p><p>上图仅为示例，图中的时频域资源未必完全对其。</p><h4 id="2-3-2-CORESET-0-的频域资源"><a href="#2-3-2-CORESET-0-的频域资源" class="headerlink" title="2.3.2 CORESET 0 的频域资源"></a>2.3.2 CORESET 0 的频域资源</h4><p>SSB块和Type0-PDCCH 公共搜索空间的CORESET 0在时频域资源都有较大灵活性，两者之间的对应关系也比较复杂，而要用MIB中有限的 8bits 信息表示两者关系，必须对两者映射关系做一定约束。协议中定义了多种时频域映射组合关系。</p><p>pdcch-ConfigSIB1:</p><ul><li>4 bits MSB，SSB和CORESET 0 的SCS，符号数，PRB offset配置，对应 [TS 38.213 Table 13-1~10]</li><li>4 bits LSB，CORESET 0 的SFN，时隙索引等，时域相关配置，对应 [TS 38.213 Table 13-11~15]</li></ul><p>CORESET 0 的频域资源：Pattern1/2/3</p><ul><li>Pattern 1</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p5-pattern1例子一.png" alt></p><p>若 index = 0；</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p8-pattern1例子二.png" alt></p><p>若 index = 1;</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p9-pattern1例子三.png" alt></p><ul><li>pattern 2</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p6-pattern2例子一.png" alt></p><p>若 index = 6，index = 7;</p><p>$k_{SSB} = 0$</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p10-pattern2例子二.png" alt></p><p>$k_{SSB} &gt; 0$</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p11-pattern2例子三.png" alt></p><ul><li>pattern 3</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p7-pattern3例子一.png" alt></p><p>若 index = 6，index = 7;</p><p>$k_{SSB} = 0$</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p12-pattern3例子二.png" alt></p><p>$k_{SSB} &gt; 0$</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p13-pattern3例子三.png" alt></p><h4 id="2-3-2-CORESET-0-的时域资源"><a href="#2-3-2-CORESET-0-的时域资源" class="headerlink" title="2.3.2 CORESET 0 的时域资源"></a>2.3.2 CORESET 0 的时域资源</h4><p>对于复用pattern 2/3，CNRESET 0的时域分布相对简单明：</p><ol><li>CORESET 0，即Type 0 公共搜索空间周期等于SSB的周期</li><li>CORESET 0 和 SSB在同一个时隙内</li><li>时隙号 $n_c$ 和帧号 $SFN_c$ 在 [TS 38.213 Table 13-13~15] 中定义</li></ol><p>对于复用pattern 1，SSB 和 CORESET 0 时分复用，并且 SSB 在时域上有多个发送时刻，因此CORESET 0 和SSB之间的时域对应关系表达相对复杂，在[TS 38.213] 中定义：对于复用 pattern 1，终端监听 $n_0$ 开始的连续2个时隙。</p><script type="math/tex;mode=display">n_0=(O\cdot 2^{\mu}+\lfloor i\cdot M \rfloor)mod N_{slot}^{frame,\mu}\quad \mu\in \{0,1,2,3\}</script><p>CORESET 0 开始帧号，SFN满足</p><script type="math/tex;mode=display">当\quad \lfloor(O\cdot 2^{\mu}+\lfloor i\cdot M \rfloor)/N_{slot}^{frame,\mu}\rfloor mod 2 = 0 \quad  时\quad SFN_c mod2=0\\当\quad \lfloor(O\cdot 2^{\mu}+\lfloor i\cdot M \rfloor)/N_{slot}^{frame,\mu}\rfloor mod 2 = 1 \quad  时\quad SFN_c mod2=1</script><p>其中：<br><em>i</em> 为 SSB的 index，<em>O</em>，<em>M</em>，在规范中13-11 (FR 1) 到 13-12 (FR2) 表格定义。</p><ul><li>$O\cdot 2^{\mu}$，可以理解为 <em>O</em> ms (绝对时间)，当 $i=0$ 时 (第一个SSB) 所对应的CORESET 0 搜索空间，相对于偶数帧的开始时刻偏移了 <em>O</em> ms<ul><li>FR1时，<em>O</em> 取值为 0，2，5，7</li><li>FR2时，<em>O</em> 取值为 0，2.5，5，7.5</li></ul></li><li><em>N</em>，[TS 38.213 Table 13-11~12] 表中的 Number of search space sets per slot，每个时隙中的搜索空间个数</li><li><em>M</em>，[TS 38.213 Table 13-11~12] 表中的 <em>M</em> ，可以理解为前后两个SSB对应的CORESET 0 搜索空间的间隔，单位为 slot</li></ul><p>以下对应的三种情况 (图片摘自春天工作室)</p><ul><li>情形一</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p14-时域1.png" alt></p><ul><li>情形二</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p15-时域2.png" alt></p><ul><li>情形三</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p16-时域3.png" alt></p><h2 id="3-RMSI-的获取"><a href="#3-RMSI-的获取" class="headerlink" title="3. RMSI 的获取"></a>3. RMSI 的获取</h2><p>通过以下步骤，UE获得了RMSI 的CORESET０的时频域资源，可以在CORESET 0 物理资源对应的Type 0 Common Search Space 使用 SI-RNTI 盲检RMSI的调度信息 (PDCCH信道上发送 SI-RNTI 加扰的DCI 1_0)。</p><h2 id="4-initial-DL-BWP"><a href="#4-initial-DL-BWP" class="headerlink" title="4. initial DL BWP"></a>4. initial DL BWP</h2><p>和LTE不同，NR中由于信道带宽可能会非常大，而UE没有必要支持全部信道带宽范围。因此，NR中频域上引入了 Bandwidth part (BWP) 的概念，UE可以被配置多个DL/UL BWP (BWP 根据UE能力配置，小于等于信道带宽)，UE同时只能工作在一个激活BWP中。NR中，频域资源的分配基于BWP内。</p><p>BWP的配置包括：子载波间隔，频域起始位置，带宽，CP类型;</p><p>UE要根据 CORESET 0 PDCCH 调度 DCI 1_0 得到 RMSI 的PDSCH的频域资源信息，首先要确定初始下行 BWP (Initial DL BWP)，[TS 38.213] 规定：Initial DL BWP 就是 CORESET 0 的频域大小 (子载波间隔，频域位置，连续RB，CP)。</p><h2 id="5-用于报告控制信息的UE过程"><a href="#5-用于报告控制信息的UE过程" class="headerlink" title="5. 用于报告控制信息的UE过程"></a>5. 用于报告控制信息的UE过程</h2><p>对应于协议的第九章 还没有看</p><h2 id="6-用于接收控制信息的UE过程"><a href="#6-用于接收控制信息的UE过程" class="headerlink" title="6. 用于接收控制信息的UE过程"></a>6. 用于接收控制信息的UE过程</h2><p>对应于协议的第十章 还没有看</p><blockquote><p>参考文献<br>公众号：5G菜鸟成长日记，春天工作室<br>网页：<a href="https://mp.weixin.qq.com/s/pYBUorrVeYUedqGJxVi9Xg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/pYBUorrVeYUedqGJxVi9Xg</a><br>博客：<a href="https://blog.csdn.net/milkbusy/article/details/81536306" target="_blank" rel="noopener">https://blog.csdn.net/milkbusy/article/details/81536306</a><br>协议：TS 38.213</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>TS 38.213</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-参考信号学习</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="1-CSI"><a href="#1-CSI" class="headerlink" title="1 CSI"></a>1 CSI</h1><p>与LTE中的CSI-RS类似，在NR中引入CSI-RS(Channel-state information RS)的目的是对信道状态进行评估，UE基于信令配置的CSI-RS参数对CSI-RS进行测量评估从而得到下行信道状态信息并反馈给基站并应用于链路自适应算法中。<br>需要注意的是，LTE中存在Cell-specific RS，所有属于某个cell的UE都可以通过测量CRS来获取下行信道质量；而在NR中，没有了CRS的概念，对下行信道的测量只能通过CSI-RS进行。</p><p>CSI-RS分为 zero-power(ZP)和non-zero-power(NZP) 两种CSI-RS：</p><ul><li>NZP CSI-RS 用于UE专有的下行信道测量</li><li>ZP CSI-RS使用与多个小区之间CSI-RS的协作传输，简单点说就是为了避免与其他小区的CSI-RS 传输的冲撞，将一个小区的下行数据传输中的一些RE设置为ZP CSI-RS(即该RE上为0功率传输)，这样就避开了CSI-RS传输的相互干扰，提高了对下行信道评估的准确性。</li></ul><h2 id="1-1-CSI-配置"><a href="#1-1-CSI-配置" class="headerlink" title="1.1 CSI 配置"></a>1.1 CSI 配置</h2><p>一些重要的配置如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p2-NZP-CSI-resource.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p3-RS-ResourceMapping.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p1-CSI-FrequencyOccuption.png" alt></p><h2 id="1-2-序列生成"><a href="#1-2-序列生成" class="headerlink" title="1.2 序列生成"></a>1.2 序列生成</h2><p>CSI-RS 序列 $r(m)$ 由以下公式定义：</p><script type="math/tex;mode=display">r(m) = \frac{1}{\sqrt{2}}(1-2\cdot c(2m)+j\frac{1}{\sqrt{2}}(1-2\cdot c(2m+1))\\c_{init}=(2^{10}(N_{symb}^{slot}n_{s,f}^{\mu}+l+1)(2n_{ID}+1)+n_{ID})mod2^{31}</script><p>其中：</p><ul><li>$N_{symb}^{slot}$ 为一个时隙中 OFDM 符号的个数</li><li>$n_{s,f}^{\mu}$ 为在子载波间距 $\mu$ 中，当前时隙在系统帧中的序号</li><li>$l$ 为 OFDM 符号 $l$ 在当前时隙中的序号</li><li>$n_{ID}$ 由 <em>NZP-CSI-RS-Resource -&gt; scramblingID</em> 或者 <em>CSI-RS-ResourceConfigMobility -&gt; sequenceGenerationConfig</em> 赋值</li></ul><h2 id="1-3-映射"><a href="#1-3-映射" class="headerlink" title="1.3 映射"></a>1.3 映射</h2><h3 id="1-3-1-原理"><a href="#1-3-1-原理" class="headerlink" title="1.3.1 原理"></a>1.3.1 原理</h3><p>对于配置的每一个CSI-RS，$r(m)$ 被映射到资源单元 $(k,l)_{p,\mu}$ ，根据：</p><script type="math/tex;mode=display">\alpha_{k,l}^{(p,\mu)}=\beta_{CSIRS}w_f(k')\cdot w_t(l')\cdot r_{l,n_{s,f}}(m')\\m'= \lfloor n\alpha \rfloor +k' + \lfloor \frac{\overline k\rho}{N_{sc}^{RB}} \rfloor\\k=nN_{sc}^{RB}+\overline k +k'\\l = \overline l+l'\\ \alpha = \begin{cases} \rho \quad\quad for\quad X=1 \\ 2\rho \quad\quad for \quad X>1 \end{cases}\\n = 0,1,...</script><p>其中：</p><ul><li>$\beta_{CSIRS}$，对于NZP-CSI-RS，由 <em>NZP-CSI-RS-Resource -&gt; powerContorlOffsetSS</em> 决定，对于ZP-CSI-RS， $\beta_{CSIRS} = 0$ ；</li><li>$\rho$ 由 <em>CSI-RS-ResourceMapping -&gt; density</em> 或者 <em>CSI-RS-cellMobility -&gt; density</em> 决定；</li><li>$X$ 由 <em>CSI-RS-ResourceMapping -&gt; nrofPorts</em> 决定，CSI-RS端口个数；</li><li>CSI-RS 的资源块的起始位置和数量由 <em>CSI-RS-ResourceMapping -&gt; freqBand</em> 决定，<em>freqBand</em> 指向了 <em>CSI-FrequencyOccupation</em>，分别由其中的 <em>startingRB , nrofRBs</em> 决定；</li><li>$k$ 为频域上子载波索引，$k$ 的参考点 $k = 0$ 是指 CRB#0 的子载波0的位置 ;</li><li>$k’,l’,w_f{k’},w_t{l’}$ 由表[TS 38.211 7.4.1.5.3-1-7.4.1.5.3-6] 给出，如下所示：</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/t1-211-7.4.1.5.3-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/t2-211-7.4.1.5.3-2~5.png" alt></p><p>其中：</p><ul><li>$l_0,l_1$ 为时域位置，$l_0 \in \{0,…,13\}$ 和 $l_1 \in \{2,…,12\}$ 由 <em>CSI-RS-ResourceMapping -&gt; firstOFDMSysmbolInTimeDomain, firstOFDMSysmbolInTimeDomain2</em> 决定。</li><li>$k_i$ 为频域位置，$k_i$ 由<em>CSI-RS-ResourceMapping -&gt; frequencyDomainAllocation</em> 决定。其中 $k_i$ 由 [TS 38.211 7.4.1.5.3-1]中所在row，以及下面公式决定：<ul><li>$[b_3 \cdots b_0],k_i=f(i)$，对于 [TS 38.211 7.4.1.5.3-1] 中 row = 1</li><li>$[b_{11} \cdots b_0],k_i=f(i)$，对于 [TS 38.211 7.4.1.5.3-1] 中 row = 2</li><li>$[b_2 \cdots b_0],k_i=4f(i)$，对于 [TS 38.211 7.4.1.5.3-1] 中 row = 4</li><li>$[b_5 \cdots b_0],k_i=2f(i)$，对于 [TS 38.211 7.4.1.5.3-1] 中 row = other</li></ul></li></ul><p>上面内容解释：$f(i)$ 中的 $i$ 代表的是 <em>bitmap</em> 第 $i$ 次1的出现的位置是二进制的权值。<br>若row1_FrequencyDomainBitmap=[0001]，则$k_0 = f(1) = 0$；<br>若row2_FrequencyDomainBitmap=[000000000010]，则$k_0=f(1)=1$<br>若row4_FrequencyDomainBitmap=[100]，则$k_0 = 4f(1) = 4\times 2=8$；<br>若row10_FrequencyDomainBitmap=[001110]，则$k_0 =2 f(1) = 2，k_1=2f(2)=2\times 2 = 4,k_2=2f(3)=2\times 4=8$</p><ul><li>$p$ 为发送CSI-RS的天线端口，根据下式得出：</li></ul><script type="math/tex;mode=display">p=3000+s+jL\\j=0,1,...,N/L-1\\s=0,1,...,L-1</script><ul><li>其中：<ul><li>$s$ 由[TS 38.211 7.4.1.5.3-2~5] 中序列索引给出；</li><li>$L \in \{1,2,4,8\}$ 是CDM group 的大小；</li><li>$N$ 是CSI-RS端口数量；</li><li>$j$ 是CDM group index，由[TS 38.211 7.4.1.5.3-1]中给出, CDM group 按照先频域后时域顺序分配编号。</li></ul></li></ul><h3 id="1-3-2-例子"><a href="#1-3-2-例子" class="headerlink" title="1.3.2 例子"></a>1.3.2 例子</h3><h4 id="1-3-2-1-RB内"><a href="#1-3-2-1-RB内" class="headerlink" title="1.3.2.1 RB内"></a>1.3.2.1 RB内</h4><p>采用1.2.1所用的四个例子，更详细的说明映射的时频域位置，以及天线端口。<br>(1) 若row1_FrequencyDomainBitmap=[0001]，firstOFDMSysmbolInTimeDomain = 4<br>(2) 若row2_FrequencyDomainBitmap=[000000000010]，firstOFDMSysmbolInTimeDomain = 4<br>(3) 若row4_FrequencyDomainBitmap=[100]，firstOFDMSysmbolInTimeDomain = 2<br>(4) 若row10_FrequencyDomainBitmap=[001110]，firstOFDMSysmbolInTimeDomain = 2<br>首先先在 [TS 38.211 7.4.1.5.3-1] 中选择需要的参数，如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p4-CSI映射例子.png" alt></p><p><strong>(1) 若row1_FrequencyDomainBitmap=[0001]，firstOFDMSysmbolInTimeDomain = 4</strong></p><ul><li>Density = 3，一个RB内，CSI-RS 出现三次，每个位置间隔4个子载波；</li><li>FrequencyDomainBitmap = [0001]，$k_0 = f(1) = 0$；</li><li>No-CDM，没有采用CDM，只对应一个天线端口3000。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p5-CSI映射1.png" alt></p><p><strong>(2) 若row2_FrequencyDomainBitmap=[000000000010]，firstOFDMSysmbolInTimeDomain = 4</strong></p><ul><li>Density = 1 or 0.5，①一个RB内，CSI-RS 出现一次；②奇数RB，或偶数RB出现，也就是每两个RB出现一次。</li><li>FrequencyDomainBitmap =[000000000010]，$k_0 = f(1) = 1$；</li><li>No-CDM，没有采用CDM，只对应一个天线端口3000。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p6-CSI映射2.png" alt></p><p><strong>(3) 若row4_FrequencyDomainBitmap=[100]，firstOFDMSysmbolInTimeDomain = 2</strong></p><ul><li>Density = 1，一个RB内，一组 CSI-RS CDM码出现一次；</li><li>FrequencyDomainBitmap = [100]，$k_0 = 4f(1) = 4\times2=8$；</li><li>fd-CDM2：一组CDM码占一个符号 $(l’=0)$，两个子载波 $(k’=0,1)$<ul><li>天线端口3000，3001位于符号 2 的 #8-#9 子载波</li><li>天线端口3002，3003位于符号 2 的 #10-#11 子载波</li></ul></li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p7-CSI映射3.png" alt></p><p><strong>(4) 若row10_FrequencyDomainBitmap=[001110]，firstOFDMSysmbolInTimeDomain = 2</strong></p><ul><li>Density = 1，一个RB内，一组 CSI-RS CDM 码 出现一次；</li><li>FrequencyDomainBitmap = [001110]，$k_0 =2 f(1) = 2，k_1=2f(2)=2\times 2 = 4,k_2=2f(3)=2\times 4=8$；</li><li>cdm4-FD2-TD2：一组CDM码占两个符号 $(l’=0,1)$，两个子载波 $(k’=0,1)$<ul><li>天线端口3000，3001位于符号 2 的 #2 - #3 子载波</li><li>天线端口3002，3003位于符号 3 的 #2 - #3 子载波</li><li>天线端口3004，3005位于符号 2 的 #4 - #5 子载波</li><li>天线端口3006，3007位于符号 3 的 #4 - #5 子载波</li><li>天线端口3008，3009位于符号 2 的 #8 - #9 子载波</li><li>天线端口3010，3011位于符号 3 的 #8 - #9 子载波</li></ul></li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p8-CSI映射4.png" alt></p><h4 id="1-3-2-2-BWP内"><a href="#1-3-2-2-BWP内" class="headerlink" title="1.3.2.2 BWP内"></a>1.3.2.2 BWP内</h4><p>在CSI-RS所关联的BWP内，主要考虑 <em>CSI-Frequency Occupation</em> 参数，需要确定起始RB以及RB个数。分别由 <em>CSI-Frequency Occupation -&gt; startingRB</em> 和 <em>CSI-Frequency Occupation -&gt; nrofRBs</em> 决定。<br>以下再一次引入上面例子(1)(2)，BWP内映射情况如下：</p><ul><li>若row1_FrequencyDomainBitmap=[0001]，则$k_0 = f(1) = 0$；</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p9-CSI映射BWP1.png" alt></p><ul><li>若row2_FrequencyDomainBitmap=[000000000010]，则$k_0=f(1)=1$</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p10-CSI映射BWP2.png" alt></p><h2 id="1-4-CSI-RS-的发送时隙"><a href="#1-4-CSI-RS-的发送时隙" class="headerlink" title="1.4 CSI-RS 的发送时隙"></a>1.4 CSI-RS 的发送时隙</h2><p>当<em>CSI-ResourceSet</em> 配置为周期或半持续配置时，CSI-RS的发送时隙满足以下公式：</p><script type="math/tex;mode=display">(N_{slot}^{frame,\mu}n_f+n_{s,f}^{\mu}-T_{offset})modT_{CSI-RS} = 0</script><p>其中：</p><ul><li>$N_{slot}^{frame,\mu}$为子载波间隔配置 $\mu$ 下，一个系统帧的时隙的个数</li><li>$n_f$ 为系统帧号</li><li>$n_{s,f}^{\mu}$ 为子载波间隔配置 $\mu$ 下，一个系统帧中莫格时隙的序号</li><li>$T_{CSI-RS}，T_{offest}$，分别为CSI-RS的周期(单位：ms)和每个周期的偏移量(单位：slot)。由①<em>NZP-CSI-RS-Resource -&gt; periodicityAndOffset</em> 或 <em>ZP-CSI-RS-Resource -&gt; periodicityAndOffset</em> ；②CSI-RS-Resource-Mobility -&gt; slotConfig 获取。</li></ul><p><strong>以下简单描述 ZP CSI-RS，CSI-IM (interference measurement)，CSI-RS for Tracking，CSI-RS for L1-RSRP，CSI-RS for mobility。</strong></p><h2 id="1-5-ZP-CSI-RS"><a href="#1-5-ZP-CSI-RS" class="headerlink" title="1.5 ZP CSI-RS"></a>1.5 ZP CSI-RS</h2><p>在 ZP CSI-RS 上，基站不发送CSI-RS参考信号，功率为0，目的用于PDSCH速率适配，即PDSCH的发送不使用ZP CSI-RS占用的RE符号。在<em>PDSCH-Comfig</em>配置了三种ZP CSI-RS Resource Set （周期/半持续/非周期）。<br>在PDSCH中，最多配置32个ZP CSI-RS Resource Set，每个Resource Set 中，包含最多16个 Resource。<br>对于ZP CSI-RS配置的 <em>CSI-RS-ResourceMapping</em>，参数含义和NZP CSI-RS 一致</p><h2 id="1-6-CSI-RS-配置框架"><a href="#1-6-CSI-RS-配置框架" class="headerlink" title="1.6 CSI-RS 配置框架"></a>1.6 CSI-RS 配置框架</h2><p>每一个CSI Report Setting （<em>CSI-ReportConfig</em>） 关联一个Resource Setting（<em>CSI-ResourceCofig</em>）；一个 Resource Setting 归属到一个BWP，类型为非周期，周期或者半持续。Resource Setting 中包括 S 个Resource Set，对于周期或者半持续Resource Setting，S=1，即只有一个资源集；<br>基站选择一个Resource Set 用于UE测量；一个Resource Set中包含了参考信号列表，可以是NZP CSI-RS 或者CSI-SSB，CSI-IM，用<em>ResourceID</em> 标识。UE 在Resource Set 中对一个Resource 进行测量和报告。</p><h2 id="1-7-CSI-IM及其资源映射"><a href="#1-7-CSI-IM及其资源映射" class="headerlink" title="1.7 CSI-IM及其资源映射"></a>1.7 CSI-IM及其资源映射</h2><p>CSI-IM用于进行干扰估计。UE 可以配置1个或者多个CSI-IM ResourceSet，每个Set包含 $K\geq 1$ 个资源。CSI-IM的资源映射相对简单，CSI-IM也可以是非周期，周期和半持续类型。</p><h3 id="1-7-1-Pattern-0"><a href="#1-7-1-Pattern-0" class="headerlink" title="1.7.1 Pattern 0"></a>1.7.1 Pattern 0</h3><p>当资源映射方式配置为Pattern 0 时，CSI-IM的资源映射到如下RE：</p><script type="math/tex;mode=display">(k_{CSI-IM},l_{CSI-IM}),(k_{CSI-IM},l_{CSI-IM}+1),(k_{CSI-IM}+1,l_{CSI-IM}),(k_{CSI-IM}+1,l_{CSI-IM}+1)</script><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p27-CSI-IM-p0.png" alt></p><h3 id="1-7-2-Pattern-1"><a href="#1-7-2-Pattern-1" class="headerlink" title="1.7.2 Pattern 1"></a>1.7.2 Pattern 1</h3><p>当资源映射方式配置为Pattern 1 时，CSI-IM的资源映射到如下RE：</p><script type="math/tex;mode=display">(k_{CSI-IM},l_{CSI-IM}),(k_{CSI-IM}+1,l_{CSI-IM}),(k_{CSI-IM}+2,l_{CSI-IM}),(k_{CSI-IM}+3,l_{CSI-IM})</script><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p28-CSI-IM-p1.png" alt></p><h3 id="1-7-3-干扰测量"><a href="#1-7-3-干扰测量" class="headerlink" title="1.7.3 干扰测量"></a>1.7.3 干扰测量</h3><p>对于CSI-IM配置的资源，基站不发送任何信号，也可以认为是一种ZP CSI-RS。UE在CSI-IM 上测量的干扰信号，来自于邻区或者为底噪，用来进行干扰估计。</p><h2 id="1-8-CSI-RS-for-Tracking"><a href="#1-8-CSI-RS-for-Tracking" class="headerlink" title="1.8 CSI-RS for Tracking"></a>1.8 CSI-RS for Tracking</h2><p>CSI-RS for Tracking，也称为TRS(tracking reference signal)，是一种比较特殊的参考信号，UE用来进行精确的时频域同步（精度高于SSB）。<br>在ResourceSet设置trs-info 为 true，ResourceSet 中的TRS使用相同端口；在RRC链接态下，必须配置TRS。<br>TRS时域特性：</p><ul><li>对于FR1，UE可以配置1个或者多个Set，每个Set包含连续两个时隙，一共4个资源Resource，每个时隙2个资源Resource;</li><li>对于FR2，可以配置4个资源（FR1），也可以配置两个资源（一个时隙）</li></ul><p>符号位置：</p><ul><li>FR1/FR2：$l\in \{4,8\},l\in \{5,9\},or,l\in \{6,10\}$</li><li>FR2：$l\in \{0,4\},l\in \{1,5\},l\in \{2,6\},l\in \{3,7\},l\in \{7,11\},l\in \{8,12\},l\in \{9,13\}$</li></ul><h2 id="1-9-CSI-RS-for-L1-RSRP"><a href="#1-9-CSI-RS-for-L1-RSRP" class="headerlink" title="1.9 CSI-RS for L1-RSRP:"></a>1.9 CSI-RS for L1-RSRP:</h2><p>用于L1 层RSRP测量与波束管理。<br>在ResourceSet设置Repetion字段，表示用于L1-RSRP测量</p><ul><li>On 表示ResourceSet中的多个Resource使用相同的下行波束发送</li><li>Off 表示ResourceSet中的多个Resource使用不同的下行波束发送</li></ul><h2 id="1-10-CSI-RS-for-mobility"><a href="#1-10-CSI-RS-for-mobility" class="headerlink" title="1.10 CSI-RS for mobility"></a>1.10 CSI-RS for mobility</h2><p>CSI-RS可以用来进行RR吗测量，用于移动性管理（切换）。</p><h1 id="2-SRS"><a href="#2-SRS" class="headerlink" title="2 SRS"></a>2 SRS</h1><p>LTE中已经支持 SRS ，基站可以利用SRS评估上行信道参数，对于TDD系统，利用信道互异性，也可以评估下行信道参数。<br>NR中也支持SRS，基站可以利用SRS评估上行(下行)信道质量以外，还可以使用SRS进行上行波束的管理，包括波束训练，波束切换等。</p><h2 id="2-1-SRS-配置"><a href="#2-1-SRS-配置" class="headerlink" title="2.1 SRS 配置"></a>2.1 SRS 配置</h2><p>一些重要参数配置如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p26-SRS参数配置.png" alt></p><h2 id="2-2-SRS-发送梳配置"><a href="#2-2-SRS-发送梳配置" class="headerlink" title="2.2 SRS 发送梳配置"></a>2.2 SRS 发送梳配置</h2><p>和LET类似，NR中的SRS在频域上，也采用了 “梳状” Comb 发送的方式，即对于单UE，在频域上，每N个子载波发送SRS；NR中，发送梳 <em>transmissionComb</em> 支持 N=2 或 N=4配置，其中的 $K_{TC}$ 参数表示 N，其中 <em>combOffset</em> 为发送梳偏置，对于N=2 或 N=4，分比为 {0,1}，{0,1,2,3}。不同UE可以配置不同子载波上的频分复用。</p><h2 id="2-3-序列生成"><a href="#2-3-序列生成" class="headerlink" title="2.3 序列生成"></a>2.3 序列生成</h2><p>SRS 序列长度定义 $M_{sc,b}^{RS} = m_{SRS,b}N_{sc}^{RB}/K_{TC}$。SRS 的序列长度为SRS在频域上的子载波个数。其中$m_{SRS,b}$ 由 [TS 38.211 6.4.1.4.3-1] 给出，见下文。<br>SRS资源的序列按照如下公式生成：</p><script type="math/tex;mode=display">r^{p_i}(n,l')=r_{u,v}^{(\alpha_i,\delta)}(n)\\0\leq n \leq M_{sc,b}^{RS}-1\\l'\in \{0,1,...,N_{symb}^{SRS}-1\}\\N_{symb}^{SRS}\in \{1,2,4\}</script><p>其中：</p><ul><li>$\alpha_i$，由 <em>cyclic shift</em> $\alpha_i$ 给出，见下文；</li><li>$\delta = log_2(K_{TC})$</li><li>$r_{u,v}^{(\alpha,\delta)}(n)$，为低峰均比序列，由 [TS 38.211 5.2.2] 定义，$r_{u,v}^{(\alpha,\delta)}(n)=e^{j\alpha n}\overline r_{u,v}(n),0\leq n\leq M_{ZC}$，$M_{ZC}$ 为序列长度,按照SRS序列来说就是 $M_{sc,b}^{RS}$ 。</li></ul><h2 id="2-4-SRS循环移位"><a href="#2-4-SRS循环移位" class="headerlink" title="2.4 SRS循环移位"></a>2.4 SRS循环移位</h2><p>不同的UE可以使用相同的SRS物理资源，此时不同UE的不同SRS端口，通过不同的循环移位 <em>cyclic shift</em> $\alpha_i$ 复用。根据不同发送梳配置，支持的最大循环移位个数不相同：</p><ul><li>$K_{TC}=2$，$n_{SRS}^{CS,max} = 8$</li><li>$K_{TC}=4$，$n_{SRS}^{CS,max} = 12$</li></ul><p>对于天线端口 $p_i$，循环移位 $\alpha_i$ 根据以下公式确定：</p><script type="math/tex;mode=display">\alpha_i = 2\pi\frac{n_{SRS}^{CS,i}}{n_{SRS}^{CS,max}}\\n_{SRS}^{CS,i}=\left( n_{SRS}^{CS}+\frac{n_{SRS}^{CS,max}(p_i-100)}{N_{ap}^{SRS}}\right) modn_{SRS}^{CS,max}\\n_{SRS}^{CS} \in \{0,1,...,n_{SRS}^{CS,max}-1\}\\N_{ap}^{SRS}\in\{1,2,4\}</script><h2 id="2-4-映射"><a href="#2-4-映射" class="headerlink" title="2.4 映射"></a>2.4 映射</h2><h3 id="2-4-1-时域资源配置"><a href="#2-4-1-时域资源配置" class="headerlink" title="2.4.1 时域资源配置"></a>2.4.1 时域资源配置</h3><p>由两个参数决定：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrofSymbols		ENUMERATED &#123;n1,n2,n4&#125;</span><br><span class="line">startPosition	ENuMERATED &#123;0..5&#125;</span><br></pre></td></tr></table></figure><br>分别表示 $N_{symb}^{SRS} \in \{1,2,4\}$ 个OFDM 符号，$l_{offset}\in \{0,1,…,5\}$。<br>SRS 的时域开始符号 $l_0=N_{symb}^{slot}-1-l_{offset}，l_{offset} \geq N_{symb}^{SRS}-1$。即从时隙的最后一个符号开始倒数计数（SRS不能超过时隙的边界）<p></p><p>举例</p><ul><li>$N_{symb}^{SRS} =1，l_{offset} =2 ，l_0 = 11$</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p10-SRS时隙配置1.png" alt></p><ul><li>$N_{symb}^{SRS} =4，l_{offset} =3 ，l_0 = 10$</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p11-SRS时隙配置.png" alt></p><h3 id="2-4-2-频域资源"><a href="#2-4-2-频域资源" class="headerlink" title="2.4.2 频域资源"></a>2.4.2 频域资源</h3><p>SRS频域资源配置和映射相对复杂，但归根结底是需要确定SRS在频域的起始子载波位置和频域上的带宽分布。主要在SRS-Resource下这几个参数配置：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">freqDomainPosition	INTEGER (0..67);	&#x2F;&#x2F; 频域位置</span><br><span class="line">freqDomainShifft	INTEGER (0..268);	&#x2F;&#x2F; 频域偏移</span><br><span class="line">freqHopping		SEQUENCE &#123;				&#x2F;&#x2F; 跳频相关配置</span><br><span class="line">	c-SRS			INTEGER (0..63);</span><br><span class="line">	b-SRS			INTEGER (0..3);</span><br><span class="line">	b-hop			INTEGER (0..3);</span><br></pre></td></tr></table></figure><br>参数分别对应的物理层变量名为：<p></p><ul><li>$n_{RRC}$</li><li>$n_{shift}$</li><li>$C_{SRS}\in\{0,1,…,63\}$</li><li>$B_{SRS}\in \{0,1,2,3\}$</li><li>$b_{hop}\in \{0,1,2,3\}$</li></ul><p>参数 $m_{SRS,b}$ 为SRS 在频域上分布的RB个数，根据 $C_{SRS}，B_{SRS}$ 配置，由[TS 38.211 Table 6.4.1.4.3-1] 确定：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/t3-211-6.4.1..4.3-11.png" alt><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/t4-211-6.4.1..4.3-12.png" alt><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/t5-211-6.4.1..4.3-13.png" alt></p><h3 id="2-4-3-频域资源特性"><a href="#2-4-3-频域资源特性" class="headerlink" title="2.4.3 频域资源特性"></a>2.4.3 频域资源特性</h3><p>SRS的频域起始位置定义如下：</p><script type="math/tex;mode=display">k_0^{p_i}=\overline k_0^{(p_i)}+ \sum_{b=0}^{B_{SRS}}K_{TC}M_{sc,b}^{SRS}n_b\\ \overline k_0^{(p_i)}=n_{shift}N_{sc}^{RB}+k_{TC}^{(p_i)}\\k_{TC}^{(p_i)}=\begin{cases} (\overline k_{TC}+K_{TC}/2)modK_{TC}\quad \quad if\quad n_{SRS}^{CS}\in \{n_{SRS}^{cs,max}/2,...,n_{SRS}^{cs,max}-1\}\\ \quad\quad \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\cdots\quad and\quad N_{ap}^{SRS}=4,p_i \in \{1001,1003\}\\ \overline k_{TC} \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad otherwise   \end{cases}</script><p>其中：</p><ul><li>$\overline k_{TC} \in \{0,1,…,K_{TC}-1\}$ ，为发送梳偏置 <em>combOffset</em>；</li><li>$K_{TC}$ 为发送梳配置，由<em>transmissionComb</em>配置；</li><li>$n_{shift}$ 由 <em>freqDomainShift</em> 配置；</li><li>当 $b_{hop} \geq B_{SRS}$ ，即不跳频，此时$n_b = \lfloor 4n_{RRC}/m_{SRS,b} \rfloor mod N_b$<ul><li>$n_{RRC}$ 由 <em>freqDomainPosition</em> 配置；</li><li>$b_{hop}$ 由 <em>freqHopping -&gt; b-hop</em> 配置。</li></ul></li></ul><h3 id="2-4-4-频域资源配置"><a href="#2-4-4-频域资源配置" class="headerlink" title="2.4.4 频域资源配置"></a>2.4.4 频域资源配置</h3><h4 id="2-4-4-1-频域资源配置（非跳频）"><a href="#2-4-4-1-频域资源配置（非跳频）" class="headerlink" title="2.4.4.1 频域资源配置（非跳频）"></a>2.4.4.1 频域资源配置（非跳频）</h4><p>当 $b_{hop} \geq B_{SRS}$，$n_b=\lfloor 4n_{RRC}/m_{SRS,b} \rfloor mod N_b$。<br>以下直接用4个例子说明，都设定参数 $C_{RS} = 63，K_{TC} = 2$，$n_{RRC}$ 由 <em>freqDomainPosition</em> 配置，为了方便作图，假定频域初始RB级偏移为0。</p><ul><li><ol><li>$B_{SRS} = 0$</li></ol></li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p13-非调频1.png" alt></p><p>此时，$N_0=1,m_{SRS,0}=272,n_0=\lfloor 4n_{RRC}/m_{SRS,0} \rfloor mod N_0 = 0$</p><script type="math/tex;mode=display">k_0^{p_i}=\overline k_0^{(p_i)}+ \sum_{b=0}^{B_{SRS}}K_{TC}M_{sc,b}^{SRS}n_b = \overline k_0^{(p_i)} \\ \overline k_0^{(p_i)}=n_{shift}N_{sc}^{RB}+k_{TC}^{(p_i)}</script><p>此时 $n_{shift}$ 配置为 0/1，此种情况 SRS分布在全部配置的RB上，如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p17-非调频11.png" alt></p><ul><li><ol><li>$B_{SRS} = 1$</li></ol></li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p14-非调频2.png" alt></p><p>此时：</p><script type="math/tex;mode=display">N_0=1,m_{SRS,0}=272,n_0=\lfloor 4n_{RRC}/m_{SRS,0} \rfloor mod N_0 = 0\\N_1=17,m_{SRS,1}=16,n_1=\lfloor 4n_{RRC}/m_{SRS,1} \rfloor mod N_1 \in \{0,1,...,16\}</script><script type="math/tex;mode=display">k_0^{p_i}=\overline k_0^{(p_i)}+ \sum_{b=0}^{B_{SRS}}K_{TC}M_{sc,b}^{SRS}n_b = \overline k_0^{(p_i)} +K_{TC}M_{sc,1}^{SRS}n_1 \\ \overline k_0^{(p_i)}=n_{shift}N_{sc}^{RB}+k_{TC}^{(p_i)}</script><p>此种情况就是把SRS总带宽分为了 $N_1$ 个等份，每个等份的RB个数为 $m_{SRS,1}$，通过 $n_{RRC}$ 来配置取哪个等份的索引，本例子采用 $n_1 = 1$，如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p18-非调频22.png" alt></p><ul><li><ol><li>$B_{SRS} = 2$</li></ol></li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p15-非调频3.png" alt></p><p>此时：</p><script type="math/tex;mode=display">N_0=1,m_{SRS,0}=272,n_0=\lfloor 4n_{RRC}/m_{SRS,0} \rfloor mod N_0 = 0\\N_1=17,m_{SRS,1}=16,n_1=\lfloor 4n_{RRC}/m_{SRS,1} \rfloor mod N_1 \in \{0,1,...,16\}\\N_2=2,m_{SRS,2}=8,n_2=\lfloor 4n_{RRC}/m_{SRS,2} \rfloor mod N_2 \in \{0,1 \}</script><script type="math/tex;mode=display">k_0^{p_i}=\overline k_0^{(p_i)}+ \sum_{b=0}^{B_{SRS}}K_{TC}M_{sc,b}^{SRS}n_b = \overline k_0^{(p_i)} +K_{TC}M_{sc,1}^{SRS}n_1+K_{TC}M_{sc,2}^{SRS}n_2 \\ \overline k_0^{(p_i)}=n_{shift}N_{sc}^{RB}+k_{TC}^{(p_i)}</script><p>此种情况就是把SRS总带宽分为了 $N_1$ 个大等份，每个大等份的RB个数为 $m_{SRS,1}$，通过 $n_{RRC}$ 来配置取哪个大等份的索引，本例子采用 $n_1 = 1$。接着继续将每个大等份继续划分为 $N_2$ 个中等份，每个中等份的RB数为 m_{SRS,2}，通过$n _{RRC}$来确定中等份的索引，本例子采用 $n_2 = 0$，如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p19-非调频33.png" alt></p><ul><li><ol><li>$B_{SRS} = 2$</li></ol></li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p16-非调频4.png" alt></p><p>此时：</p><script type="math/tex;mode=display">N_0=1,m_{SRS,0}=272,n_0=\lfloor 4n_{RRC}/m_{SRS,0} \rfloor mod N_0 = 0\\N_1=17,m_{SRS,1}=16,n_1=\lfloor 4n_{RRC}/m_{SRS,1} \rfloor mod N_1 \in \{0,1,...,16\}\\N_2=2,m_{SRS,2}=8,n_2=\lfloor 4n_{RRC}/m_{SRS,2} \rfloor mod N_2 \in \{0,1 \}\\N_3=2,m_{SRS,3}=4,n_3=\lfloor 4n_{RRC}/m_{SRS,3} \rfloor mod N_3 \in \{0,1\}</script><script type="math/tex;mode=display">k_0^{p_i}=\overline k_0^{(p_i)}+ \sum_{b=0}^{B_{SRS}}K_{TC}M_{sc,b}^{SRS}n_b = \overline k_0^{(p_i)} +K_{TC}M_{sc,1}^{SRS}n_1+K_{TC}M_{sc,2}^{SRS}n_2+K_{TC}M_{sc,3}^{SRS}n_3 \\ \overline k_0^{(p_i)}=n_{shift}N_{sc}^{RB}+k_{TC}^{(p_i)}</script><p>此种情况就是把SRS总带宽分为了$ N_1 $个大等份，每个大等份的RB个数为 $m_{SRS,1}$，通过 $n_{RRC}$ 来配置取哪个大等份的索引，本例子采用 $ n_1 = 1$；接着继续将每个大等份继续划分为 $N_2 $ 个中等份，每个中等份的RB数为 $m_{SRS,2}$，通过 $n _{RRC}$ 来确定中等份的索引，本例子采用 $n_2 = 0$；最后再将中等份划分为 $N_3$ 个小等份，每个小等份的RB数为 $m _{SRS,3}$ ，通过 $n _{RRC}$ 来确定小等份的索引，本例子采用的 $n _3 = 0$，如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p20-非调频44.png" alt></p><h4 id="2-4-4-2-频域资源配置（跳频）"><a href="#2-4-4-2-频域资源配置（跳频）" class="headerlink" title="2.4.4.2 频域资源配置（跳频）"></a>2.4.4.2 频域资源配置（跳频）</h4><p>SRS可以支持跳频，由时域和频域两方面的参数共同确定跳频特性。<br>时域上：SRS再时隙内占用 $N_s$ 个符号（1,2,4）; <em>Repetition Factor</em>，$R \in \{R \leq N_s\}$ ，即再每个符号上重复 R 次，显然：</p><ul><li>当 $R = N_s$ 时，不支持时隙内跳频；</li><li>当 $R = 1,N_s=2,4$ 时，时隙内进行跳频，以一个OFDM符号为单位跳频；</li><li>当 $R = 2,N_S = 4$ 时，时隙内进行跳频，以两个OFDM符号位单位跳频；</li></ul><p>SRS支持三种类型的 Resource Type：</p><ul><li>非周期：只能再时隙内进行（即触发一次就完全跳完）</li><li>周期和半持续可以在时隙内跳频，也支持时隙间（周期）跳频</li></ul><p>当 $b_{hop} &lt; B_{SRS}$ 时，表示跳频生效，此时频率位置参数 $n_b$ ，由以下公式给出：</p><script type="math/tex;mode=display">n_b=\begin{cases} \quad\quad \lfloor 4n_{RRC}/m_{SRS,b} \rfloor mod N_b\quad\quad\quad\quad\quad\quad\quad b\leq b_{hop}\\ \{ F_b(n_SRS)+\lfloor 4n_{RRC}/m_{SRS,b} \rfloor \} mod N_b\quad\quad otherwise  \end{cases}\\F_b(n_{SRS})=\begin{cases} (N_b/2)\lfloor \frac{n_{SRS}mod\prod_{b'=b_{hop}}^{b}N_{b'}}{\prod_{b'=b_{hop}}^{b}N_{b'}}+\frac{n_{SRS}mod\prod_{b'=b_{hop}}^{b}N_{b'}}{2\prod_{b'=b_{hop}}^{b}N_{b'}} \rfloor \quad if\quad N_b\quad even\\ \quad\quad\quad\lfloor N_b/2 \rfloor\lfloor n_{SRS}/\prod_{b'=b_{hop}}^{b-1}N_{b'} \rfloor\quad\quad\quad\quad\quad\quad if\quad N_b\quad odd \end{cases}</script><h5 id="2-4-4-2-1-非周期"><a href="#2-4-4-2-1-非周期" class="headerlink" title="2.4.4.2.1 非周期"></a>2.4.4.2.1 非周期</h5><p>非周期SRS，仅支持时隙内跳频（即依次完成）</p><ul><li>当 $R = 1,N_S=2$时，时隙内跳频，2个OFDM符号跳频，需要覆盖到整个SRS带宽，即把SRS带宽分为两个子带，通过2个符号跳频实现；</li><li>当 $R = 1,N_S=4$时，时隙内跳频，4个OFDM符号跳频，需要覆盖到整个SRS带宽，即把SRS带宽分为四个子带，通过4个符号跳频实现；</li><li>当 $R = 2,N_S=4$时，时隙内跳频，4个OFDM符号跳频，需要覆盖到整个SRS带宽，即把SRS带宽分为两个子带，通过2个符号对跳频实现；<br>如下图所示：</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p21-跳频非周期1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p22-跳频非周期2.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p23-跳频非周期3.png" alt></p><p>以下有一个摘自春天工作室的例子，来说明如何使用上文所描述跳频的公式：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p24-春天工作室例子1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-%E5%8F%82%E8%80%83%E4%BF%A1%E5%8F%B7%E5%AD%A6%E4%B9%A0/p25-春天工作室例子2.png" alt></p><h5 id="2-4-4-2-2-周期和半持续"><a href="#2-4-4-2-2-周期和半持续" class="headerlink" title="2.4.4.2.2 周期和半持续"></a>2.4.4.2.2 周期和半持续</h5><p>对于周期和半持续SRS：</p><ul><li>当 $N_s=1$ 时，可以进行时隙间跳频</li><li>当 $N_s=2 or 4$ 时，可以进行时隙内和时隙间跳频</li><li>当 $N_s=R$ 时，可以进行时隙间跳频</li></ul><p>和非周期相比，周期和半持续 SRS 跳频函数相同，SRS发送计数定义不同 $n_{SRS}$:</p><script type="math/tex;mode=display">n_{SRS} = ( \frac{N_{slot}^{frame,\mu}n_f+n_{s,f}^{\mu}-T_{offset}}{T_{SRS}})(\frac{N_{symb}^{SRS}}{R})+ \lfloor \frac{l'}{R} \rfloor</script><p>即根据周期发送，$n_{SRS}$ 进行累加计数，实现了时隙间跳频。</p><h3 id="2-4-5-物理资源映射"><a href="#2-4-5-物理资源映射" class="headerlink" title="2.4.5 物理资源映射"></a>2.4.5 物理资源映射</h3><p>最终，根据前文的基础，当SRS在给定的SRS资源上传输时，序列$r^{(p_i)}(n,l’)$ 从 $r^{(p_i)}(0,l’)$ 开始在天线端口 $p_i$ 上的时隙上依次映射到资源单元 $(k,l)$ 上，公式如下：</p><script type="math/tex;mode=display">\alpha_{K_{TC}k'+k_0^{(p_i)},l'+l_0}^{(p_i)}=\begin{cases} \frac{1}{\sqrt{N_{ap}}}\beta_{SRS}r^{(p_i)}(k',l')\quad k'=0,1,...,M_{sc,b}^{SRS}\quad l'=0,1,...,N_{symb}^{SRS}-1\\\quad 0\quad\quad\quad\quad\quad\quad\quad\quad\quad othersize \end{cases}</script><h2 id="SRS-补充"><a href="#SRS-补充" class="headerlink" title="SRS 补充"></a>SRS 补充</h2><p>NR 系统中，基站可以为 UE 配置多个 SRS 资源集，每个 SRS 资源集包含 1 到 多个 SRS 资源，每个 SRS 资源包含1、2 或 4 个 SRS 端口。每个 SRS 资源可以配置在一个时隙的最后 6 个OFDM 符号中锋1、2或 4 个连续的符号。当SRS 与 PUSCH 发送在同一个时隙时，SRS 只能在 PUSCH 及其对应 的 DMRS 之后发送。<br>SRS 资源内的 SRS 端口所占有的子载波数在一个 RB 中的偏移通过高层信令配置。 SRS 资源的时频域资源映射是针对每个 SRS 资源进行配置的，同一个 SRS 资源内的不同 SRS 端口占用完全相同的符号，互相间通过频分 (占用不同的子载波) 或者码分 (利用不同的 ZC 序列或者相同的 ZC 序列的不同循环移位) 的方式进行复用。<br>NR 系统种 支持 64 种 SRS 贷款配置方式，一个 SRS 资源可配置的最小带宽为 4 个 RB，最大带宽 为 272 个 RB。</p><p>NR系统支持周期、半周期和非周期的 SRS的发送方式。SRS 的发送方式通过为 SRS 资源集和 SRS 资源配置关于时域类型的高层参数类型来实现。一个 SRS资源集内的所有 SRS 资源都与该 SRS 资源集具有相同的时域类型。</p><ul><li>周期性发送。时域类型被配置为周期的 SRS 资源的所有参数由高层信令配置，UE根据所配置的参数进行周期性的发送。同一个 SRS 资源集内的所有 SRS 资源具有相同的周期性。</li><li>半持续发送。时域类型被配置为半持续的 SRS 资源在激活期间也是周期发送的。它与周期性 SRS 的区别在于 UE 在接收到关于半持续 SRS 资源的高层信令配置后不发送 SRS，只有在接收到 MAC 层发送的关于半持续 SRS 资源的激活信令后才开始周期性地发送半持续 SRS 资源对应的 SRS ，在接收 MAC 层发送的半持续 SRS 资源的去激活命令后停止发送 SRS。因此，相对于周期性 SRS 资源，半持续 SRS 资源的配置以及激活，去激活相比高层信令 (RRC 信令) 更快，更灵活，适应于要求时延较低的业务快速传输。</li><li>非周期性发送。时域类型被配置为非周期的 SRS 资源通过 DCI 信令激活。 UE 每接收到一次触发非周期 SRS 资源的 SRS 触发信令，UE 进行一次所触发的 SRS 资源对应的 SRS 发送。</li></ul><h1 id="3-CSI-报告"><a href="#3-CSI-报告" class="headerlink" title="3 CSI 报告"></a>3 CSI 报告</h1><p>还没看完。</p><blockquote><p>参考文献<br>微信公众号：春天工作室<br>网页：<a href="https://mp.weixin.qq.com/s/nJIEE5B4wV3xirAqJZHfZA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nJIEE5B4wV3xirAqJZHfZA</a><br>网页：<a href="https://mp.weixin.qq.com/s/-15pUXt8BN4ZbxaiKJ-jgQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-15pUXt8BN4ZbxaiKJ-jgQ</a><br>网页：<a href="https://mp.weixin.qq.com/s/WDpxnX6BqqOHzv9iJokS8w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WDpxnX6BqqOHzv9iJokS8w</a><br>网页：<a href="http://www.sharetechnote.com/html/5G/5G_CSI_RS.html" target="_blank" rel="noopener">http://www.sharetechnote.com/html/5G/5G_CSI_RS.html</a><br>博客：<a href="http://blog.sina.com.cn/s/blog_3c3393b00102yne0.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_3c3393b00102yne0.html</a><br>博客：<a href="http://blog.sina.com.cn/s/blog_3c3393b00102yqs4.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_3c3393b00102yqs4.html</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>CSI</tag>
        <tag>SRS</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-PUSCH学习</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="1-PUSCH信道处理流程"><a href="#1-PUSCH信道处理流程" class="headerlink" title="1 PUSCH信道处理流程"></a>1 PUSCH信道处理流程</h1><h2 id="1-1-TS-38-212对应处理过程"><a href="#1-1-TS-38-212对应处理过程" class="headerlink" title="1.1 TS 38.212对应处理过程"></a>1.1 TS 38.212对应处理过程</h2><h3 id="1-1-1-增加CRC校验"><a href="#1-1-1-增加CRC校验" class="headerlink" title="1.1.1 增加CRC校验"></a>1.1.1 增加CRC校验</h3><p>PUSCH数据$a_0,a_1,…,a_{A-1}$，首先判断传输块长度 A 的大小，来确定选择的 CRC方法：<br>$if$ $A &gt; 3824$<br>​ $g_{CRC24(D)}$ \\\ L = 24<br>$else$<br>​ $g_{CRC16(D)}$ \\\ L = 16</p><p>随后，$a_0,a_1,…,a_{A-1}$ 通过 $g_{CRC24(D)}$ 或 $g_{CRC16(D)}$ 来生成校验位 $p_0,p_1,…,p_{L-1}$</p><p>最后，将校验位$p_0,p_1,…,p_{L-1}$，附在 $a_0,a_1,…,a_{A-1}$ 后，形成添加CRC的数据，$a_0,…,a_{A-1},p_0,…,p_{L-1}$。即$b_0,b_1,…,b_{B-1}$，其中 $B = A+L$</p><h3 id="1-1-2-LDPC-base-graph-selection"><a href="#1-1-2-LDPC-base-graph-selection" class="headerlink" title="1.1.2 LDPC base graph selection"></a>1.1.2 LDPC base graph selection</h3><p>base graph 的选择有如下的规则：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A ≤ 292 ——————————————————————→ LDPC base graph 2</span><br><span class="line">A ≤ 3824 and R ≤ 0.67 ————————→ LDPC base graph 2</span><br><span class="line">R ≤ 0.25 —————————————————————→ LDPC base graph 2</span><br><span class="line">else  ————————————————————————→ LDPC base graph 1</span><br></pre></td></tr></table></figure><br>即：<br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p1-base graph选择.png" alt><p></p><p>可以近似理解为：<br>低码率/小TBS选择BG2；高码率/大TBS选择BG1。</p><h3 id="1-1-3-Code-block-码块分割和增加CRC"><a href="#1-1-3-Code-block-码块分割和增加CRC" class="headerlink" title="1.1.3 Code block 码块分割和增加CRC"></a>1.1.3 Code block 码块分割和增加CRC</h3><p>NR中LDPC编码，最大码块长度限定为：<br>LDPC base graph 1 $K_{cb} = 8448$ ;<br>LDPC base graph 2 $K_{cb} = 3840$;</p><p>因此TB块(含CRC)要根据LDPC码块长度分为多个码块。<br>待编码bit $b_0,b_1,…,b_{B-1}$</p><ul><li>当 $B\leq K_{cb}$， 码块个数 $C = 1$</li><li>当$B&gt; k_{cb}$，码块个数 $C = \lceil B/(K_{cb}-L)\rceil$，其中 $L = 24$ 为每个码块增加的CRC校验bit位数<br>如下图所示：</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p2-码块分割.png" alt></p><p>以上每个码块内含有的比特数为 $K’ = B’/C$，即$B/C + L$，因为 $B’ = B + C\cdot L$</p><p>简单的说就是每个分组的的码块长度是 K’ 有三种情况：</p><ul><li>如果$B$ ≤ $K_{cb}$，$K’ = B$；</li><li>如果$B$ &gt; $K_{cb}$，除了最后一个可能取整多余出来分组外，$K’ = K_{cb}$;</li><li>就上述最后一个分组，$K’ = B - (C-1)\cdot(K_{cb}-L) + L$;</li></ul><p>码块长度确定后，要根据不同BG，生成编码矩阵，首先要确定编码矩阵的<strong>列数</strong>。</p><ul><li>对于BG1，$K_b = 22$，即基础矩阵的最大系统列数22列</li><li>对于BG2：<br>$if\quad B&gt;640\quad K_b = 10;$<br>$elseif\quad B&gt;560\quad K_b = 9;$<br>$elseif\quad B&gt;192\quad K_b = 8;$<br>$else\quad K_b = 6$</li></ul><p><strong>lifting size $Z_c$ </strong>：满足 $K_b\cdot Z_c \leq K’$，且是表格中的最小值。设，BG1：$K = 22Z_c$；BG2：$K = 10Z_c$。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t3-38.212 5.3.2-1.png" alt></p><p>通过上图 $Z_c$ 所处在的集合，可以确定 Set Index ($i_{LS}$)。</p><h3 id="1-1-4-信道编码"><a href="#1-1-4-信道编码" class="headerlink" title="1.1.4 信道编码"></a>1.1.4 信道编码</h3><p>编码前，$c_0,c_1,c_2,…,c_{K-1}$，K由上文给出。<br>LDPC编码后，$d_0,d_1,d_2,…,d_{N-1}$，BG1：$N = 66Z_c$；BG2：$N = 50Z_c$。<br><strong>基矩阵</strong>：</p><ul><li>对于BG1：$H_{BG}$ 为 46$\times$68 的矩阵</li><li>对于BG2：$H_{BG}$ 为 42$\times$52 的矩阵</li></ul><p>$H_{BG}$ 中的元素通过 Set Index ($i_{LS}$) 查表获得：</p><blockquote><p>BG1：[TS 38.212 Table 5.3.2-2]<br>BG2：[TS 38.212 Table 5.3.2-3]</p></blockquote><p><strong>注</strong>：通过查表中的前两列可知 $H_{BG}$中对应的行列数元素值为1，其中没有的行列数对应的值为0，全部设置为0。表中 $V_{i,j}$ 则代表其奇偶校验矩阵对应的元素数值。</p><p>再利用Set Index ($i_{LS}$) 确定$V_{i,j}$后，根据$P_{i,j} = mod(V_{i,j},Z_c)$，获得编码矩阵的循环移位值，根据 $H_{BG}$ 生成编码校验矩阵 <strong>H</strong>，生成方式再协议中的描述如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p3-编码矩阵生成.png" alt></p><p>简单来说就是将$H_{BG}$中的每个元素用大小为 $Z_c\times Z_c$ 的矩阵代替。</p><ul><li>如果元素值为0，则用大小为 $Z_c\times Z_c$ 的零矩阵代替。</li><li>如果元素值为1，则用大小为 $Z_c\times Z_c$ 的单位矩阵经过循环移位后的矩阵 $I(P_{i,j})$ 来替换。其中循环移位值由之前的$P_{i,j} = mod(V_{i,j},Z_c)$ 给出。</li></ul><p>总结，若：<br>待编码的信息比特，<strong>c</strong> $=[ c_0,c_1,c_2,…,c_{K-1}]^T$<br>其校验比特， <strong>w</strong> $=[w_0,w_1,…,w_{N+2Z_c-K-1}]^T$，可以得到 $H\times \left[ \begin{matrix} c\\w \end{matrix}\right]=0$</p><p><strong>疑问</strong>：用来生成<strong>[<em>c|W</em>]</strong>的生成矩阵到底是什么? 按理来说使用信息比特与生成矩阵相乘，产生信息比特和校验比特 <strong>[<em>c|W</em>]</strong>，这个生成矩阵到底是上面的那个<strong>$H_{BG}$</strong>又不是啊，<strong><em>H</em></strong>又是校验矩阵。</p><h3 id="1-1-5-速率匹配"><a href="#1-1-5-速率匹配" class="headerlink" title="1.1.5 速率匹配"></a>1.1.5 速率匹配</h3><p>完成LDPC编码后，得到 $d_0,d_1,d_2,…,d_{N-1}$。需要对其进行 Rate matching 速率适配，包括</p><ul><li>Bit selection</li><li>Bit interleaving</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p4-速率匹配.png" alt></p><h3 id="1-1-6-码块串联"><a href="#1-1-6-码块串联" class="headerlink" title="1.1.6 码块串联"></a>1.1.6 码块串联</h3><p>将速率匹配完成后的数据码块按序重组。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p5-码块重组.png" alt></p><h2 id="1-2-TS-38-211对应处理过程"><a href="#1-2-TS-38-211对应处理过程" class="headerlink" title="1.2 TS 38.211对应处理过程"></a>1.2 TS 38.211对应处理过程</h2><h3 id="1-2-1-加扰"><a href="#1-2-1-加扰" class="headerlink" title="1.2.1 加扰"></a>1.2.1 加扰</h3><p>对于单码字传输时，$q = 0$。[TS 38.211 7.3.1.1]，每一个码字对应的原始数据 $b^{(q)}(0),…,b^{(q)}(M_{bit}^{(q)}-1)$ ,经过加扰处理生成加扰后的数据为 $\widetilde b^{(q)}(0),…,\widetilde b^{(q)}(M_{bit}^{(q)}-1)$ 。加扰处理如下伪代码所示：</p><p>$while$ $i$ &lt; $M_{bit}^{(q)}$</p><p>​ $if$ $b^{(q)}(i) = x$ // UCI placeholder bits</p><p>​ $\widetilde b^{(q)}(i) = 1$</p><p>$else$<br>$if$ $b^{(q)}(i)=y$ // UCI placeholder bits</p><p>​ $\widetilde b^{(q)}(i) = \widetilde b^{(q)}(i-1)$</p><p>​ $else$</p><p>​ $\widetilde b^{(q)}(i) = (b^{(q)}(i) + c^{(q)}(i))mod2$</p><p>​ $end$ $if$</p><p>​ $end$ $if$</p><p>​ $i=i+1$</p><p>$end$ $ while$</p><p>其中加扰序列$c^{(q)}(i)$是一个伪随机序列，由[TS 38.211 5.2.1]给出，加扰序列的初始为：</p><script type="math/tex;mode=display">C_{init} = n_{RNTI}\cdot2^{15}+n_{ID}</script><p>其中</p><ul><li>$n_{RNTI}$ = C-RNTI or CS-RNTI , 并且在公共搜索空间中不使用DCI forrmat 0_0调度传输</li><li>$n_{ID}\in \{0,1,…,1023\}$ , 其值等于<em>dataScramblingIdentityPUSCH</em>(如果配置)，否则 $n_{ID} = N_{ID}^{cell}$</li></ul><h3 id="1-2-2-调制"><a href="#1-2-2-调制" class="headerlink" title="1.2.2 调制"></a>1.2.2 调制</h3><p>每一个码字加扰后的比特块 $\widetilde b^{(q)}(0),…,\widetilde b^{(q)}(M_{bit}^{(q)}-1)$ 采用下表中的一种调制方式进行调制，得到一个复值调制符号块$d^{(q)}(0),…,d^{(q)}(M_{symb}^{(q)}-1)$。[TS 38.211 6.3.1.2-1]</p><table><tr><th colspan="2"><center>Transform precoding disabled</center></th><th colspan="2"><center>Transform precoding enabled</center></th></tr><tr><td><center>Modulation scheme</center></td><td><center>Modulation order</center></td><td><center>Modulation scheme</center></td><td><center>Modulation order</center></td></tr><tr><td><center></center></td><td><center></center></td><td><center>π/2-BPSK</center></td><td><center>1</center></td></tr><tr><td><center>QPSK</center></td><td><center>2</center></td><td><center>QPSK</center></td><td><center>2</center></td></tr><tr><td><center>16QAM</center></td><td><center>4</center></td><td><center>16QAM</center></td><td><center>4</center></td></tr><tr><td><center>64QAM</center></td><td><center>6</center></td><td><center>64QAM</center></td><td><center>6</center></td></tr><tr><td><center>256QAM</center></td><td><center>8</center></td><td><center>256QAM</center></td><td><center>8</center></td></tr></table><h3 id="1-2-3-层映射"><a href="#1-2-3-层映射" class="headerlink" title="1.2.3 层映射"></a>1.2.3 层映射</h3><p>对于单个码字$q = 0$ , 每一个码字生成的调制信号 $d^{(q)}(0),…,d^{(q)}(M_{symb}^{(q)}-1)$ 根据表[TS 38.211 7.3.1.3-1] 映射到4层$x(i)=[x^0{i} \cdots x^{v-1}(i)]^T$，$i = 0,1,…,M_{symb}^{layer}-1$，具体的矩阵形式如下所示 , $M_{symb}^{layer}$ 表示每层调制符号的数量，其中$v$表示层数。,需要注意的是PUSCH最多映射4层，PDSCH最多8层。</p><script type="math/tex;mode=display">x(i)=[x^0{i} \cdots x^{v-1}(i)]^T\quad i = 0,1,...,M_{symb}^{layer}-1\\=\left[ \begin{matrix} x^{(0)}(0)&x^{(0)}(1)&\cdots&x^{(0)}(M_{sysmb}^{layer}-1)\\x^{(1)}(0)&x^{(1)}(1)&\cdots&x^{(1)}(M_{sysmb}^{layer}-1)\\ \vdots&\vdots&\ddots&\vdots \\x^{(p-1)}(0)&x^{(p-1)}(1)&\cdots&x^{(p-1)}(M_{sysmb}^{layer}-1)\end{matrix} \right]</script><div class="table-container"><table><thead><tr><th style="text-align:center">层数</th><th style="text-align:center">码字数</th><th>码字到层映射<br>$i = 0,1,…,M_{symb}^{layer}-1$</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(i)$ $M_{symb}^{layer} = M_{symb}^{(0)}$</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(2i)$<br>$x^{(1)}(i) = d^{(0)}(2i+1)$ $M_{symb}^{layer} = M_{symb}^{(0)}/2$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(3i)$<br>$x^{(1)}(i) = d^{(0)}(3i+1)$ $M_{symb}^{layer} = M_{symb}^{(0)}/3$<br>$x^{(2)}(i) = d^{(0)}(3i+2)$</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(4i)$<br>$x^{(1)}(i) = d^{(0)}(4i+1)$<br>$x^{(2)}(i) = d^{(0)}(4i+2)$ $M_{symb}^{layer} = M_{symb}^{(0)}/4$<br>$x^{(3)}(i) = d^{(0)}(4i+3)$</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(2i)$<br>$x^{(1)}(i) = d^{(0)}(2i+1)$<br>$x^{(2)}(i) = d^{(1)}(3i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/2 = M_{symb}^{(1)}/3$<br>$x^{(3)}(i) = d^{(1)}(3i+1)$<br>$x^{(4)}(i) = d^{(1)}(3i+2)$</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(3i)$<br>$x^{(1)}(i) = d^{(0)}(3i+1)$<br>$x^{(2)}(i) = d^{(0)}(3i+2)$<br>$x^{(3)}(i) = d^{(1)}(3i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/3 = M_{symb}^{(1)}/3$<br>$x^{(4)}(i) = d^{(1)}(3i+1)$<br>$x^{(5)}(i) = d^{(1)}(3i+2)$</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(3i)$<br>$x^{(1)}(i) = d^{(0)}(3i+1)$<br>$x^{(2)}(i) = d^{(0)}(3i+2)$<br>$x^{(3)}(i) = d^{(1)}(4i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/3 = M_{symb}^{(1)}/4$<br>$x^{(4)}(i) = d^{(1)}(4i+1)$<br>$x^{(5)}(i) = d^{(1)}(4i+2)$<br>$x^{(6)}(i)=d^{(1)}(4i+3)$</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(4i)$<br>$x^{(1)}(i) = d^{(0)}(4i+1)$<br>$x^{(2)}(i) = d^{(0)}(4i+2)$<br>$x^{(3)}(i)=d^{(0)}(4i+3)$<br>$x^{(4)}(i) = d^{(1)}(4i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/4 = M_{symb}^{(1)}/4$<br>$x^{(5)}(i) = d^{(1)}(4i+1)$<br>$x^{(6)}(i) = d^{(1)}(4i+2)$<br>$x^{(7)}(i)=d^{(1)}(4i+3)$</td></tr></tbody></table></div><h3 id="1-2-4-变换预编码"><a href="#1-2-4-变换预编码" class="headerlink" title="1.2.4 变换预编码"></a>1.2.4 变换预编码</h3><p>为了降低PAPR峰均比，上行PUSCH可以支持Transform Precoding , 即采用DFT-s-OFDM的形式，通过RRC层参数和DCI指示。</p><p>仅当<em>PUSCH-Config -&gt; transformprecoder</em> 配置 或者<em>RACH-configCommon -&gt; msg3-transformPrecoding</em> 配置时使用。</p><ul><li>如果变换预编码不可用，对于层$\lambda = 0,1,…,v-1$，有 $y^{(\lambda)}(i) = x^{(\lambda)}(i)$。</li><li>如果变换预编码可用，$v = 1$ , 且复值符号块$x^{(0)}(0),…,x^{(0)}(M_{symb}^{layer}-1)$ 被分为$M_{symb}^{layer}/M_{sc}^{PUSCH}$个集合，每个集合对应于一个OFDM符号。变换预编码根据如下公式进行：<script type="math/tex;mode=display">y^{(0)}(l \cdot M_{sc}^{PUSCH}+k)=\frac{1}{\sqrt{M_{sc}^{PUSCH}}}\sum_{i=0}^{M_{sc}^{PUSCH}-1}\widetilde x^{(0)}(l \cdot M_{sc}^{PUSCH}+i)e^{-j\frac{2\pi ik}{M_{sc}^{PUSCH}}}\\k =0,1,...,M_{sc}^{PUSCH}-1\\l=0,1,...,M_{symb}^{layer}/M_{sc}^{PUSCH}-1</script></li></ul><p>得到复值符号块 $y^{(0)}(0),…,y^{(0)}(M_{symb}^{layer}-1)$ 。$M_{sc}^{PUSCH} = M_{RB}^{PUSCH}\cdot M_{sc}^{RB}$，其中$M_{RB}^{PUSCH}$ 就是RB而言的带宽，并且满足</p><script type="math/tex;mode=display">M_{RB}^{PUSCH} = 2^{\alpha_2}\cdot 3^{\alpha_3}\cdot 5^{\alpha_5}\leq N_{RB}^{UL}</script><p>其中 $\alpha_2,\alpha_3,\alpha_5$ 是非负整数集合。</p><h3 id="1-2-5-预编码"><a href="#1-2-5-预编码" class="headerlink" title="1.2.5 预编码"></a>1.2.5 预编码</h3><p>根据如下公式对向量块$[y^{(0)}(i),…,y^{(v-1)}(i)]^{T},i = 0,1,…,M_{symb}^{layer}-1$ 进行预编码处理：</p><script type="math/tex;mode=display">\left[\begin{matrix} z^{(0)}(i)\\ \vdots\\ z^{(p-1)}(i) \end{matrix} \right]=W\left[\begin{matrix} y^{(0)}(i)\\ \vdots \\ y^{(p-1)}(i) \end{matrix} \right]</script><p>其中 $i = 0,1,…,M_{symb}^{ap} -1, M_{symb}^{ap} =M_{symb}^{layer}$ 。</p><p>RRC 参数如下：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txConfig				ENUMERATED &#123;codebook,nonCodebook&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于基于非码本的传输，预编码矩阵 <strong>W</strong> 为单位矩阵。<br>对于基于码本的传输，预编码矩阵 <strong>W</strong>：</p><ul><li><p>When number of layer = 1, number of antenna port = 1，<strong>W</strong> = 1。</p></li><li><p>When number of layer $\geq$ 1 and number of antenna port $\geq$ 2 ，</p><p>根据DCI 0-1中的 “Precoding information and number of layers” 确定预编码矩阵<strong>W</strong>(参考如下表格)：</p><blockquote><p>[TS 38.211 Table 6.3.1.5-1]<br>[TS 38.211 Table 6.3.1.5-2]<br>[TS 38.211 Table 6.3.1.5-3]<br>[TS 38.211 Table 6.3.1.5-4]<br>[TS 38.211 Table 6.3.1.5-5]<br>[TS 38.211 Table 6.3.1.5-6]<br>[TS 38.211 Table 6.3.1.5-7]</p></blockquote></li></ul><p>按照层数，天线端口数，是否配置变换预编码，三者的参数，选取预编码矩阵，总结成如下表格：</p><div class="table-container"><table><thead><tr><th>Number of Layers</th><th>Number of Antenna</th><th>Transform Precoding</th><th>Precoding Matrix</th></tr></thead><tbody><tr><td>1</td><td>2</td><td></td><td>211 Table 6.3.1.5-1</td></tr><tr><td>1</td><td>4</td><td>enabled</td><td>211 Table 6.3.1.5-2</td></tr><tr><td>1</td><td>4</td><td>disabled</td><td>211 Table 6.3.1.5-3</td></tr><tr><td>2</td><td>2</td><td>disabled</td><td>211 Table 6.3.1.5-4</td></tr><tr><td>2</td><td>4</td><td>disabled</td><td>211 Table 6.3.1.5-5</td></tr><tr><td>3</td><td>4</td><td>disabled</td><td>211 Table 6.3.1.5-6</td></tr><tr><td>4</td><td>4</td><td>disabled</td><td>211 Table 6.3.1.5-7</td></tr></tbody></table></div><h3 id="1-2-6-映射到VRB"><a href="#1-2-6-映射到VRB" class="headerlink" title="1.2.6 映射到VRB"></a>1.2.6 映射到VRB</h3><p>对于用于传输PUSCH的每个天线端口，复值符号块 $z^{(p)}(0),…,z^{(p)}(M_{symb}^{ap}-1)$ 应与幅度缩放因子$\beta_{PUSCH}$相乘，以满足[5,TS 38.213]中规定的发射功率。<br>对于每个天线步骤，都会创建一个虚拟资源网格。在资源网格内，从RE的最低频率到较高频率的来自来填充PUSCH数据到每个RE中。一旦它以分配的PUSCH资源块的最高频率到达RE，则移至下一个OFDM符号的最低频率的RE。</p><h3 id="1-2-7-映射到PRB"><a href="#1-2-7-映射到PRB" class="headerlink" title="1.2.7 映射到PRB"></a>1.2.7 映射到PRB</h3><p>按照之前的协议：有交织和非交织两种模式，和PDSCH一样。参考PDSCH映射规则。<br>按照现在<strong>最新版本</strong>的协议，只有<strong>非交织</strong>的模式。如下所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p6-VRB映射1.png" alt><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p7-VRB映射2.png" alt></p><h1 id="2-PUSCH-DMRS"><a href="#2-PUSCH-DMRS" class="headerlink" title="2 PUSCH DMRS"></a>2 PUSCH DMRS</h1><h2 id="2-1-序列生成"><a href="#2-1-序列生成" class="headerlink" title="2.1 序列生成"></a>2.1 序列生成</h2><p>有两种条件下DMRS序列生成方式，Transform Precoding disabled，Transform Precoding enabled。</p><h3 id="2-1-1-Transform-Precoding-disabled"><a href="#2-1-1-Transform-Precoding-disabled" class="headerlink" title="2.1.1 Transform Precoding disabled"></a>2.1.1 Transform Precoding disabled</h3><p>这种情况的生成方式是与PDSCH DMRS一样的：<br>PUSCH DMRS序列有如下公式生成：</p><script type="math/tex;mode=display">r(n) = \frac{1}{\sqrt{2}}(1-2\cdot c(2n))+j\frac{1}{\sqrt{2}}(1-2\cdot c(2n+1))</script><p>加扰序列采用31阶Gold序列生成，加扰序列的初始序列$c_{init}$如下式所示:</p><script type="math/tex;mode=display">c_{init} = (2^{17}(N_{symb}^{slot}n_{s,f}^{\mu}+l+1)(2N_{ID}^{\overline n_{SCID}^{\overline \lambda}}+1)+2^{17}\lfloor\frac{\overline \lambda}{2} \rfloor+2N_{ID}^{\overline n_{SCID}^{\overline \lambda}}+\overline n_{SCID}^{\overline \lambda})mod2^{31}</script><p>其中： $l$ 为时隙中的符号索引， $n_{s,f}$ 为时隙索引， $N_{symb}^{slot}$ 为一个时隙内的符号数量。</p><ul><li>$N_{ID}^0,N_{ID}^1\in\{0,1,…,65535\}$：分别由高层参数 <em>scramblingID0</em> 和 <em>scramblingID1</em> 给出 （如果配置的话，且PUSCH由 DCI format 0_1,0_2调度，或者是具有配置的授权的PUSCH传输）；</li><li>$N_{ID}^0\in\{0,1,…,65535\}$：由 <em>DMRS-UplinkConfig -&gt; scramblingID0</em> 给出（如果配置的话，且PUSCH由被 C-RNTI，MSC-C-RNTI，或者 CS－RNTI 加扰的 DCI format 0_0 调度）；</li><li>$N_{ID}^0,N_{ID}^1\in\{0,1,…,65535\}$：对于每个msgA PUSCH 配置，分别由高层参数 <em>msgA-DMRS-Configuration</em> -&gt; <em>msgA-scramblingID0</em> , <em>msgA-scramblingID1</em>给出（如果配置的话，且PUSCH传输是由Type-2随机接入过程触发的）；</li><li>$N_{ID}^{\overline n_{SCID}^{\overline \lambda}}=N_{ID}^{cell}$ otherwise；</li><li>$\overline n_{SCID}^{\overline \lambda}$ and $\overline \lambda$ 由高层参数 <em>DMRS-UplinkConfig -&gt; dmrs-Uplink-r16</em>给出，其中 $\lambda$ 是CDM group：<script type="math/tex;mode=display">N_{ID}^{\overline n_{SCID}^{\overline \lambda}}=\begin{cases}n_{SCID}\quad\quad\quad \lambda=0\quad or\quad\lambda = 2\\1-n_{SCID}\quad\quad \lambda=1 \end{cases}\\\overline \lambda = \lambda</script>否则<script type="math/tex;mode=display">N_{ID}^{\overline n_{SCID}^{\overline \lambda}}=n_{SCID}\\ \overline \lambda = 0</script>其中 $n_{SCID}\in \{0,1\}$：</li><li>如果使用DCI format 0_1 或者 0_2，则在与PUSCH传输相关的DCI中使用 DM-RS初始化字段（如果存在）</li><li>由高层参数 <em>dmrs-SeqInitialization</em> 给出（如果存在，且是具有配置的授权的Type 1 PUSCH传输，或者PUSCH传输是由Type-2随机接入过程触发的）；</li><li>否则 $n_{SCID} = 0$；</li></ul><h3 id="2-1-2-Transform-Precoding-enabled"><a href="#2-1-2-Transform-Precoding-enabled" class="headerlink" title="2.1.2 Transform Precoding enabled"></a>2.1.2 Transform Precoding enabled</h3><p>生成公式如下：</p><script type="math/tex;mode=display">r(n)=r_{u,v}^{(\alpha,\delta)}(n)\\n=0,1,...,M_{sc}^{PUSCH}/2^{\delta}-1</script><p>其中 $r_{u,v}^{(\alpha,\delta)}(n)$ 中 $\delta = 1,\alpha =0$</p><ul><li>如果高层参数 <em>dmrsUplinkTransformPrecoding-r16</em> 已配置，PUSCH使用 $\pi/3-BPSK$ 调制 ，且此次PUSCH传输不是 msg3，并且这次传输在CCS中并没有使用 DCI format 0_0 调度，$r_{u,v}^{(\alpha,\delta)}(n)$ 为低均峰比序列，见[TS 38.211 5.2.2~3]。</li></ul><p>序列组 $u = (f_{gh}+n_{ID}^{RS})mod30$，其中$n_{ID}^{RS}$由下面给出：</p><ul><li><p>$n_{ID}^{RS}=n_{ID}^{PUSCH}$，如果 $n_{ID}^{PUSCH}$ 由高层参数<em>DMRS-UplinkConfig</em> -&gt; <em>nPUSCH-Identity</em> 配置，而高层参数<em>dmrsUplinkTransformPrecoding-r16</em> 为配置，而且PUSCH既不是由RAR UL调度，也不是由利用TC-RNTI加扰的DCI format 0_0 调度的；</p></li><li><p>$n_{ID}^{RS}=n_{ID}^{PUSCH}$，如果 $n_{ID}^{PUSCH}$ 由高层参数<em>dmrs-UplinkTransformPrecoding-r16</em>配置，PUSCH 使用 $\pi/2-BPSK$ 调制，且此次PUSCH传输不是 msg3，并且这次传输在 CCS中并没有使用 DCI format 0_0 调度。</p></li><li>$n_{ID}^{RS} = N_{ID}^{cell}$ otherwise；</li></ul><p>其中 $f_{gh}$ 和 序列数 $v$ 由下面给出：</p><ul><li>如果既没有组跳变也没有序列跳变<script type="math/tex;mode=display">f_{gh}=0\\v-0</script></li><li>如果配置了组跳变，未配置序列跳变<script type="math/tex;mode=display">f_{gh} = (\sum_{m = 0}^{7}2^mc(8(N_{symb}^{slot}n_{s,f}^{\mu}+l)+m))mod30\\v=0\\c_{init}=\lfloor n_{ID}^{RS}/30 \rfloor</script></li><li>如果序列跳变配置，组跳变未配置<script type="math/tex;mode=display">f_{gs} = 0\\v=\begin{cases}v = c(N_{symb}^{slot}n_{s,f}^{\mu}+l) \quad if\quad M_{ZC}\geq 6N_{sc}^{RB}\\0\quad\quad\quad\quad\quad\quad\quad\quad\quad otherwise \end{cases}\\c_{init}=n_{ID}^{RS}</script></li></ul><p>跳变模式(hopping mode)由高层参数控制：</p><ul><li>如果PUSCH传输是由RAR UL 调度的，或者是由由TC-RNTI 加扰的 DCI format 0_0 调度的，此时序列跳变禁用，组跳变禁用启用于否由高层参数 <em>groupHoppingEnabledTransformPrecoding</em> 决定；</li><li>其他传输时，序列跳变和组跳变的禁用启用与否分别由高层参数 <em>sequenceHopping , sequenceGroupHopping</em> 决定（如果这些参数配置的话，否则将采用和Msg3一样的hopping mode）。</li></ul><p>UE 是并不期待同时处理序列跳变和组跳变的。</p><h2 id="2-2-资源映射"><a href="#2-2-资源映射" class="headerlink" title="2.2 资源映射"></a>2.2 资源映射</h2><p>序列 $r(m)$ 被 映射中间值为 $\widetilde \alpha_{k,l}^{(\widetilde p_j,\mu)}$ ，根据如下：</p><ul><li>①if transform precoding is not enable,<script type="math/tex;mode=display">\widetilde \alpha_{k,l}^{(\widetilde p_j,\mu)}=w_f(k')w_t(l')r(2n+k')\\k = \begin{cases}4n+2k'+\Delta \quad \quad Configuration\quad type\quad1\\6n+k'+\Delta\quad \quad Configuration\quad type\quad 2 \end{cases}\\k'=0,1\\l=\overline{l}+l'\\n = 0,1,...\\j=0,1,...,v-1</script></li><li>②if transform precoding is enable<script type="math/tex;mode=display">\widetilde \alpha_{k,l}^{(\widetilde p_j,\mu)}=w_f(k')w_t(l')r(2n+k')\\k=4n+2k'+\Delta\\k'=0,1\\l=\overline l+l'\\n=0,1,...</script>中间值 $\widetilde \alpha_{k,l}^{(\widetilde p_j,\mu)}$ 会经过预编码矩阵 <strong><em>W</em></strong> 和缩放因子 $\beta_{PUSCH}^{DMRS}$ , 最终映射为 $\alpha_{k,l}^{( p_j,\mu)}$，如下所示：<script type="math/tex;mode=display">\left[ \begin{matrix}\alpha_{k,l}^{( p_0,\mu)}\\ \vdots\\\alpha_{k,l}^{( p_{\rho-1},\mu)}  \end{matrix}\right]=\beta_{PUSCH}^{DMRS}W\left[ \begin{matrix}\widetilde \alpha_{k,l}^{( \widetilde p_0,\mu)}\\ \vdots\\ \widetilde \alpha_{k,l}^{(\widetilde p_{\rho-1},\mu)} \end{matrix} \right]</script></li></ul><h3 id="2-2-1-频域索引"><a href="#2-2-1-频域索引" class="headerlink" title="2.2.1 频域索引"></a>2.2.1 频域索引</h3><p>由以上可知</p><ul><li>① 情形时，DMRS的映射情况和PUSCH DMRS 一致</li><li>② 情形时，其频域映射规则只有Configuration Type 1</li></ul><p>需要注意的是，对于两种情况的参考点</p><ul><li>①情形时，其参考点是PUSCH RB#0</li><li>②情形时，其参考点是CRB#0</li></ul><h3 id="2-2-2-时域索引"><a href="#2-2-2-时域索引" class="headerlink" title="2.2.2 时域索引"></a>2.2.2 时域索引</h3><p>DMRS的符号位置取决于PDSCH的mapping type，分为mapping type A 和 mapping type B，如下表所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t2-38.214 6.1.2.1-1.png" alt></p><p>PUSCH 与 PDSCH 的差别除了初始符号位置和符号长度的些许区别外，还在于PUSCH 还会配置 <em>frequency intra-slot hopping</em> 方式，是否hopping 的两种方式下DMRS符号会有些差异。所以DMRS也会略有不同。<br>但是PUSCH和PDSC和的DMRS类似，PUSCH DMRS也支持：</p><ul><li><em>Front-loaded DM-RS</em>：支持单前置，双前置</li><li><em>Additional DM-RS</em>：支持单符号和双符号</li></ul><p>两种hopping下的DMRS：</p><ul><li>对于不跳频：其时域映射和PDSCH DMRS 机制一样，参考表[TS 38.211 6.4.1.1.3-3~4]</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t9-211 6.4.1.1.3-3.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t12-211.png" alt><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t10-211 6.4.1.1.3-4.png" alt></p><ul><li>对于跳频：其时域映射,参考表[TS 38.211 6.4.1.1.3-6],注意此时<strong>仅支持</strong>单前置+additional DMRS。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t13-211 6.4.1.1.3-6.png" alt></p><h2 id="2-3-天线端口问题"><a href="#2-3-天线端口问题" class="headerlink" title="2.3 天线端口问题"></a>2.3 天线端口问题</h2><p>PUSCH DMRS Type 1 和 Type 2 多天线端口CDM group 定义和PDSCH DMRS相同，仅仅是天线端口的编号差异。参考表格[TS 38.211 6.1.1.3-1,2,5]如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t7-211 6.4.1.1.3-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t8-211 6.4.1.1.3-2.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t14-211 6.4.1.1.3-5.png" alt></p><ul><li>type 1，single symbol情况下，最多支持4个端口，端口0，1和2，3分别在不同的CDM group，每个CDM group内，比如端口0和1，又通过频域的OCC来实现正交，从而实现4个端口的正交。</li><li>type 1，double symbol情况下，最多支持8个端口，除了频域OCC外，还可以时域OCC来实现正交，所以可以支持更多的端口。</li><li>type 2，single symbol情况下，最多支持6个端口，共三个CDM group，每个group内又通过频域OCC实现正交。</li><li>type 2，double symbol情况下，最多支持12个端口，与类型1双符号情况同理，除了频域OCC外，还可以时域OCC，从而支持更多的端口。</li></ul><h1 id="3-PUSCH-PTRS"><a href="#3-PUSCH-PTRS" class="headerlink" title="3 PUSCH PTRS"></a>3 PUSCH PTRS</h1><h2 id="3-1-序列生成"><a href="#3-1-序列生成" class="headerlink" title="3.1 序列生成"></a>3.1 序列生成</h2><p>有两种条件下PTRS序列生成方式，Transform Precoding disabled，Transform Precoding enabled。</p><h3 id="3-1-1-Transform-Precoding-disabled"><a href="#3-1-1-Transform-Precoding-disabled" class="headerlink" title="3.1.1 Transform Precoding disabled"></a>3.1.1 Transform Precoding disabled</h3><p>如果未使用变换预编码，层j上子载波k上的PTRS由下式给出：</p><script type="math/tex;mode=display">r^{(\widetilde p_j)}(m) = \begin{cases}r(m)\quad\quad if\quad j=j'||j =  j''\\0\quad\quad\quad\quad otherwise \end{cases}</script><ul><li>序列$r(m)$与对应的PUSCH的DMRS相同</li><li>不论是否跳频，PTRS的时域位置都在所在子载波的第一个DMRS符号上。</li><li><h3 id="3-1-2-Transform-Precoding-enabled"><a href="#3-1-2-Transform-Precoding-enabled" class="headerlink" title="3.1.2 Transform Precoding enabled"></a>3.1.2 Transform Precoding enabled</h3>如果未使用变换预编码，PTRS再DFT之前插入，此时PTRS映射位置m取决于PTRS group数量和每个group内sample的数量以及PUSCH总共所占的子载波的数量。序列生成公式如下所示：<script type="math/tex;mode=display">r_{m}(m')=w(k')\frac{e^{j\frac{\pi}{2}(mmod2)}}{\sqrt{2}}[(1-2c(m'))+j(1-2c(m'))]\\m'=N_{samp}^{group}s'+k'\\s'=0,1,...N_{group}^{PT-RS}-1\\k' = 0,1,N_{samp}^{group}-1\\c_{init}=(2^{17}(N_{symb}^{slot}n_{s,f}^{\mu}+l+1)(2N_{ID}+1)+2N_{ID})mod2^{31}</script>$w(i)$ 由下表给出：</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t4-211 6.4.1.2.1.2-1.png" alt></p><h2 id="3-2-资源映射"><a href="#3-2-资源映射" class="headerlink" title="3.2 资源映射"></a>3.2 资源映射</h2><p>同样对应着有两种条件下PTRS序列映射方式，Transform Precoding disabled，Transform Precoding enabled。</p><h3 id="3-2-1-Transform-Precoding-disabled"><a href="#3-2-1-Transform-Precoding-disabled" class="headerlink" title="3.2.1 Transform Precoding disabled"></a>3.2.1 Transform Precoding disabled</h3><p>UE只在高层信令指示PTRS传输下才传输，且只在PUSCH内传输PTRS，映射到RE的公式如下</p><script type="math/tex;mode=display">\left[ \begin{matrix}a_{k.l}^{(p_0,\mu)}\\ \vdots\\ a_{k.l}^{(p_{\rho-1},\mu)} \end{matrix} \right]=\beta_{PT-RS}W\left[ \begin{matrix}r^{(\widetilde p_0)}(2n+k')\\ \vdots\\ r^{(\widetilde p_v-1{})}(2n+k') \end{matrix} \right]\\k=\begin{cases}4n+2k'+\Delta\quad\quad configuration\quad type1\\6n+k'+\Delta\quad\quad\quad configuration\quad type2 \end{cases}</script><p>其中：</p><ul><li>$l$ 是PUSCH所占OFDM符号数；</li><li>RE未被DMRS占用；</li><li>$k’$ and $\Delta$ 对应 $\widetilde p_0,…,\widetilde p_{v-1}$</li><li>W是预编码矩阵</li><li>$\beta_{PT-RS}$ 是功率因子</li></ul><h4 id="3-2-1-1-时域索引"><a href="#3-2-1-1-时域索引" class="headerlink" title="3.2.1.1 时域索引"></a>3.2.1.1 时域索引</h4><p>确定时域索引$l$的方式如下：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. set i&#x3D;0 and l_&#123;ref&#125; &#x3D; 0 </span><br><span class="line">2. if any symbol in the interval max(l_&#123;ref&#125;+(i-1)L_&#123;PT-RS&#125; + 1,l_&#123;ref&#125;),…,l_&#123;ref&#125; + iL_&#123;PT-RS&#125; overlaps with a symbol used for DM-RS according to clause 6.4.1.1.3</span><br><span class="line">-	set i&#x3D;1</span><br><span class="line">-	set l_&#123;ref&#125; to the symbol index of the DM-RS symbol in case of a single-symbol DM-RS or to the symbol index of the second DM-RS symbol in case of a double-symbol DM-RS</span><br><span class="line">-	repeat from step 2 as long as l_&#123;ref&#125; +iL_&#123;PT-RS&#125; is inside the PUSCH allocation</span><br><span class="line">3. add l_&#123;ref&#125; + iL_&#123;PT-RS&#125; to the set of time indices for PT-RS</span><br><span class="line">4. increment i by one</span><br><span class="line">5. repeat from step 2 above as long as l_&#123;ref&#125; +iL_&#123;PT-RS&#125; is inside the PUSCH allocation</span><br><span class="line">where L_&#123;PT-RS&#125;∈&#123;1，2，4&#125; is defined in Table 6.2.3.1-1 of [6,TS 38.214].</span><br></pre></td></tr></table></figure><br>以上步骤简单描述如下：<br>$L_{PT-RS}$ 表示PTRS再时域上的密度，也就是每 $L_{PT-RS}$ 个符号有一个PTRS符号。配置方式为：从PUSCH开始调度的位置开始，直到PUSCH结束，每个L符号配置PTRS，如果碰到了DMRS，则重新开始计数。例如，PUSCH在一个slot内调度，即从$i = 0$ 开始，$i = 13$ 结束，$L_{PT-RS} = 4$，DMRS在 $l = 2$ 的符号上，则PTRS时域配置情形如下图所示：<p></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p8-PTRS1.png" alt></p><h4 id="3-2-1-2-频域索引"><a href="#3-2-1-2-频域索引" class="headerlink" title="3.2.1.2 频域索引"></a>3.2.1.2 频域索引</h4><p>(与PDSCH PTRS 几乎一样)<br>首先，假定分配给PUSCH的RB为从0到$N_{RB}-1$，那么分配给PUSCH的子载波范围就是0-$N_{sc}^{RB}N_{RB}-1$。最终PTRS频域索引$k$，由下面公式得到：</p><script type="math/tex;mode=display">k=k_{ref}^{RE}+(iK_{PT-RS}+k_{ref}^{RB})N_{sc}^{RB}\\k_{ref}^{RB}= \begin{cases}n_{RNTI}modK_{PT-RS} \quad \quad \quad if N_{RB}modK_{PT-RS} = 0 \\n_{RNTI}mod(N_{RB}modK_{PT-RS})\quad \quad otherwise\end{cases}</script><p>$k_{ref}^{RE}$ 由下表获得[TS 38.211-Table 6.4.1.2.2-1]：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t5-211 6.4.1.2.2.1-1.png" alt></p><p>由上可知，$K_{PT-RS}$为相邻 PTRS之间间隔的RB数，即相邻 PTRS之间相差$K_{PT-RS}\cdot N_{sc}^{RB}$ 个子载波，第一个PTRS 子载波定位是 $k_{ref}^{RE}+（0K_{PT-RS}+k_{ref}^{RB}）N_{sc}^{RB}$ 。大概的图样如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/PTRS频域图.png" alt></p><h3 id="3-2-2-Transform-Precoding-enabled"><a href="#3-2-2-Transform-Precoding-enabled" class="headerlink" title="3.2.2 Transform Precoding enabled"></a>3.2.2 Transform Precoding enabled</h3><p>此种情况PTRS是在DFT之前插入，插入的位置m与三个参数有关：PTRS的group数量，每个group内的sample数量和PUSCH所占子载波的数量，不同情况下的具体公式在下表中给出：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t6-211 6.4.1.2.2.2-1.png" alt></p><blockquote><p>参考目录<br>微信公众号：春天工作室，5G菜鸟成长日记<br>网页：<a href="https://mp.weixin.qq.com/s/83D25ABb2YURSbLQ3fOYsg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/83D25ABb2YURSbLQ3fOYsg</a><br>网页：<a href="https://mp.weixin.qq.com/s/SZwf4bJEzWa8RfJDiCC-CA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SZwf4bJEzWa8RfJDiCC-CA</a><br>网页：<a href="http://www.sharetechnote.com/html/5G/5G_PUSCH.html" target="_blank" rel="noopener">http://www.sharetechnote.com/html/5G/5G_PUSCH.html</a><br>网页：<a href="http://www.sharetechnote.com/html/5G/5G_PUSCH_TxMode.html" target="_blank" rel="noopener">http://www.sharetechnote.com/html/5G/5G_PUSCH_TxMode.html</a><br>博客：<a href="https://blog.csdn.net/kakamilan/article/details/104759214/" target="_blank" rel="noopener">https://blog.csdn.net/kakamilan/article/details/104759214/</a> （DMRS）<br>博客：<a href="https://blog.csdn.net/m0_45416816/article/details/105097130" target="_blank" rel="noopener">https://blog.csdn.net/m0_45416816/article/details/105097130</a> （PTRS）</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>PUSCH</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-PUCCH学习</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="1-PUCCH-信道"><a href="#1-PUCCH-信道" class="headerlink" title="1 PUCCH 信道"></a>1 PUCCH 信道</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>NR 中PUCCH物理信道是用来发送上行控制信息 Uplink Control information (UCI) (UCI 也可以在PUSCH信道上发送)，UCI的内容包括：信道状态信息CSI，HARQ的ACK/NACK，调度请求Scheduling Request（SR）及组合信息。</p><h2 id="1-2-低PAPR序列"><a href="#1-2-低PAPR序列" class="headerlink" title="1.2 低PAPR序列"></a>1.2 低PAPR序列</h2><p>PUCCH的序列生成及PUCCH DMRS都涉及低PAPR序列。其中除了format 2之外其他的格式都要涉及低PAPR序列。</p><script type="math/tex;mode=display">r_{u,v}^{(\alpha,\delta)}(n) = e^{j \alpha n}\overline r_{u,v}(n) , \quad 0 \leq n \leq M_{ZC}-1\\M_{ZC} = mN_{sc}^{RB}/2^{\delta}\\u \in \{0,1,...,29\}\\(v=0)\quad1/2\leq m/2^\delta \leq 5\\(v=0,1)\quad 6\leq m/2^\delta \quad\quad</script><h3 id="1-2-1-基序列生成"><a href="#1-2-1-基序列生成" class="headerlink" title="1.2.1 基序列生成"></a>1.2.1 基序列生成</h3><p>基序列的生成方式与序列长度有关：<br>$36 \leq M_{ZC}$:</p><script type="math/tex;mode=display">\overline r_{u,v}(n)=x_q(n\cdot modN_{ZC})\\x_q(m) = e^{-j\frac{\pi qm(m+1)}{N_{ZC}}}\\q = \lfloor \overline q +1/2\rfloor+v\cdot(-1)^{\lfloor 2\overline q \rfloor}\\\overline q = N_{ZC}\cdot (u+1)/31\\ max\quad prime\quad number\quad N_{ZC}<M_{ZC}</script><p>$M_{ZC} \in \{6,12,18,24\}$ ：可查表[TS 38.211 Table 5.2.2.2-1~4]，来确定$\varphi(n)$</p><script type="math/tex;mode=display">\overline r_{u,v}(n) = e^{j \varphi(n) \pi /4} , \quad 0 \leq n \leq M_{ZC}-1</script><p>$M_{ZC} = 30$:</p><script type="math/tex;mode=display">\overline r_{u,v}(n) = e^{-j\frac{\pi(u+1)(n+1)(n+2)}{31}},0\leq n\leq M_{ZC}-1</script><h3 id="1-2-2-Group-and-sequence-hopping"><a href="#1-2-2-Group-and-sequence-hopping" class="headerlink" title="1.2.2 Group and sequence hopping"></a>1.2.2 Group and sequence hopping</h3><p>对于PUCCH format 0/1/3/4使用Low PAPR sequence，其中的u和v取决于配置pucch-GroupHopping。<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pucch-GroupHopping			ENUMERATED&#123;neither,enable,disable&#125;,</span><br><span class="line">hoppingId					INTEGER(0...1024)</span><br></pre></td></tr></table></figure><br>其中的 hoppingId 配置的是 $n_{ID}$ , 如果未配置，则 $n_{ID} = N_{ID}^{cell}$<p></p><p>$u=(f_{gh}+f_{ss})mod30$</p><p>当 <em>pucch-GroupHopping = neither</em>：</p><script type="math/tex;mode=display">f_{gh} = 0,f_{ss} = n_{ID} mod 30,v = 0</script><p>当 <em>pucch-GroupHopping = enable</em>：</p><script type="math/tex;mode=display">f_{gh} = (\sum_{m = 0}^{7}2^mc(8(2n_{s,f}^\mu+n_{hop})+m))mod30\\f_{ss} = n_{ID} mod 30\\v = 0\\c_{init} = \lfloor n_{ID}/30 \rfloor</script><p>当 <em>pucch-GroupHopping = disabled</em>：</p><script type="math/tex;mode=display">f_{gh} = 0\\f_{ss} = n_{ID} mod 30\\v = c(2n_{s,f}^{\mu}+n_{hop})\\c_{init}=2^5\lfloor n_{ID}/30 \rfloor+(n_{ID}mod30)</script><p>其中：$n_{s,f}^{\mu}$ 为无线帧时隙号，跳变与否要看序列长度决定，短序列$: v = 0$ ； 长序列$:v=0,1$</p><p>注意：PUCCHGroupHopping意味着基序列组和序列的跳变，而非跳频。</p><h3 id="1-2-3-循环移位-alpha"><a href="#1-2-3-循环移位-alpha" class="headerlink" title="1.2.3 循环移位 $\alpha$"></a>1.2.3 循环移位 $\alpha$</h3><script type="math/tex;mode=display">r_{u,v}^{(\alpha,\delta)}(n)=e^{j \alpha n}\overline r_{u,v}(n)\\\alpha_l=\frac{2\pi}{N_{sc}^{RB}}((m_0+m_{cs}+n_{cs}(n_{s,f}^{\mu},l+l'))modN_{sc}^{RB})\\n_{cs}(n_{s,f}^{\mu},l) = \sum_{m = 0}^{7}2^m c(14 \cdot 8n_{s,f}^{\mu}+8l+m)\\c_{init} = n_{ID}</script><p>其中</p><ul><li>$m_0$ - PUCCH format 0/1：由 <em>initialCyclicShift</em> 给出，PUCCH format 3 : $m_0 = 0$，PUCCH format 4 由38.211 Table 6.4.1.3.3.1-1确定。</li><li>$m_{cs}$ - PUCCH format 0：根据HARQ应答信息确定，PUCCH format 1/3/4 ：$m_{cs} = 0$</li></ul><h3 id="1-2-4-应用"><a href="#1-2-4-应用" class="headerlink" title="1.2.4 应用"></a>1.2.4 应用</h3><p>在PUCCH应用中的大致流程如下，通过参数生成低PAPR序列，其长度取决于PUCCH映射到频域的PRB数，不同时域应用的是不同循环移位的低PAPR序列。</p><h2 id="1-3-PUCCH-format"><a href="#1-3-PUCCH-format" class="headerlink" title="1.3 PUCCH format"></a>1.3 PUCCH format</h2><p>NR中支持5种格式PUCCH，根据PUCCH信道占用时域符号长度分为</p><ul><li>短PUCCH：1-2个符号，PUCCH format 0，PUCCH format 2 能够支持更快捷的HARQ 应答/信道状态反馈，可用于超低时延场景</li><li>长PUCCH：4-14个符号，PUCCH format 1，PUCCH format 3，PUCCH format 4</li></ul><p>PUCCH 信道格式定义</p><div class="table-container"><table><thead><tr><th>PUCCH format</th><th>length in OFDM sysbols<br>$N_{symb}^{PUCCH}$</th><th>Number of bits</th></tr></thead><tbody><tr><td>0</td><td>1 - 2</td><td>$\leq 2$</td></tr><tr><td>1</td><td>4 - 14</td><td>$\leq 2$</td></tr><tr><td>2</td><td>1 - 2</td><td>$&gt; 2$</td></tr><tr><td>3</td><td>4 - 14</td><td>$&gt; 2$</td></tr><tr><td>4</td><td>4 - 14</td><td>$&gt; 2$</td></tr></tbody></table></div><ul><li><p>长格式 PUCCH format 1，3，4 可以支持<strong>时隙内</strong>和<strong>时隙间</strong>跳频</p></li><li><p>短格式 PUCCH format 0，2 可以支持<strong>时隙内</strong>跳频（2个符号时）</p></li></ul><p>当使用时隙内跳频时，第一跳($1^{st}hop$)发送的符号的数位$\lfloor N_{symb}^{PUCCH}/2 \rfloor$，其余的为第二跳。</p><p>在一个时隙内，可以发1 - 2 个PUCCH，至少有一个PUCCH 0 或者PUCCH 2</p><h3 id="1-3-1-format-0"><a href="#1-3-1-format-0" class="headerlink" title="1.3.1 format 0"></a>1.3.1 format 0</h3><h4 id="1-3-1-1-序列生成"><a href="#1-3-1-1-序列生成" class="headerlink" title="1.3.1.1 序列生成"></a>1.3.1.1 序列生成</h4><p>PUCCH 0 用于发送HARQ的ACK/NACK反馈，也可以携带SR信息。<br>PUCCH 0 发送的信息bit为1或者2（对应调度的PDSCH信道的两个Codeword时，也就是对应两个独立的可调制的数据块流）。<br>PUCCH 0 在频域上占用一个RB，在时域上占用1-2个符号。没有DMRS。<br>如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p1-format0.png" alt></p><p>PUCCH 0 高层相关配置参数：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUCCH-format0 ::&#x3D;		SEQUENCE&#123;</span><br><span class="line">	initialCyclicShift		INTEGER(0..11),  &#x2F;&#x2F;初始循环移位</span><br><span class="line">	nrofSymbols				INTEGER(1..2),	&#x2F;&#x2F;符号个数</span><br><span class="line">	startingSymbolIndex		INTEGER(0..13)	 &#x2F;&#x2F;开始符号索引，时隙内任意位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>NR中，使用PUCCH 0 发送ACK/NACK反馈（0-NACK，1-ACK）时，信息bit不需要经过编码→调制→映射到物理资源的过程。<br>通过ACK和NACK信息来选择PUCCH序列循环移位表示, 见[TS 38.213 Table 9.2.3-3(4)]:</p><div class="table-container"><table><thead><tr><th>HARQ-ACK Value</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>Sequence cyclic shift</td><td>$m_{cs}=0$</td><td>$m_{cs}=6$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>HARQ-ACK Value</th><th>{0,0}</th><th>{0,1}</th><th>{1,1}</th><th>{1,0}</th></tr></thead><tbody><tr><td>Sequence cyclic shift</td><td>$m_{cs}=0$</td><td>$m_{cs}=3$</td><td>$m_{cs}=6$</td><td>$m_{cs}=9$</td></tr></tbody></table></div><p>当PUCCH format 0,如果在一个时隙内，同时传输HARQ-ACK与SR请求时候$m_{cs}$也由HARQ-ACK bit的内容确定，但是其取值和上述表格不同，通过$m_{cs}$的取值，网络就能识别PUCCH format 0上是否同时包含了SR请求。</p><div class="table-container"><table><thead><tr><th>HARQ-ACK Value</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>Sequence cyclic shift</td><td>$m_{cs}=3$</td><td>$m_{cs} = 9$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>HARQ-ACK Value</th><th>{0,0}</th><th>{0,1}</th><th>{1,1}</th><th>{1,0}</th></tr></thead><tbody><tr><td>Sequence cyclic shift</td><td>$m_{cs}=1$</td><td>$m_{cs}=4$</td><td>$m_{cs}=7$</td><td>$m_{cs}=10$</td></tr></tbody></table></div><p><em>initialCyclicShift</em> 决定参数 $m_0$。</p><h4 id="1-3-1-2-资源映射"><a href="#1-3-1-2-资源映射" class="headerlink" title="1.3.1.2 资源映射"></a>1.3.1.2 资源映射</h4><script type="math/tex;mode=display">x(l\cdot N_{sc}^{RB}+n)=r_{u,v}^{(\alpha,\delta)(n)}\\n = 0,1,...,N_{sc}^{RB}-1\\l = \begin{cases} 0 \quad\quad for\quad single\quad symbol\quad PUCCH\quad transmision\\0,1 \quad for\quad double\quad symbol\quad PUCCH\quad transmision \end{cases}</script><p>映射顺序先频域 $k$，在时域 $l$。<br>PUCCH 0/1/2/3/4 使用的天线端口都是 $p = 2000$</p><h3 id="1-3-2-format-1"><a href="#1-3-2-format-1" class="headerlink" title="1.3.2 format 1"></a>1.3.2 format 1</h3><h4 id="1-3-2-1-序列生成"><a href="#1-3-2-1-序列生成" class="headerlink" title="1.3.2.1 序列生成"></a>1.3.2.1 序列生成</h4><p>PUCCH 1 属于长PUCCH，在时域占用符号个数4-14个，<u>承载的信息bit最多2个</u>，用于HARQ的ACK/NACK反馈，也可以携带SR（Scheduling Rquest，调度请求机制）信息。PUCCH 1 在频域上占用1个RB。如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p2-format1.png" alt></p><p>PUCCH 1 高层相关配置参数<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUCCH-format 1::&#x3D;			SEQUENCE&#123;</span><br><span class="line">	initialCyclicShift		INTEGER(0..11),	 &#x2F;&#x2F;初始循环移位</span><br><span class="line">	nrofSymbols				INTEGER(4..14),	 &#x2F;&#x2F;符号个数</span><br><span class="line">	startingSymbolIndex		INTEGER(0..10),  &#x2F;&#x2F;开始符号索引</span><br><span class="line">	timeDomainOCC			INTEGER(0..6)    &#x2F;&#x2F;时域OCC配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>PUCCH 1 的ACK/NACK反馈信息 1或者2 bits —1 表示ACK，0表示NACK；分别采用 $\pi / 2$ BPSK (1 bit) 和 QPSK （2 bits）调制，调制后为一个复值符号。<br>PUCCH 1 使用的序列和PUCCH 0 一样 $r_{u,v}^{(\alpha , \delta)}(n) = e^{j \alpha n} \cdot \overline r_{u,v}(n),0 \leq n &lt; M_{ZC}$，同样支持pucch-GroupHopping 配置。<br>调制后的复值符号，映射到序列后 $y(n) = d(0)\cdot r_{u,v}^{(\alpha , \delta)}(n)$。<p></p><h4 id="1-3-2-2-正交序列及资源映射"><a href="#1-3-2-2-正交序列及资源映射" class="headerlink" title="1.3.2.2 正交序列及资源映射"></a>1.3.2.2 正交序列及资源映射</h4><p>和 PUCCH 0不同的是，PUCCH 1支持基于时域正交序列的复用。</p><script type="math/tex;mode=display">z(m'N_{sc}^{RB}N_{SF,0}^{PUCCH,1}+mN_{sc}^{RB}+n)=w_i(m)\cdot y(n)\\n = 0,1,...,N_{sc}^{RB}-1\\m = 0,1...,N_{SF,m'}^{PUCCH,1}-1\\m'=\begin{cases} 0 \quad\quad no\quad intra-slot\quad frequencyhopping\\0,1 \quad intra-slot\quad frequencyhopping\quad enabled \end{cases}</script><p>其中：</p><ul><li>$z(n)$映射到物理资源</li><li>正交序列$w_i(m)$ 取决于[TS 38.211 Table 6.3.2.4.1-1~2]，下标$i$ 由 <em>timeDomainOCC</em> 决定。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/t1-211 6.3.2.4.1-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/t2-211 6.3.2.4.1-2.png" alt></p><h4 id="1-3-2-3-DMRS"><a href="#1-3-2-3-DMRS" class="headerlink" title="1.3.2.3 DMRS"></a>1.3.2.3 DMRS</h4><script type="math/tex;mode=display">z(m'N_{sc}^{RB}N_{SF,0}^{PUCCH,1}+mN_{sc}^{RB}+n)=w_i(m)\cdot r_{u,v}^{(\alpha,\delta)}(n)\\n = 0,1,...,N_{sc}^{RB}-1\\m = 0,1...,N_{SF,m'}^{PUCCH,1}-1\\m'=\begin{cases} 0 \quad\quad no\quad intra-slot\quad frequencyhopping\\0,1 \quad intra-slot\quad frequencyhopping\quad enabled \end{cases}</script><p>DMRS生成方式和format 1 基本相同，但有两处差别：</p><ul><li>正交序列后乘的直接是低PAPR序列，而不是复值块d(0)</li><li>$N_{SF,m’}^{PUCCH,1}$ 定义的表格略有不同，DMRS采用的是[TS 38.211 Table 6.4.1.3.1.1-1]</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/t2-211 6.4.1.3.1.1-1.png" alt></p><p>DMRS资源映射：</p><script type="math/tex;mode=display">\alpha_{k,l}^{p,\mu} = \beta_{PUCCH,1}Z(m)\\l=0,2,4...</script><p>由此可知，format 1 DMRS映射在偶数符号位置，从符号0开始，结束位置和配置的PUCCH 1符号个数相关。</p><h4 id="1-3-2-4-应用举例"><a href="#1-3-2-4-应用举例" class="headerlink" title="1.3.2.4 应用举例"></a>1.3.2.4 应用举例</h4><p>参数配置如下：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrofSymbols &#x3D; 8；</span><br><span class="line">no intra-slot frequencyhopping;</span><br><span class="line">intra-slot frequencyhopping enabled;</span><br><span class="line">timeDomainOCC &#x3D; i (具体看表格选取)</span><br></pre></td></tr></table></figure><p></p><ol><li>非时隙内跳频</li></ol><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p3-format1-例子1.png" alt></p><ol><li>时隙内跳频</li></ol><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p4-format1-例子2.png" alt></p><h3 id="1-3-3-format-2"><a href="#1-3-3-format-2" class="headerlink" title="1.3.3 format 2"></a>1.3.3 format 2</h3><p>PUCCH 2 在时域上占用1-2个符号，在频域上可以占1-16个RB。PUCCH 2时域符号少，适合用于低时延场景，支持较大信息量的UCI，其时频域资源如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p5-format2.png" alt></p><p>format 2 高层相关配置参数如下:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUCCH-format 2::&#x3D;			SEQUENCE&#123;</span><br><span class="line">	nrofPRBs				INTEGER(1..16)	 &#x2F;&#x2F;PRB数</span><br><span class="line">	nrofSymbols				INTEGER(1..2),	 &#x2F;&#x2F;符号个数</span><br><span class="line">	startingSymbolIndex		INTEGER(0..13),  &#x2F;&#x2F;开始符号索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="1-3-3-1-数据处理"><a href="#1-3-3-1-数据处理" class="headerlink" title="1.3.3.1 数据处理"></a>1.3.3.1 数据处理</h4><p>PUCCH format 2数据在[TS 38.211]的处理过程，先进行加扰，调制，然后进行时频映射。<br><strong>1. 加扰</strong><br>编码后的bits流： $b(0),…,b(M_{bit}-1)$，$M_{bit}$ 为编码后bits长度<br>加扰公式定义如下：</p><script type="math/tex;mode=display">\widetilde b(i) = (b(i)+c(i))mod2\\c_{init} = n_{RNTI}\cdot 2^{15}+n_{ID}</script><p>其中$n_{ID}\in \{0,1,…,1023\}$</p><ul><li>由 <em>dataScramblingIdentityPUSCH</em> 配置</li><li>否则，$n_{ID}=N_{ID}^{cell}$</li></ul><p>加扰后的输出bits流 ：$\widetilde b(0),…,\widetilde b(M_{bit}-1)$</p><p><strong>2. 调制</strong><br>加扰后的输出bits流：$\widetilde b(0),…,\widetilde b(M_{bit}-1)$，进行QPSK调制。<br>输出复值符号：$d(0),…,d(M_{symb}-1),M_{symb} = M_{bit}/2$</p><p><strong>3. 映射</strong><br>映射到物理资源，按照先频域$k$，在时域$l$ 的顺序，不能使用DMRS资源。参考下文DMRS的映射图示。</p><h4 id="1-3-3-2-DMRS"><a href="#1-3-3-2-DMRS" class="headerlink" title="1.3.3.2 DMRS"></a>1.3.3.2 DMRS</h4><p>PUCCH format 2 DMRS序列使用的不是低PAPR序列，所以PUCCH format 2中的DMRS序列与其他format 中相关的$m_0,m_{cs}$ 参数无关。<br>由如下公式生成序列：</p><script type="math/tex;mode=display">r_l(m)=\frac{1}{\sqrt{2}}(1-2c(2m))+j\frac{1}{\sqrt{2}}(1-2c(2m+1))\\m = 0,1,..\\c_{init}=(2^{17}(N_{symb}^{slot}n_{s,f}^{\mu}+l+1)(2N_{ID}^0+1)+2N_{ID}^0)mod2^{31}</script><p>其中$N_{ID}^0 \in \{0,1,…,65535\}$：</p><ul><li>由<em>scramblingID0 in the DMRS-UplinkConfig</em> 配置</li><li>否则，$N_{ID}^0 = N_{ID}^{cell}$</li></ul><p>DMRS在频域的映射方式是与数据在频域进行复用。</p><script type="math/tex;mode=display">\alpha_{k,l}^{(p,\mu)}=\beta_{PUCCH,2}r(m)\\k = 3m+1</script><p>若1RB，2 OFDM symbol情况，则如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p6-format2-例子1.png" alt></p><h3 id="1-3-4-format-3-4"><a href="#1-3-4-format-3-4" class="headerlink" title="1.3.4 format 3/4"></a>1.3.4 format 3/4</h3><p>PUCCH 3 在时域上占用4-14个符号，在频域上可以占用1-16个RB（2/3/5的倍数）,物理资源位置图略。<br>PUCCH 4 在时域上占用4-14个符号，在频域只占用1个RB，物理资源位置图略。</p><script type="math/tex;mode=display">M_{RB}^{PUCCH,s} = \begin{cases} 2^{\alpha_2}\cdot 3^{\alpha_3}\cdot 5^{\alpha_5}\quad PUCCH\quad format\quad 3\\1\quad\quad\quad\quad\quad\quad PUCCH\quad format\quad4 \end{cases}\\s \in \{3,4\}</script><p>PUCCH 3 高层相关配置参数<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUCCH-format 3::&#x3D;			SEQUENCE&#123;</span><br><span class="line">	nrofPRBs				INTEGER(1..16)	 &#x2F;&#x2F;PRB数</span><br><span class="line">	nrofSymbols				INTEGER(4..14),	 &#x2F;&#x2F;符号个数</span><br><span class="line">	startingSymbolIndex		INTEGER(0..10),  &#x2F;&#x2F;开始符号索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结合上面的公式可知 nrofPRBs $\in \{1,2,3,4,5,6,8,9,10,12,15,16\}$<p></p><p>PUCCH 4 高层相关配置参数<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUCCH-format 4::&#x3D;			SEQUENCE&#123;</span><br><span class="line">	nrofSymbols				INTEGER(4..14),	         &#x2F;&#x2F;符号个数</span><br><span class="line">	occ-Length				ENUMERATED&#123;n2,n4&#125;,       &#x2F;&#x2F;正交码个数</span><br><span class="line">	occ-Index				ENUMERATED&#123;n0,n1,n2,n3&#125;, &#x2F;&#x2F;正交码索引</span><br><span class="line">	startingSymbolIndex		INTEGER(0..10),          &#x2F;&#x2F;开始符号索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="1-3-4-1-数据处理"><a href="#1-3-4-1-数据处理" class="headerlink" title="1.3.4.1 数据处理"></a>1.3.4.1 数据处理</h4><p>PUCCH 3/4 的数据处理部分，主要是[TS 38.211]中的处理过程。<br>PUCCH 3/4 UCI经过编码，加扰，调制，分块传播 ，变换预编码，映射。（format 3 没有经过Block-wise spreading 流程，也就是不支持OCC，format 4 支持）</p><p><strong>1. 加扰</strong><br>编码后的bits流： $b(0),…,b(M_{bit}-1)$，$M_{bit}$ 为编码后bits长度<br>加扰公式定义如下：</p><script type="math/tex;mode=display">\widetilde b(i) = (b(i)+c(i))mod2\\c_{init} = n_{RNTI}\cdot 2^{15}+n_{ID}</script><p>其中$n_{ID}\in \{0,1,…,1023\}$</p><ul><li>由 <em>dataScramblingIdentityPUSCH</em> 配置</li><li>否则，$n_{ID}=N_{ID}^{cell}$</li></ul><p>加扰后的输出bits流 ：$\widetilde b(0),…,\widetilde b(M_{bit}-1)$</p><p><strong>2. 调制</strong><br>加扰后的输出bits流：$\widetilde b(0),…,\widetilde b(M_{bit}-1)$，默认QPSK调制，若配置$\pi /2$-BPSK，则使用$\pi /2$-BPSK。<br>输出复值符号：$d(0),…,d(M_{symb}-1)$，对于QPSK： $M_{symb} = M_{bit}/2$，对于$\pi /2$-BPSK：$M_{symb} = M_{bit}$</p><p><strong>3. 分块传播</strong><br>对于format 3 ，不应用Block-wise spreading ：</p><script type="math/tex;mode=display">y(lM_{sc}^{PUCCH,3}+k)=d(lM_{sc}^{PUCCH,3}+k)\\k =0,1,...,M_{sc}^{PUCCH,3}-1\\l=0,1,...,(M_{symb}/M_{sc}^{PUCCH,3})-1\\N_{SF}^{PUCCH,3} = 1</script><p>对于format 4，应根据数据应用 Block-wise spreading ：</p><script type="math/tex;mode=display">y(lM_{sc}^{PUCCH,4}+k)=w_{n}(k)\cdot d(l\frac{M_{sc}^{PUCCH,4}}{N_{SF}^{PUCCH,4}}+kmod\frac{M_{sc}^{PUCCH,4}}{N_{SF}^{PUCCH,4}})\\k =0,1,...,M_{sc}^{PUCCH,4}-1\\l=0,1,...,(N_{SF}^{PUCCH,4}M_{symb}/M_{sc}^{PUCCH,4})-1</script><p>其中：</p><ul><li>$M_{RB}^{PUCCH,4} = 1,N_{SF}^{PUCCH,4} \in \{2,4\}$</li><li>$w_n$ 由[TS 38.211 Table 6.3.2.6.3-1~2]给出</li><li>n 由 <em>occ-Index</em> 给出，当<em>occ-Length</em> = 2时，<em>occ-Index</em>可以配置0，1；当<em>occ-Length</em> = 4时，occ-Index可以配置0，1，2，3。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/t4-211 6.3.2.6.3-1~2.png" alt></p><p><strong>4. 变换预编码</strong><br>因为format 3 在频域可能支持有多个PRB分配，为了降低PAPR，需要进行Transform precoding，即采用DFT-s-OFDM<br>复值符号块：$y(0),…,y(N_{SF}^{PUCCH ,s}M_{symb}-1)$ ，根据如下公式进行预编码：</p><script type="math/tex;mode=display">z(l \cdot M_{sc}^{PUCCH,s}+k)=\frac{1}{\sqrt{M_{sc}^{PUCCH,s}}}\sum_{m=0}^{M_{sc}^{PUCCH,s}-1}y(l \cdot M_{sc}^{PUCCH,s}+m)e^{-j\frac{2\pi mk}{M_{sc}^{PUCCH,s}}}\\k =0,1,...,M_{sc}^{PUCCH,4}-1\\l=0,1,...,(N_{SF}^{PUCCH,s}M_{symb}/M_{sc}^{PUCCH,s})-1</script><p>变换预编码后输出：$z(0),…,z(N_{SF}^{PUCCH,s}M_{sybm}-1)$</p><p><strong>5. 映射</strong><br>变换预编码后的复值符号映射到物理资源，$\alpha_{k,l}^{(p,\mu)}=\beta_{PUCCH,s}r(m)$，按照先频域 $k$，在时域 $l$ 的顺序，不能使用DMRS资源。具体映射图参考下文DMRS映射部分。<br>PUCCH 3，4 都支持时隙内跳频。</p><h4 id="1-3-4-2-DMRS"><a href="#1-3-4-2-DMRS" class="headerlink" title="1.3.4.2 DMRS"></a>1.3.4.2 DMRS</h4><p>PUCCH 4 DMRS使用低PAPR序列 $r_{u,v}^{(\alpha , \delta)}(n) = e^{j \alpha n} \cdot \overline r_{u,v}(n),0 \leq n &lt; M_{ZC}$。<br>PUCCH 3 DMRS 也使用低PAPR序列 $r_{u,v}^{(\alpha , \delta)}(n) = e^{j \alpha n} \cdot \overline r_{u,v}(n),0 \leq n &lt; M_{ZC}$，但与 format 0/1/4 不同的是，format 3 在频域可以配置多个PRB，所以序列长度 $M_{ZC}$ 可变。具体情况参考前文低PAPR序列描述。需要注意的是，对于PUCCH 3：$m_0 = 0,m_{cs} = 0$。对于PUCCH 4，其$m_{cs}=0，m_0$ 取决于[TS 38.311 Table 6.4.1.3.3.1-1]中，如下。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/t5-211 6.4.1.3.3.1-1.png" alt></p><p><strong>1. format 3/4 的DMRS序列</strong></p><script type="math/tex;mode=display">r_l(m) = r_{u,v}^{(\alpha , \delta)}(m)\\m=0,1,...,M_{sc}^{PUCCH,s}-1</script><p><strong>2. 映射到物理资源</strong></p><script type="math/tex;mode=display">\alpha_{k,l}^{(p,\mu)}=\beta_{PUCCH,s}r(m)\\m = 0,1,...,M_{sc}^{PUCCH,s}-1</script><p>$l$ 的位置定义如下：additional DM-RS 由高层参数配置，参考[TS 38.211 Table 6.4.1.3.3.2-1]，如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/t6.211 6.4.1.3.3.2-1.png" alt></p><p>若，format 4，PUCCH length = 14 ；资源映射如下图：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p7-format34.png" alt></p><h3 id="1-4-格式总结"><a href="#1-4-格式总结" class="headerlink" title="1.4 格式总结"></a>1.4 格式总结</h3><p>各种格式的配置情况总结如下图所示：图片摘自 ShareTechnote</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p8-格式总结.png" alt></p><h1 id="2-PUCCH-资源"><a href="#2-PUCCH-资源" class="headerlink" title="2 PUCCH 资源"></a>2 PUCCH 资源</h1><h2 id="2-1-PUCCH-资源确定"><a href="#2-1-PUCCH-资源确定" class="headerlink" title="2.1 PUCCH 资源确定"></a>2.1 PUCCH 资源确定</h2><h2 id="2-2-PUCCH-资源集选择"><a href="#2-2-PUCCH-资源集选择" class="headerlink" title="2.2 PUCCH 资源集选择"></a>2.2 PUCCH 资源集选择</h2><p>还没看完，没来得及总结</p><blockquote><p>参考文献<br>公众号：春天工作室，5G菜鸟成长日记<br>网页：<a href="https://mp.weixin.qq.com/s/83D25ABb2YURSbLQ3fOYsg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/83D25ABb2YURSbLQ3fOYsg</a><br>网页：<a href="http://www.sharetechnote.com/html/5G/5G_PUCCH.html" target="_blank" rel="noopener">http://www.sharetechnote.com/html/5G/5G_PUCCH.html</a><br>博客：<a href="https://blog.csdn.net/bluewhu/article/details/104196665" target="_blank" rel="noopener">https://blog.csdn.net/bluewhu/article/details/104196665</a><br>博客：<a href="https://blog.csdn.net/m0_45416816/article/details/104968797" target="_blank" rel="noopener">https://blog.csdn.net/m0_45416816/article/details/104968797</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>PUCCH</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-PRACH学习</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="1-PRACH-信道"><a href="#1-PRACH-信道" class="headerlink" title="1 PRACH 信道"></a>1 PRACH 信道</h1><h2 id="1-1-PRACH-preamble-生成"><a href="#1-1-PRACH-preamble-生成" class="headerlink" title="1.1 PRACH preamble 生成"></a>1.1 PRACH preamble 生成</h2><p>LTE系统中使用Zaddof-Chu (ZC) 序列作为PRACH信道的上行同步序列，因为其具有良好的<strong>自相关</strong>和<strong>互相关性</strong>，<strong>恒幅低峰均比</strong>等特性。</p><p>①<strong>自相关</strong>：对于任意ZC原始序列与其循环移位n位后所得到的序列互不相关；<br>②<strong>互相关</strong>：互相关和部分相关值接近零，便于接收端准确地把所需的信号检测出来；<br>③<strong>恒幅低峰均比</strong>：保证相应带宽内的每个频点经理相同的激励，便于实现想干检测中的无偏估计；<br>在PRACH信道上发送的ZC序列，也被称为PRACH Preamble，前导码。LTE支持两种长度的ZC序列，根据根索引序列，通过循环移位生成多个序列</p><script type="math/tex;mode=display">N_{ZC} = 839\\N_{ZC} = 139</script><p>NR 中的PRACH信道沿用了LTE的ZC序列设计，支持两种长度ZC序列，和LTE一致，也通过循环移位生成多个序列，只是符号名称不同，含义都是相同的。</p><script type="math/tex;mode=display">L_{RA} = 839\\L_{RA} = 139</script><p>ZC 序列定义：$x_u(i) = e^{-j \frac{\pi u(i+1)}{L_{RA}}},i = 0,1,…,L_{RA}-1$</p><p>经过循环移位后，ZC序列集合为：$x_{u,v}(n)=x_u((n+C_v)modL_{RA})$</p><p>具体的生成流程如下图所示:<br><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p1-preamble生成.png" alt></p><p>举例说明，参数如下：<br><em>prach-ConfigurationIndex</em> 2<br><em>zeroCorrelationZoneConfig</em> = 6<br><em>restrictedSetConfig</em> <em>unrestrictedSet</em><br><em>prach-RootSequenceIndex</em> l839 : 20</p><p>首先根据 <em>prach-ConfigurationIndex 2</em> ，查表[TS 38.211 Table 6.3.3.2-2] 可知 Format 0 即long symbol 类型，也就是$L_{RA} = 839$, 之后查表[TS 38.211 Table 6.3.3.1-3]<br>根据 <em>prach-RootSequenceIndex</em> l839 : 20 可知：$u = 2$ , 并通过ZC序列定义公式生成$x_2(n)$序列。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T4-38.211-6.3.3.1-3(4" alt>副本.png)</p><p>由 <em>zeroCorrelationZoneConfig</em> = 6；<em>restrictedSetConfig unrestrictedSet</em>。<br>查表[TS 38.211 Table 6.3.3.1-1]可知$\Delta f_{RA} = 1.25$KHz<br>再查表[TS 38.211 6.3.3.1-5]可知$N_{CS} = 32$。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/Inked38.211-6.3.3.1-5_LI.jpg" alt></p><p>根据公式可知$v = 0,1,…,\lfloor L_{RA}/N_{CS} \rfloor - 1 = 0,1,…,\lfloor 839/32 \rfloor -1 = 0,1,…,25$，所以$C_v = v \cdot N_{CS} = v \cdot 32 = [0,32,64,…,800]$，这样可以获得 $x_2(n)$ 的26种循环移位后的序列，也就是获得了26个preamble 序列。</p><p>因为 26 &lt; 64，所以根索引会递增为 <em>prach-RootSequenceIndex</em> l839 : 21，对应的$u = 837$，操作与上文相同，又可以生成26个preamble序列。<br>因为 52 &lt; 64，所以根索引会递增为 <em>prach-RootSequenceIndex</em> l839 : 22，对应的$u = 1$，操作与上文相同，这次只用生成12个preamble序列即可。</p><p>经过以上步骤，就获得了64个preamble序列，对其做DFT就是其频域表达。</p><h2 id="1-2-PRACH-preamble-格式"><a href="#1-2-PRACH-preamble-格式" class="headerlink" title="1.2 PRACH preamble 格式"></a>1.2 PRACH preamble 格式</h2><p>Preamble总体上分为两大类，long preamble和short preamble，分别对应$L_{RA} = 839,L_{RA} = 139$。其中long preamble分为四种Format,分别为Format 0/1/2/3，short preamble分为九种A1/A2/A3/B1/B2/B3/B4/C0/C2。配置如下表所示:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T1-38.211-6.3.3.1-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T2-38.211-6.3.3.1-2.png" alt></p><p>需要的一些基础参数如下：</p><script type="math/tex;mode=display">T_c = 1/(\Delta f_{max}\cdot N_f) = 1/(480\times 10^3\cdot 4096) = 0.509ns = 0.509\times10^{-6}ms\\T_s = 1/(\Delta f_{ref}\cdot N_{f,ref}) = 1/(15\times 10^3\cdot 2048) = 32.552ns = 32.552\times10^{-6}ms\\K = \frac{T_s}{T_c} = 64</script><p>Preamble结构一般由三部分组成：Cyclic Prefix(CP) + Preamble Sequence (重复) + Guard Period(GP)，其中核心部分preamble sequence可能重复多次，取决于不同的Format。</p><table><tr><td><center></center></td><td><center>PRACH preamble 格式</center></td><td><center>特点</center></td></tr><tr><th rowspan="4"><center>long preamble</center></th><td><center>Format 0</center></td><td><center>时长1ms; 用于普通场景</center></td></tr><tr><td><center>Format 1</center></td><td><center>时长3ms; 用于超远距离覆盖场景</center></td></tr><tr><td><center>Format 2</center></td><td><center>时长3.5ms; 其中sequence重复发送4次,用于需要覆盖增强场景(如室内)</center></td></tr><tr><td><center>Format 3</center></td><td><center>时长1ms; 用于高速移动场景</center></td></tr><tr><th rowspan="3"><center>short preamble</center></th><td><center>Format A1/A2/A3</center></td><td><center>时长和2,4,6个OFDM符号对齐; 没有GAP; 用于覆盖距离较近,UE位置集中的场景</center></td></tr><tr><td><center>Format B1/B2/B3/B4</center></td><td><center>时长和2,4,6,12个OFDM符号对齐; 有GAP</center></td></tr><tr><td><center>Format C0/C2</center></td><td><center>时长和2,6个OFDM符号对齐; 有GAP,且相对于其他类型较长; 用于较远距离场景</center></td></tr></table><p>以下为各种格式的细节:<strong>图片摘自ShareTechnote</strong></p><p><strong>long preamble 分为四种 Format , 分别为 Format 0/1/2/3</strong></p><p>Format 0:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p2-Format 0.png" alt></p><p>Format 1:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p3-format 1.png" alt></p><p>Format 2:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/format2.png" alt></p><p>Format 3:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p5-format 3.png" alt></p><p><strong>short preamble 分为九种 Format A1/A2/A3/B1/B2/B3/B4/C0/C2</strong></p><p>格式 A 没有定义GAP，适用于覆盖距离较近，UE位置集中的场景</p><p>Format A1: PRACH时长和 <strong>2 OFDM symbol</strong> 对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p6-format A1.png" alt></p><p>Format A2: PRACH时长和 <strong>4 OFDM symbol</strong> 对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p7-format A2.png" alt></p><p>Format A3: PRACH时长和 <strong>6 OFDM symbol</strong> 对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p8-format A3.png" alt></p><p>格式B 定义了GAP</p><p>Format B1: PRACH时长和 <strong>2 OFDM symbol </strong>对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p9-format B1.png" alt></p><p>Format B2: PRACH时长和 <strong>4 OFDM symbol </strong>对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p10-format B2.png" alt></p><p>Format B3: PRACH时长和 <strong>6 OFDM symbol</strong> 对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p11-format B3.png" alt></p><p>Format B4: PRACH时长和 <strong>12 OFDM symbol</strong> 对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p12-format B4.png" alt></p><p>格式C 定义了GAP，且GAP保护时长较大，适用于覆盖距离较远的场景</p><p>Format C0: PRACH时长和 <strong>2 OFDM symbol</strong> 对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p-13format C0.png" alt></p><p>Format C2: PRACH时长和 <strong>6 OFDM symbol</strong> 对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p14-format C2.png" alt></p><p>补充： 如果PRACH Format指示为 A1/B1，A2/B2，A3/B3（混合格式）时，则一个PRACH时隙中最后一个PRACH Occasion 为Format B1/B2/B3，一个PRACH时隙中，前面位置的PRACH Occasion为Format A1/A2/A3。（Format A1/2/3，B1/2/3时长一致(2/4/6 OFDM 符号)，差别在于CP和GAP长度，Format A 无GAP）</p><h2 id="1-3-映射到物理资源"><a href="#1-3-映射到物理资源" class="headerlink" title="1.3 映射到物理资源"></a>1.3 映射到物理资源</h2><p>PRACH信道时域信号定义如下：</p><script type="math/tex;mode=display">s_l^{(p,\mu)}(t)=\sum_{k=0}^{L_{RA}-1}{a_k}^{(p,RA)}\cdot e^{j2\pi(k+Kk_1+\overline k)\Delta f_{RA}(t-N_{CP,l}^{RA}T_c-t_{start}^{RA})}\\K = \Delta f/\Delta f_{RA}\\k_1 = k_0^\mu+N_{BWP,i}^{start}N_{sc}^{RB}+n_{RA}N_{RB}^{RA}N_{sc}^{RB}-N_{grid}^{size,\mu}N_{sc}^{RB}/2\\k_0^\mu = (N_{grid}^{start,\mu}+N_{grid}^{size,\mu}/2)N_{sc}^{RB}-(N_{grid}^{start,\mu_0}+N_{grid}^{size,\mu_0}/2)N_{sc}^{RB}2^{\mu_0-\mu}</script><p>其中 $t_{start}^{RA}\leq t &lt;t_{start}^{RA}+(N_u+N_{CP,l}^{RA})T_c$<br>$\alpha_k^{(p,RA)} = \beta_{PRACH}\cdot y_{u,v}(k)$</p><p>$t_{start}^{RA}$ 表示PRACH preamble</p><ul><li>在一个子帧中的开始位置 —- （ $\Delta f_{RA} \in \{1.25,5,15,30\}$KHz ）</li><li>或者在一个60 KHz的时隙中的位置 —- （ $\Delta f_{RA} \in \{60，120\}$KHz ）</li></ul><h3 id="1-3-1-时域资源映射"><a href="#1-3-1-时域资源映射" class="headerlink" title="1.3.1 时域资源映射"></a>1.3.1 时域资源映射</h3><p>从公式着手：</p><script type="math/tex;mode=display">t_{start}^{RA} = t_{start,l}^\mu \\t_{start,l}^{\mu} = \begin {cases} 0 \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad l = 0\\ t_{start,l-1}^\mu +(N_u^\mu + N_{CP,l-1}^{\mu})T_c \quad \quad otherwise \end{cases}</script><p>符号位置$l$ , $l = l_0+n_t^{RA}N_{dur}^{RA}+14n_{slot}^{RA}$</p><p>其中：</p><ul><li>$l_0$ 为起始符号位置，根据配置表格获得</li><li>$n_t^{RA}$ 为一个PRACH时隙内的PRACH发送时刻，$n_t^{RA} \in \{0,…,N_t^{RA,slot}-1\}$, $L_{RA}= 839$ 时固定为1, $L_{RA} = 139$ 时根据配置表格得到</li><li>$N_{dur}^{RA}$ 根据PRACH配置索引表格得到，和各自格式对应</li><li>$\Delta f_{RA} \in \{1.25,5\}$KHz $\mu = 0$ , 其他情况下，$\mu$按照子载波间隔配置</li><li>$n_{slot}^{RA}$ : ① $\Delta f_{RA} \in \{1.25,5,15,60\}$KHz 时，$n_{slot}^{RA} = 0$ 。② $\Delta f_{RA} \in \{30,120\}$KHz 时，根据配置表格得到(倒数第三列)，如果配置为1，则$n_{slot}^{RA} = 1$ 。③ 其他情况，$n_{slot}^{RA}\in \{0,1\}$</li></ul><p>以上配置表格参考协议中的表格，见附录</p><blockquote><p>[TS 38.211 Table 6.3.3.2-2]<br>[TS 38.211 Table 6.3.3.2-3]<br>[TS 38.211 Table 6.3.3.2-4]</p></blockquote><p>对于时域资源的映射，只需要知道初始符号位置即可，应为特定的Format对应的preamble时域时长时确定的。</p><p>示例说明：<em>prach-ConfigurationIndex</em> = 103，查表可知参数如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p15-时域举例1-1 (1" alt>.png)<br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p16-时域举例1-2.png" alt></p><p>利用上文公式可知，时域资源映射位置，如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p17-时域举例1-3.png" alt><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p18-时域举例1-4.png" alt></p><h3 id="1-3-2-频域资源映射"><a href="#1-3-2-频域资源映射" class="headerlink" title="1.3.2 频域资源映射"></a>1.3.2 频域资源映射</h3><p>PRACH的频域资源主要由两个参数“<strong><em>msg1-FrequencyStart</em></strong>”和“<strong><em>msg1-FDM</em></strong>”决定。频域资源映射主要要确定PRACH频域资源的起始位置，以及PRACH频域占多少个RB。</p><ul><li>PRACH子载波间隔，1.25 5 15 30 60 120 KHz</li><li>PRACH资源在频域上的个数，即频域上的PRACH transmission Occasions, 也称为FDM个数，配置范围(1/2/4/8)个，对应高层参数为 <strong><em>msg1-FDM</em></strong></li><li>PRACH 第一个频域资源，在频域的起始位置，相对于上行激活BWP（上行初始BWP）中PRB 0的偏移位置，对应高层参数为 <strong><em>msg1-FrequencyStart</em></strong></li></ul><p>多个PRACH transmission occasions 在频域上连续放置。</p><p>PRACH频域资源具体情况，在[TS 38.211 Table 6.3.3.2-1]描述</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T3-38.211-6.3.3.2-1.png" alt></p><p>其中$\overline k $ 为下边缘子载波保护个数。分析表格可知，$(\Delta f/\Delta f^{RA}) \cdot N_{RB}^{RA} \cdot N_{sc}^{RB} $ 为 PRACH 占用的子载波数，实际发送使用$L_{RA}$ 个子载波。举个例子，对于第一行：PRACH占用的子载波数 = $(15/1.25)<em>6</em>12 = 864$ 个子载波，实际发送使用 <strong><em>839</em></strong> 个子载波。</p><p>根据1.3节上PRACH信道时域信号</p><p>其中：</p><ul><li>$\mu_0$ 为UE配置的子载波中最大的 $\mu$ 值</li><li>$N_{BWP,i}^{start}$ 为配置的上行初始BWP（或者激活上行BWP）的最低RB索引</li><li>$n_{RA}^{start}$ 为配置的PRACH频域资源在BWP（初始或激活）中的最低RB索引，对应高层参数<em>msg1-FrequencyStar</em></li><li>$n_{RA} \in \{0,1,…,M-1\}$ 表示PRACH transmission occasion 的索引，从0到M，M为配置的PRACH频域资源的PRACH频域资源个数对应的高层参数 <em>msg1-FDM</em> 其取值范围是1，2，4，8</li></ul><p>频域资源位置参考如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p19-频域映射.png" alt></p><h2 id="1-4-SSB和RACH信道配置"><a href="#1-4-SSB和RACH信道配置" class="headerlink" title="1.4 SSB和RACH信道配置"></a>1.4 SSB和RACH信道配置</h2><h3 id="1-4-1-概述"><a href="#1-4-1-概述" class="headerlink" title="1.4.1 概述"></a>1.4.1 概述</h3><p>基站按照前文步骤生成了 preamble，并通过广播发送给UE，UE也知道了PRACH的时频域资源位置，在把preamble放在某个PRACH上发出去之前，还差最关键的一步，那就是基站要确定PRACH与SSB的映射关系。<br>5G里面凡事都会涉及到Beam这个概念，RACH流程也不例外。一个5G小区会发射多个SSB，也就是说有很多个下行的beam。终端会monitor和测量这些beam，挑选一个信号最好的SSB或者beam进行驻留。很明显，终端要获得比较好的上下行传输性能，需要与基站建立一个beam pair(发送beam和接收beam)。这里要强调一点，beam是分发送和接收的，并不是只有发送有beam，接收也有。另外，说到发送beam和接收beam，这里要区分上下行。</p><ul><li>上行（UE -&gt; gNB）: beam pair指基站接收beam，终端发送beam</li><li>下行（gNB -&gt; UE）: beam pair指终端接收beam，基站发送beam</li></ul><p><strong>大致的流程</strong>如下：</p><ol><li>基站：根据逻辑根索引配置生成64个preamble，通过多组beam广播生成信息给UE。</li><li>UE：接收，并测量出最佳的波束方向，随机选取preamble index，选择一个CB preamble，然后以最佳的波束方向反向发送PRACH给基站。</li><li>基站：接收到UE的PRACH，并通过SSB与PRACH之间的关联（SSB仅与CB preamble相关联）确定基站与UE之间的最佳波束方向，以后通过该波束方向向UE发送后续数据。</li></ol><p>简而言之，就是PRACH的发送时刻（RO，RACH occasion，PRACH occasion）需要和SSB发送的时刻（SSB index）建立映射关系。基站根据UE上行PRACH的资源位置，决定下行RAR（RA response）发送的波束。</p><h3 id="1-4-2-SSB与RO映射顺序"><a href="#1-4-2-SSB与RO映射顺序" class="headerlink" title="1.4.2 SSB与RO映射顺序"></a>1.4.2 SSB与RO映射顺序</h3><p>RACH参数配置中<strong><em>ssb-perRACH-OccasionAndCB-PreamblesPerSSB</em></strong>用于配置：</p><ul><li>每个RACH时刻对应的SSB个数 N ，取值可以为 1/8 1/4 1/2 1 2 4 8 16</li><li>每个SSB在一个RO内所能使用的基于竞争的Preamble个数，R（其实就是按SSB数平分CB-preambles）</li></ul><p>① <strong><em>ssb-perRACH-Occasion</em></strong> &gt;=1,即 N &gt; = 1时，表示一个RACH Occasion 对应多个SSB<br>② <strong><em>ssb-perRACH-Occasion</em></strong> &lt;1 , 表示一个SSB对应多个RACH Occasion</p><p>SSB和RO的映射遵循以下原则：</p><ul><li>首先，在一个RO内按照preamble index的升序映射</li><li>其次，按照频域RO升序映射</li><li>然后，按照一个PRACH slot内时域RO升序映射</li><li>最后，按照PRACH slot升序映射</li></ul><p>以下举4个例子说明一下:<br>(1) <em>ssb-perRACH-Occasion</em> = 1/4 , <em>msg1-FDM</em> = 4 $L_{max} = 4$ (也即 SSB个数), SSB 与PRACH occasion映射示意图如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p20-SSB-PRACH例子1.png" alt></p><p>(2) <em>ssb-perRACH-Occasion</em> = 1/2 , <em>msg1-FDM</em> = 4 $L_{max} = 8$ , SSB 与PRACH occasion映射示意图如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p21-SSB-PRACH例子2.png" alt></p><p>(3) <em>ssb-perRACH-Occasion</em> = 1 , <em>msg1-FDM</em> = 4 $L_{max} = 8$ , SSB 与PRACH occasion映射示意图如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p22-SSB-PRACH例子3.png" alt></p><p>(4) <em>ssb-perRACH-Occasion</em> = 2 , <em>msg1-FDM</em> = 2 $L_{max} = 16$ , SSB 与PRACH occasion映射示意图如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p23-SSB-PRACH例子4.png" alt></p><h3 id="1-4-3-SSB-和-RACH-映射周期"><a href="#1-4-3-SSB-和-RACH-映射周期" class="headerlink" title="1.4.3 SSB 和 RACH 映射周期"></a>1.4.3 SSB 和 RACH 映射周期</h3><p>PRACH在时域和频域上有多个发送时刻，每个SSB块要和PRACH发送时刻建立映射关系。同时引入一个<strong><em>association period</em></strong> 映射周期的概念，即表示所有的SSB块全部映射到RO后，需要在时域上多少个PRACH周期。<br>映射周期从帧号0开始。所有SSB至少映射一次后，“多余”的RO，没有SSB映射的话，这些RO不用。<br><strong><em>Association pattern period</em></strong> — 映射图样周期，包含1个或者多个映射周期<strong><em>association periods</em></strong>，为160 ms ,每隔160 ms 重复进行PRACH和SSB的映射。</p><p>举例说明:<br>若<strong><em>ssb-perRACH-Occasion</em></strong> = 1/2 , <strong><em>msg1-FDM</em></strong> = 4 $L_{max} = 4$ , PRACH 周期为 1 Frame = 10 ms，每一个 Frame 中只有一个subFrame 有时域 Occasion ,每一个 subFrame 中 只有一个 时域 occasion 。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p24-SSB周期.png" alt></p><h1 id="2-随机接入过程"><a href="#2-随机接入过程" class="headerlink" title="2 随机接入过程"></a>2 随机接入过程</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>终端成功解出SSB后便获得了NR系统的下行同步，要想完成上行同步以并与NR网络建立RRC连接，那么随机接入RACH流程必不可少。</p><h3 id="2-1-1-随机接入触发场景"><a href="#2-1-1-随机接入触发场景" class="headerlink" title="2.1.1 随机接入触发场景"></a>2.1.1 随机接入触发场景</h3><p>下面这10条RACH触发原因摘自协议38.300。其中第7、9和10条是NR系统新出现的，也是在以往LTE中没有的。其中第7条是指由RRC_Inactive状态向RRC_Connected状态转换，RRC_Inactive状态是NR中新引入的一种RRC状态；第9条是指对于NR系统中一些不广播的系统消息Other SI，UE采用随机接入流程“按需索要”这些不广播的系统消息；第10条是指beam failure后的恢复流程。</p><blockquote><p>1）Initial access from RRC_IDLE;<br>2）RRC Connection Re-establishment procedure;<br>3）DL or UL data arrival during RRC_CONNECTED when UL synchronisation status is “non-synchronised”;<br>4）UL data arrival during RRC_CONNECTED when there are no PUCCH resources for SR available;<br>5）SR failure;<br>6）Request by RRC upon synchronous reconfiguration (e.g. handover);<br>7）Transition from RRC_INACTIVE;<br>8）To establish time alignment for a secondary TAG;<br>9）Request for Other SI;<br>10）Beam failure recovery.</p></blockquote><h3 id="2-1-2-随机接入流程"><a href="#2-1-2-随机接入流程" class="headerlink" title="2.1.2 随机接入流程　　"></a>2.1.2 随机接入流程</h3><p>随机接入过程可以分为竞争性随机接入过程（CBRA）和非竞争性随机接入（CFRA）。非竞争性随机接入是网络将特定的随机接入资源是分配给UE的，通过Random Access Preamble网络就能识别特定的UE。具体的流程如下图所示（摘自ShareTechnote）：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p26-contention-Based.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p27-contention-free.png" alt></p><p>以CBRA的4步(上图CDEF步骤)为例：</p><ul><li>Msg1: UE在合适的PRACH上向gNB发送Preamble；</li><li>Msg2: gNB向UE发送RAR，并包含TC-RNTI、UL timing和对Msg3的调度等信息；</li><li>Msg3/4: 用于竞争冲突解决（多个UE恰巧在同一PRACH时频资源上采用了同一个preamble做RACH）。</li></ul><h2 id="2-2-Msg1"><a href="#2-2-Msg1" class="headerlink" title="2.2 Msg1"></a>2.2 Msg1</h2><p>前文描述的内容也就是Msg1的大部分内容。在发送Msg1给基站之前, ① 要确定多大的功率发送Msg1的preamble；②要确定RAR是发给自己的，即需要一个身份认证，因此用到了RA-RNTI可以唯一标识Msg1发送的时频资源这一特性。</p><h3 id="2-2-1-Msg1的发射功率"><a href="#2-2-1-Msg1的发射功率" class="headerlink" title="2.2.1 Msg1的发射功率"></a>2.2.1 Msg1的发射功率</h3><p>根据[TS 38.213 7.4]，UE配置PRACH信道的发送功率为 $P_{PRACH,b,f,c}(i) $，其意义是基于服务小区C 的 DL RS 在上行激活带宽 b 载波 f上，在发送时刻 为 i 时的发射功率。</p><script type="math/tex;mode=display">P_{PRACH,b,f,c}(i) = min\{P_{CMAX,f,c}(i),P_{PRACH,target,f,c}+PL_{b,f,c}\}[dBm]</script><p>其中：</p><ul><li>$P_{CMAX,f,c}(i)$ 是UE配置的最大输出功率，由 [8-1. TS 38.101-1]和 [8-2. TS 38.101-2]给出。</li><li>$P_{PRACH,target,f,c}$ 为PRACH 目标接收功率 <em>PREAMBLE_RECEIVED_TARGET_POWER</em> 由[11. TS 38.321] 给出计算公式：<em>PREAMBLE_RECEIVED_TARGET_POWER</em> = <em>preambleReceivedTargetPower</em> + <em>DELTA_PREAMBLE</em> + <em>(PREAMBLE_POWER_RAMPING_COUNTER -1)</em> <em></em>PREAMBLE_POWER_RAMPING_STEP*<ul><li><em>preambleReceivedTargetPower</em> 由参数 <em>preambleReceivedTargetPower</em> 给出</li><li><em>DELTA_PREAMBLE</em>可由[TS 38.321 Table 7.3-1~2] 获得</li><li><em>PREAMBLE_POWER_RAMPING_COUNTER</em> 对初始传输为1，依据重传次数自增一</li><li><em>PREAMBLE_POWER_RAMPING_STEP</em> 由参数 <em>powerRampingStep</em> 给出<br>（以上两条是为了功率攀升而设定的参数）</li></ul></li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T13-213 7.3-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T14-213 7.3.1-2.png" alt></p><ul><li>$PL_{b,f,c}$ 为路径损耗。由参数 <em>referenceSignalPower</em> – <em>higher layer filtered RSRP</em> (in dBm) 获得。<ul><li><em>referenceSignalPower</em> 根据PRACH 关联的SSB或者CSI-RS，由参数 <em>ss-PBCH_BlockPowe</em>r 和 <em>powerControlOffsetSS</em> 决定。</li><li><em>higher layer filtered RSRP</em> 是发送PRACH时测得的 RSRP (Reference Signal Receiving Power)。</li></ul></li></ul><p>示例：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rach-ConfigGeneric</span><br><span class="line">&#123;</span><br><span class="line">prach-ConfigurationIndex 2,			\\ 可以确定format 0</span><br><span class="line">msg1-FDM one,</span><br><span class="line">msg1-FrequencyStart 2,</span><br><span class="line">zeroCorrelationZoneConfig 6,</span><br><span class="line">preambleReceivedTargetPower -100,	\\ -100</span><br><span class="line">preambleTransMax n10,				\\ 最大重传次数</span><br><span class="line">powerRampingStep dB4,				\\ 4</span><br><span class="line">ra-ResponseWindow sl20</span><br><span class="line">&#125;,</span><br><span class="line">ss-PBCH-BlockPower -8				\\ referenceSignalPower&#x3D;-8</span><br><span class="line">假设此时的RSRP为-94dBm</span><br></pre></td></tr></table></figure><p></p><p>则此时的Msg1的初始发射功率为：</p><script type="math/tex;mode=display">P = -100 + 0 + (1-1)*4 + [-8-(-94)] = -14dBm</script><p>如果发生Msg2或者Msg4失败，则会触发Msg1重传，Msg1的最大重传次数由参数<em>preambleTransMax</em>定义。如果发生Msg1的重传，每次重传功率会以<em>powerRampingStep</em>这个步长增大(功率攀升，Ramping)，直到最后达到UE的最大功率或者重传达到最大次数为止。<br>注意：</p><ul><li>当UE<strong>继续使用</strong>上次发送SSB波束重发Msg1时，需要功率攀升。</li><li>当UE<strong>更换</strong>SSB波束发送Msg1时，不需要进行功率攀升。</li></ul><h3 id="2-2-2-RA-RNTI的计算和使用"><a href="#2-2-2-RA-RNTI的计算和使用" class="headerlink" title="2.2.2 RA-RNTI的计算和使用"></a>2.2.2 RA-RNTI的计算和使用</h3><p>RA-RNTI可以表征Msg1发送时使用的时频资源，UE发送Msg1时会计算RA-RNTI并保存；gNB收到该Msg1后，同样会计算RA-RNTI，并使用该RA-RNTI对Msg2的PDCCH DCI format 1_0的CRC进行扰码。</p><p>RA-RNTI=1 + s_id + 14 $\times$ t_id +14$\times80\times$ f_id + $14\times80\times8\times$ ul_carrier_id</p><p>其中：</p><ul><li>s_id 是PRACH的起始符号索引 (0$\leq$ s_id &lt;14)</li><li>t_id 是系统帧内PRACH的起始时隙索引 (0$\leq$ t_id &lt;50)</li><li>f_id 是PRACH 频域位置索引 (0$\leq$ f_id &lt;8)</li><li>ul_carrier_id 是Msg1发送上行载波指示 (0 for NUL carrier, and 1 for SUL carrier)</li></ul><h2 id="2-2-Msg2"><a href="#2-2-Msg2" class="headerlink" title="2.2 Msg2"></a>2.2 Msg2</h2><h3 id="2-2-1-UE接收Msg2"><a href="#2-2-1-UE接收Msg2" class="headerlink" title="2.2.1 UE接收Msg2"></a>2.2.1 UE接收Msg2</h3><ol><li>UE首先需要去解析出用于Msg2的下行调度的PDCCH DCI。定义了一个window的概念，UE在这个窗口内去监听PDCCH。window的长度由参数 <em>ra-ResponseWindow</em> 规定（不能超过10ms），单位是slot。window的起点是距离PRACH发送之后至少间隔1个symbol的用于Typ1-PDCCH CSS的CORESET的首个symbol。一般情况都是PRACH发送完之后的那个下行slot作为起点。</li><li>要监听的DCI的格式是format 1_0。这个DCI需要去Type 1 PDCCH Common Search Space去找，由参数 <em>ra-SearchSpace</em> 定义。</li><li>基站对这个PDCCH DCI的CRC使用了RA-RNTI进行了扰码，所以终端需要在 <em>ra-searchspace</em>上面尝试使用RA-RNTI去解析PDCCH DCI。</li><li>如果UE成功的使用RA-RNTI解调了DCI（知道这个消息是发送给自己的）。接着它会去解PDSCH payload。</li><li>如果UE继续成功的解出了PDSCH，UE会检查其中 RAPID（random access preamble identity）是否与自己当时发送Msg1时使用的RACH preamble ID相同。如果相同，UE认为Msg2解调成功。</li><li>如果UE在<em>ra-ResponseWindow</em> 内没有使用RA-RNTI解出DCI，或者没有成功解出PDSCH payload，或者解出了PDSCH但是RAPID不匹配，UE都会认为Msg2接收失败，会触发Msg1重发。</li></ol><h3 id="2-2-2-Msg2内容"><a href="#2-2-2-Msg2内容" class="headerlink" title="2.2.2 Msg2内容"></a>2.2.2 Msg2内容</h3><blockquote><p><strong>6.1.5 MAC PDU (Random Access Response)</strong><br>A MAC PDU consists of one or more MAC subPDUs and optionally padding. Each MAC subPDU consists one of the following:</p><ul><li>a MAC subheader with Backoff Indicator only;</li><li>a MAC subheader with RAPID only (i.e. acknowledgment for SI request);</li><li>a MAC subheader with RAPID and MAC RAR.</li></ul></blockquote><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p28-Figure6.1.5-3.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p31-MAC-PDU.png" alt></p><p>上面的描述及图片摘自 [TS 38.213]，结构图摘自ShareTechnote，说明Msg2这个MAC PDU 肯能包含BI，RAPID 和 MAC RAR三部分。</p><ul><li>BI（Backoff Indicator）用于当Msg1重发的时候产生一个随机退避时间（0 - PREAMBLE_BACKOFF），当这个退避时间结束后，终端才能重发Msg1。Msg2里面的BI field对应的退避时间如下表[TS 38.321 Table 7.2-1]。如果不包含用于BI的MAC subPDU，那么重发Msg1时退避时间为0ms。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p30-7.2-1.png" alt></p><ul><li>RAPID，用于携带random access preamble ID，如上描述。</li><li>RAR，这个subPDU是Msg2里面最重要的部分。主要包括TA，UL GRANT信息和TC-RNTI，其中UL GRANT是用于后面的Msg3，包括PUSCH的时域，频域的资源分配，是否跳频，MCS，Msg3的功控(参考[TS 38.213 Table 8.2-2])和CSI request。具体结构如下图[TS 38.321 6.2.2-3]，UL_GRANT中的内容如下表[TS 38.213 Table 8.2-1]。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p29-Figure 6.2.3-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T-15-8.2-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T15-213-8.2-2.png" alt></p><h2 id="2-3-Msg3"><a href="#2-3-Msg3" class="headerlink" title="2.3 Msg3"></a>2.3 Msg3</h2><p>根据前文描述UE在Msg2中解析到MAC RAR，MAC RAR中包含着27 bit 的UL Grant，该UL Grant指示了PUSCH的时域，频域的资源分配，是否跳频，MCS，Msg3的功控和CSI request 等消息。</p><h3 id="2-3-1-Msg3的传输内容"><a href="#2-3-1-Msg3的传输内容" class="headerlink" title="2.3.1 Msg3的传输内容"></a>2.3.1 Msg3的传输内容</h3><p>Msg3传输的内容取决于随机接入的场景。</p><ul><li>UE已经拥有了合法的C-RNTI：UE在Mdg3上发送C-RNTI MAC CE (由LCID index 58)。</li><li>UE没有合法的C-RNTI：UE在Msg3上发送CCCH SDU (由LCID指示)，这些CCCH SDU里面包含竞争解决身份identity。<h3 id="2-3-2-Msg3的发送时刻"><a href="#2-3-2-Msg3的发送时刻" class="headerlink" title="2.3.2 Msg3的发送时刻"></a>2.3.2 Msg3的发送时刻</h3>假设接收Msg2末尾消息在slot $n$ , 则UE发送Msg3的 solt $n+k_2+\Delta$ , 其中的 $k_2, \Delta$ 由 [6. TS 38.214] 给出，如下图所示。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p32-K2.png" alt></p><p>Msg3的发送时刻与Msg2的最后一个symbol至少相隔 $N_{T,1}+N_{T,2}+0.5$ msec，其中 $N_{T,1}，N_{T,2}$ 是N个符号的持续时间，该时间与当配置 additional PDSCH DMRS时用于UE处理能力1,2 的PDSCH处理时间相对应。N 的对应取值由下表给出：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T20-214-6.4-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T21-214-6.4-2.png" alt></p><h2 id="2-4-Msg4"><a href="#2-4-Msg4" class="headerlink" title="2.4 Msg4"></a>2.4 Msg4</h2><p>Msg4 是 Contention Resolution 环节。竞争解决的方式取决于 Msg3 中是传输了CCCH SDU 还是 C-RNTI MAC CE。</p><ul><li><p>Msg3 中传输CCCH SDU</p><p>在这种情况下，Msg3发送对应PUSCH符号结束之后，则开启 <em>re-ContentionResolutionTimer</em> ，在TImer为未超时之前，在<em>ra-SearchSpace</em> 上检测 Temporay C-RNTI 的DCI format 1_0，在调度的PDSCH译码正确的情况下，如果解析到UE Contention Resolution Identity MAC CE，且其内容与发送的CCCH SDU 两者内容一致，则认为随机过程接入成功，之后停止 <em>ra-ContentionResolutionTimer</em>，并将TC-RNTI正式转化为C-RNTI。</p></li><li><p>Msg3 中传输 C-RNTI MAC CE</p><p>此种情况下，冲突解决的原理与传输CCCH SDU时相同，只是通过接收C-RNTI调度的DCI来判断竞争解决是否成功。</p></li></ul><h2 id="2-5-HARQ-ACK-for-Msg4"><a href="#2-5-HARQ-ACK-for-Msg4" class="headerlink" title="2.5 HARQ ACK for Msg4"></a>2.5 HARQ ACK for Msg4</h2><p>一旦UE成功解析出Msg4，UE在PUCCH中发送HARQ-ACK信息。反馈时间距离Msg4的最后一个symbol至少相隔$N_{T,1}+0.5$ msec (参考Msg3的准备时间)。</p><h2 id="2-6-流程时序图总结"><a href="#2-6-流程时序图总结" class="headerlink" title="2.6 流程时序图总结"></a>2.6 流程时序图总结</h2><p>流程时序如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p33-时序图.png" alt></p><p>其中：</p><ul><li><ol><li>gNB → UE：System information。</li></ol><ul><li>Configuration of PRACH transmission Parameters<ul><li>PRACH Preamble Format</li><li>Time Resources</li><li>Frequency Resources</li></ul></li><li>Parameters for determining the root sequences and their cyclic shifts in the PRACH Preamble sequence set<ul><li>index to logical root sequence table</li><li>Cyclic Shift(Ncs)</li><li>Set Type (unrestricted, restricted set A or restricted set B)</li></ul></li></ul></li><li><ol><li>UE → gNB：Msg1- PRACH Preamble。PRACH Preamble 频域资源由参数 <em>msg1-FDM</em> 和 <em>msg1-FrequencyStart</em> 决定；PRACH Preamble 时域资源由参数 <em>prach-ConfigurationIndex</em> 决定；</li></ol></li><li><ol><li>gNB → UE：Msg2。Msg2需要在ra-ResponseWindow内被UE接收。</li></ol></li><li><ol><li>UE → gNB：Msg3。Msg3发送时隙，与Msg2最后时隙相差 $k_2+\Delta$ ; 时间上至少相隔 $N_{T,1}+N_{T,2}+0.5$ ms 。</li></ol></li><li><ol><li>gNB → UE：Msg4。冲突解决环节，对应Msg3所传输的不同内容做出回应。Msg4需要在<em>ra-ContentionResolutionTimer</em> 内被UE接收。</li></ol></li><li><ol><li>UE → gNB：HARQ ACK。反馈时间距离Msg4的最后一个symbol至少相隔$N_{T,1}+0.5$ ms 。</li></ol></li></ul><h1 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3 扩展"></a>3 扩展</h1><blockquote><p>主要参考：<a href="https://blog.csdn.net/GiveMe5G/article/details/103847118" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/103847118</a></p></blockquote><p>主要是分析随机接入过程中的消息如何组合起来应用到实际的场景中去。参考中主要是归纳总结了随机接入的触发场景，并对三个重要场景下的RACH流程进行进一步的分析。</p><h2 id="3-1-RACH触发类型-场景-分类"><a href="#3-1-RACH触发类型-场景-分类" class="headerlink" title="3.1 RACH触发类型(场景)分类"></a>3.1 RACH触发类型(场景)分类</h2><p>RACH流程主要由三种触发类型：</p><ul><li>PDCCH order触发</li><li>MAC层触发</li><li>RRC层触发</li></ul><blockquote><p>The Random Access procedure described in this clause is initiated by a PDCCH order, by the MAC entity itself, or by RRC for the events in accordance with TS 38.300</p></blockquote><p>以下是参考文章作者根据 TS 38.300 系列整理的表格，归纳了各个场景以及其对应的触发类型：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p34-RACH场景.png" alt></p><h2 id="3-2-PDCCH-Order-RACH"><a href="#3-2-PDCCH-Order-RACH" class="headerlink" title="3.2 PDCCH Order RACH"></a>3.2 PDCCH Order RACH</h2><p>PDCCH Order 发起的随机接入主要用于上行失步后，当gNB有下行数据要发送时，会使用PDCCH Order 强制UE发起 RACH 以重新完成上行时间同步。PDCCH Order使用PDCCH DCI 1_0配置给UE。其字段的设置如下：</p><ul><li>Random Access Preamble index – 6 bits</li><li>UL/SUL indicator – 1 bit</li><li>SS/PBCH index – 6 bits</li><li>PRACH Mask index – 4 bits</li><li>Reserved bits – 10 bits</li></ul><p>从上述描述中可以看出，DCI 1_0中会告诉UE 用于RACH的preamble index 以便UE发起非竞争的随机接入，但是要注意这是有条件的，要求DCI 1_0中指示的preamble index非0，否则需要使用基于竞争的随机接入。</p><p>基于竞争和非竞争的PDCCH Order触发的RACH流程图如下所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p35-场景1.png" alt></p><h2 id="3-3-Beam-Failure-Recovery-RACH"><a href="#3-3-Beam-Failure-Recovery-RACH" class="headerlink" title="3.3 Beam Failure Recovery RACH"></a>3.3 Beam Failure Recovery RACH</h2><p>在5G当中引入了一个beam 级别的链路恢复机制，Beam failure recovery，后面简称为BFR。BFR分为基于竞争和基于非竞争两种。按照38321中的描述，如果RRC配置了用于BFR的RACH资源并且用于beam恢复的candidate beam（SSB/CSI-RS）中至少有一个beam的RSRP高于一定的门限，而且beamFailureRecoveryTimer没有超时，这时才能使用基于非竞争的BFR；否则需要使用基于竞争的BFR。<br>下面的两幅图是基于竞争和非竞争的BFR RACH流程。需要注意的是，对于基于非竞争的BFR流程的Msg2，其PDCCH是使用C-RNTI扰码的，而不是RA-RNTI。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p36-场景2.png" alt></p><h2 id="3-4-OSI-Other-System-Information-Request-RACH"><a href="#3-4-OSI-Other-System-Information-Request-RACH" class="headerlink" title="3.4 OSI (Other System Information) Request RACH"></a>3.4 OSI (Other System Information) Request RACH</h2><p>5G SA组网当中MIB和SIB1这两个系统消息一定是通过广播的方式通知UE的，但是其他的系统消息（OSI-Other System Information）可以采用像LTE的广播方式，也可以采用5G当中新引入的按需索要的方式（On Demond Request）。<br>对于按需索要的系统消息，会用到RACH 流程，具体分为Msg1 based和Msg3 based的两种RACH流程。注意，Msg1 based的请求需要基站在SIB1里面的SI-SchedulingInfo中配置专门用于OSI请求的RACH资源和Preamble，而且它的Msg2是一个只含有RAPID的MAC subPDU；而Msg3 based的其实是一种普通的基于竞争的RACH方式，只是这里面的Msg3引入了一个新的UL-CCCH消息，RRCSystemInfoRequest，用于请求UE想要的OSI。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p37-场景3.png" alt></p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="附录A-相关表格"><a href="#附录A-相关表格" class="headerlink" title="附录A 相关表格"></a>附录A 相关表格</h2><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T1-38.211-6.3.3.1-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T2-38.211-6.3.3.1-2.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T3-38.211-6.3.3.2-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T5-38.211-6.3.3.1-3(4" alt>.png)</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T6-38.211-6.3.3.1-5.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T7-38.211-6.3.3.1-6.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T8-38.211-6.3.3.1-7.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T9-38.211-6.3.3.2-2.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T10-38.211-6.3.3.2-3.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T11-38.211-6.3.3.2-4.png" alt></p><h2 id="附录B-相关配置"><a href="#附录B-相关配置" class="headerlink" title="附录B 相关配置"></a>附录B 相关配置</h2><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/C1-RACH-Configuration.png" alt><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/C2-RACH-Configuration2.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/C3-RACH-ConfigDedicated1.png" alt><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/C4-RACH-ConfigDedicated2.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/C5-RACH-ConfigGeneric.png" alt></p><blockquote><p>参考文献<br>公众号：5G菜鸟成长日记，春天工作室<br>网页：<a href="https://mp.weixin.qq.com/s/LRpnHwaAmYmpUlhF6wcmZg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LRpnHwaAmYmpUlhF6wcmZg</a><br>网页：<a href="http://www.sharetechnote.com/html/5G/5G_RACH.html" target="_blank" rel="noopener">http://www.sharetechnote.com/html/5G/5G_RACH.html</a><br>博客：<a href="https://blog.csdn.net/qq_33206497/article/details/89980529" target="_blank" rel="noopener">https://blog.csdn.net/qq_33206497/article/details/89980529</a><br>博客：<a href="https://blog.csdn.net/GiveMe5G/article/details/102634057" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/102634057</a><br>博客：<a href="https://blog.csdn.net/GiveMe5G/article/details/102633678" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/102633678</a><br>博客：<a href="https://blog.csdn.net/GiveMe5G/article/details/102633541" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/102633541</a><br>博客：<a href="https://blog.csdn.net/GiveMe5G/article/details/103219499" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/103219499</a><br>博客：<a href="https://blog.csdn.net/GiveMe5G/article/details/103413805" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/103413805</a><br>博客：<a href="https://blog.csdn.net/GiveMe5G/article/details/103606304" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/103606304</a><br>博客：<a href="https://blog.csdn.net/GiveMe5G/article/details/103847118" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/103847118</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>PRACH</tag>
        <tag>随机接入</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-PDSCH学习</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:36 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="1-PDSCH-物理流程"><a href="#1-PDSCH-物理流程" class="headerlink" title="1 PDSCH 物理流程"></a>1 PDSCH 物理流程</h1><h2 id="1-1-加扰"><a href="#1-1-加扰" class="headerlink" title="1.1 加扰"></a>1.1 加扰</h2><p>双码字传输时，$q \in \{0,1\}$；单码字传输时，$q = 0$。[TS 38.211 7.3.1.1]<br>每一个码字对应的原始数据 $b^{(q)}(0),…,b^{(q)}(M_{bit}^{(q)}-1)$ ,经过加扰处理生成加扰后的数据为 $\widetilde b^{(q)}(0),…,\widetilde b^{(q)}(M_{bit}^{(q)}-1)$ 。加扰处理如下所示：</p><script type="math/tex;mode=display">\widetilde b^{(q)}(i) = (b^{(q)}(i) + c^{(q)}(i))mod2</script><p>加扰序列是一个伪随机序列，由[TS 38.211 5.2.1]给出，加扰序列的初始为：</p><script type="math/tex;mode=display">C_{init} = n_{RNTI}\cdot2^{15}+q\cdot2^{14}+n_{ID}</script><p>其中：</p><ul><li>$n_{ID}$ = dataScramblingIdentityPDSCH(如果配置)，并且RNTI = C-RNTI or CS-RNTI，在公共搜索空间中不使用DCI格式1_0调度传输。</li><li>除此之外 $n_{ID} = N_{ID}^{cell}$</li><li>$n_{RNTI}$ 就是PDSCH当前传输时相关联的RNTI</li></ul><h2 id="1-2-调制"><a href="#1-2-调制" class="headerlink" title="1.2 调制"></a>1.2 调制</h2><p>每一个码字加扰后的比特块 $\widetilde b^{(q)}(0),…,\widetilde b^{(q)}(M_{bit}^{(q)}-1)$ 采用下表中的一种调制方式进行调制，得到一个复值调制符号块$d^{(q)}(0),…,d^{(q)}(M_{symb}^{(q)}-1)$。[TS 38.211 7.3.1.2]</p><table><tr><td><center>Modulation scheme</center></td><td><center>Modulation order</center></td></tr><tr><td><center>QPSK</center></td><td><center>2</center></td></tr><tr><td><center>16QAM</center></td><td><center>4</center></td></tr><tr><td><center>64QAM</center></td><td><center>6</center></td></tr><tr><td><center>256QAM</center></td><td><center>8</center></td></tr></table><h2 id="1-3-层映射"><a href="#1-3-层映射" class="headerlink" title="1.3 层映射"></a>1.3 层映射</h2><p>每一个码字生成的调制信号 $d^{(q)}(0),…,d^{(q)}(M_{symb}^{(q)}-1)$ 根据下表映射到多个层$x(i)=[x^0{i} \cdots x^{v-1}(i)]^T$，$i = 0,1,…,M_{symb}^{layer}-1$，其中$v$表示层数，$M_{symb}^{layer}$ 表示每层调制符号的数量。[TS 38.211 7.3.1.3]</p><div class="table-container"><table><thead><tr><th style="text-align:center">层数</th><th style="text-align:center">码字数</th><th>码字到层映射<br>$i = 0,1,…,M_{symb}^{layer}-1$</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(i)$ $M_{symb}^{layer} = M_{symb}^{(0)}$</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(2i)$<br>$x^{(1)}(i) = d^{(0)}(2i+1)$ $M_{symb}^{layer} = M_{symb}^{(0)}/2$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(3i)$<br>$x^{(1)}(i) = d^{(0)}(3i+1)$ $M_{symb}^{layer} = M_{symb}^{(0)}/3$<br>$x^{(2)}(i) = d^{(0)}(3i+2)$</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(4i)$<br>$x^{(1)}(i) = d^{(0)}(4i+1)$<br>$x^{(2)}(i) = d^{(0)}(4i+2)$ $M_{symb}^{layer} = M_{symb}^{(0)}/4$<br>$x^{(3)}(i) = d^{(0)}(4i+3)$</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(2i)$<br>$x^{(1)}(i) = d^{(0)}(2i+1)$<br>$x^{(2)}(i) = d^{(1)}(3i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/2 = M_{symb}^{(1)}/3$<br>$x^{(3)}(i) = d^{(1)}(3i+1)$<br>$x^{(4)}(i) = d^{(1)}(3i+2)$</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(3i)$<br>$x^{(1)}(i) = d^{(0)}(3i+1)$<br>$x^{(2)}(i) = d^{(0)}(3i+2)$<br>$x^{(3)}(i) = d^{(1)}(3i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/3 = M_{symb}^{(1)}/3$<br>$x^{(4)}(i) = d^{(1)}(3i+1)$<br>$x^{(5)}(i) = d^{(1)}(3i+2)$</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(3i)$<br>$x^{(1)}(i) = d^{(0)}(3i+1)$<br>$x^{(2)}(i) = d^{(0)}(3i+2)$<br>$x^{(3)}(i) = d^{(1)}(4i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/3 = M_{symb}^{(1)}/4$<br>$x^{(4)}(i) = d^{(1)}(4i+1)$<br>$x^{(5)}(i) = d^{(1)}(4i+2)$<br>$x^{(6)}(i)=d^{(1)}(4i+3)$</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(4i)$<br>$x^{(1)}(i) = d^{(0)}(4i+1)$<br>$x^{(2)}(i) = d^{(0)}(4i+2)$<br>$x^{(3)}(i)=d^{(0)}(4i+3)$<br>$x^{(4)}(i) = d^{(1)}(4i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/4 = M_{symb}^{(1)}/4$<br>$x^{(5)}(i) = d^{(1)}(4i+1)$<br>$x^{(6)}(i) = d^{(1)}(4i+2)$<br>$x^{(7)}(i)=d^{(1)}(4i+3)$</td></tr></tbody></table></div><p>可以看到，单码字映射到1-4层，双码字映射到5-8层。</p><h2 id="1-4-天线端口映射"><a href="#1-4-天线端口映射" class="headerlink" title="1.4 天线端口映射"></a>1.4 天线端口映射</h2><p>经过层映射之后的数据按照如下方式映射到天线端口。[TS 38.211 7.3.1.4]</p><script type="math/tex;mode=display">\left[
\begin{matrix}
y^{(p_0)}(i)\\
\vdots\\
y^{(p_{v-1})}(i)\\
\end{matrix}
\right]= \left[
\begin{matrix}
x^{(0)}(i)\\
\vdots\\
x^{(v-1)}(i)
\end{matrix}
\right]</script><p>其中 $i=0,1,…,M_{symb}^{ap}-1$，$M_{symb}^{ap}=M_{symb}^{layer}$</p><h2 id="1-5-映射到虚拟资源快"><a href="#1-5-映射到虚拟资源快" class="headerlink" title="1.5 映射到虚拟资源快"></a>1.5 映射到虚拟资源快</h2><p>对于每个天线步骤，都会创建一个虚拟资源网格。在资源网格内，从RE的最低频率到较高频率的来自来填充PDSCH数据到每个RE中。一旦它以分配的PDSCH资源块的最高频率到达RE，则移至下一个OFDM符号的最低频率的RE。[TS 38.211 7.3.1.5]<br>但不应使用为以下目的而分配的RE：</p><ul><li>分配给与要发送的PDSCH相关的DMRS的RE</li><li>为DMRS分配给用于其他共同调度UE的RE</li><li>非零功率CSI-RS的RE，由MeasObjectNR IE中较高层参数CSI-RS-Resource-Mobility配置的非零功率CSI-RS除外。</li><li>PTRS的RE</li><li>声明为“不适用于PDSCH的RE”</li></ul><h2 id="1-6-从虚拟资源块映射到物理资源块"><a href="#1-6-从虚拟资源块映射到物理资源块" class="headerlink" title="1.6 从虚拟资源块映射到物理资源块"></a>1.6 从虚拟资源块映射到物理资源块</h2><p>从VRB到PRB的映射有交织和非交织两种。[TS 38.211 7.3.1.6]</p><h3 id="1-6-1-非交织"><a href="#1-6-1-非交织" class="headerlink" title="1.6.1 非交织"></a>1.6.1 非交织</h3><p>在公共搜索空间用DCI Format 1_0调度的PDSCH传输这种情况下,虚拟资源块$n$映射到物理资源块 $n + N_{start}^{CORESET}$ 上，其中$N_{start}^{CORESET}$是接受相应DCI的控制资源集中编号最小的物理资源块；<br>除此情况之外，虚拟资源块$n$就映射到物理资源块$n$上。<br>如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/non-interleave.png" alt></p><h3 id="1-6-2-交织"><a href="#1-6-2-交织" class="headerlink" title="1.6.2 交织"></a>1.6.2 交织</h3><p>交织映射模式，以资源块束(RB bundle)来定义，与PDCCH的RB bundle 相比PDSCH的资源块束有些不同，主要分三种情况：<br><strong>类型一</strong>：<br>在CORESET#0的Type0-PDCCH公共搜索空间，由SI-RNTI加扰，用DCI Format 1_0 调度的PDSCH传输。<br>下行初始激活的BWP，大小$N_{BWP,init}^{size}$，分为$N_{bundle} = \lceil N_{BWP,init}^{size}/L \rceil$ 个RB bundle，按照RB编号和束编号升序排序。其中$L$是bundle的大小，取值为２。如果$N_{BWP,init}^{size}$不能整数L，最后一个RB bundle包含 $N_{BWP,init}^{size}modL$个RB，其实由于$L = 2$所以最后一个不能整数的话那就剩下一个RB，能整数除最后一个RB bundle就是2个RB。<br>如下图所示：<br><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/interleaver1.png" alt></p><p><strong>类型二</strong>：<br>除上述情况外，在公共搜索空间由DCI Format 1_0调度的PDSCH传输。<br>BWP起始位置$N_{BWP,i}^{start}$，大小为$N_{BWP,init}^{size}$ 的VRB集合$\{0,1,…,N_{BWP,init}^{size}-1\}$ 分为$N_{bundle}$ 个虚拟RB bundle，相应的$N_{BWP,init}^{size}$ 个PRB集合$\{N_{start}^{CORESET},N_{start}^{CORESET}+1,…,N_{start}^{CORESET}+N_{BWP,init}^{size}\}$ 分为$N_{bundle}$ 个物理RB bundle，其中$N_{bundle}=\lceil (N_{BWP,init}^{size}+(N_{BWP.i}^{start}+N_{start}^{CORESET})modL)/L \rceil$ ，L是bundle的大小，取值为2，$N_{start}^{CORESET}$是接受相应DCI的控制资源集中编号最小的物理资源块。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/interleave2.png" alt></p><p>其RB bundle 包含的RB数如下描述：</p><ul><li>0号RB bundle 包含了$L-((N_{BWP,i}^{start}+N_{start}^{CONRESET})modL)$个RB；</li><li>如果$(N_{BWP,init}^{size}+N_{BWP,i}^{start}+N_{start}^{CONRESET})modL&gt;0$，则最后一个RB bundle包含了$(N_{BWP,init}^{size}+N_{BWP,i}^{start}+N_{start}^{CONRESET})modL$ 个RB，否则包含$L$个RB；</li><li>其余RB bundle 包含$L$ 个RB；<br>之所以要考虑进$N_{start}^{CONRESET}$，是因为38.214中规定，对于任何在PDCCH公共搜索空间中以DCI format 1_0调度的PDSCH传输，其RB编号从接受DCI的CORESET的最低RB开始。</li></ul><p><strong>类型三</strong>：<br>其他PDSCH传输。<br>BWP，i的起始位置$N_{BWP,i}^{start}$，大小$N_{BWP,i}^{size}$，分为$N_{bundle}$ 个RB bundle 且按照RB编号和束编号的升序排列，其中$N_bundle = \lceil(N_{BWP,init}^{size}+(N_{BWP,i}^{start}modL_i))/L_i \rceil$，$L_i$ 是bundle的大小，由高层参数vrb- ToPRB-Interleaver配置。<br><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/interleave3.png" alt></p><p>其RB bundle 包含的RB数如下描述：</p><ul><li>0号RB bundle包含了$L_i-(N_{BWP,i}^{start}modL_i)$个RB，目的是为了从下一个bundle开始，每个bundle的起始位置都是$L_i $的整数倍；</li><li>如果$(N_{BWP,i}^{start}+N_{BWP,i}^{size})modL_i&gt;0$，最后一个RB bundle包含了$(N_{BWP,i}^{start}+N_{BWP,i}^{size})modL_i$ 个RB，否则包含$L_i$ 个RB；</li><li>其余RB bundle 包含$L_i$ 个RB。</li></ul><p>举个例子来描述类型三：<br>例子：假设$N_{BWP,i}^{start} = 5,N_{BWP,i}^{size} = 21$<br>1) $L_i=5$<br>$N_{bundle} = \lceil(N_{BWP,init}^{size}+(N_{BWP,i}^{start}modL_i))/L_i \rceil = \lceil(21+(5mod5))/5 \rceil = 5$<br>$N_{bundle,0} = L_i-(N_{BWP,i}^{start}modL_i) = 5-(5mod5) =5$<br>$N_{bundle,end} = (N_{BWP,i}^{start}+N_{BWP,i}^{size})modL_i = (5+21)mod5 = 1$<br>$N_{bundle,other} = L_i = 5$<br>如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/case1.png" alt></p><p>2) $L_i=4$<br>$N_bundle = \lceil(N_{BWP,init}^{size}+(N_{BWP,i}^{start}modL_i))/L_i \rceil = \lceil(21+(5mod4))/4 \rceil = 6$<br>$N_{bundle,0} = L_i-(N_{BWP,i}^{start}modL_i) = 4-(5mod4) =3$<br>$N_{bundle,end} = (N_{BWP,i}^{start}+N_{BWP,i}^{size})modL_i = (5+21)mod4 = 2$<br>$N_{bundle,other} = L_i = 4$<br>如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/case2.png" alt></p><h3 id="1-6-3-VRB-bundle-到-PRB-bundle-的映射"><a href="#1-6-3-VRB-bundle-到-PRB-bundle-的映射" class="headerlink" title="1.6.3 VRB bundle 到 PRB bundle 的映射"></a>1.6.3 VRB bundle 到 PRB bundle 的映射</h3><p>本节来看属于$j\in \{0,1,…,N_{bundle}-1\}$ 区间内的虚拟RB向物理RB的映射：</p><ul><li>$N_bundle - 1$号虚拟RB bundle映射到$N_{bundle}-1$号物理RB bundle；</li><li>其余$j\in \{0,1,…,N_{bundle}-2\}$ 的虚拟RB bundle 遵循$f(j)$ 函数映射到物理RB bundle<script type="math/tex;mode=display">f(j) = rC+c\\j = cR+r\\r = 0,1,...,R-1\\c = 0,1,...,C-1\\R = 2\\C = \lfloor N_{bundle}/R \rfloor</script></li></ul><p>举个例子说明，运用上面的例子数据:<br>1) $R = 2; \quad C = \lfloor N_{bundle}/R \rfloor = \lfloor 5/2 \rfloor = 2;\quad r = 0,1,2;\quad c = 0,1,2$。</p><div class="table-container"><table><thead><tr><th>c</th><th>r</th><th>j: VRB bundle</th><th>$f(j)$: PRB bundle</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>2</td></tr><tr><td>1</td><td>0</td><td>2</td><td>1</td></tr><tr><td>1</td><td>1</td><td>3</td><td>3</td></tr></tbody></table></div><p>映射结果如图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/case31.png" alt></p><p>2) $R = 2; \quad C = \lfloor N_{bundle}/R \rfloor = \lfloor 6/2 \rfloor = 3;\quad r = 0,1;\quad c = 0,1,2$。</p><div class="table-container"><table><thead><tr><th>c</th><th>r</th><th>j: VRB bundle</th><th>$f(j)$: PRB bundle</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>3</td></tr><tr><td>1</td><td>0</td><td>2</td><td>1</td></tr><tr><td>1</td><td>1</td><td>3</td><td>4</td></tr><tr><td>2</td><td>0</td><td>4</td><td>2</td></tr><tr><td>2</td><td>1</td><td>5</td><td>5</td></tr></tbody></table></div><p>映射结果如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/case32.png" alt></p><h1 id="2-PDSCH-DMRS"><a href="#2-PDSCH-DMRS" class="headerlink" title="2 PDSCH DMRS"></a>2 PDSCH DMRS</h1><h2 id="2-1-序列生成"><a href="#2-1-序列生成" class="headerlink" title="2.1 序列生成"></a>2.1 序列生成</h2><p>PDSCH DMRS序列有如下公式生成：</p><script type="math/tex;mode=display">r(n) = \frac{1}{\sqrt{2}}(1-2\cdot c(2n))+j\frac{1}{\sqrt{2}}(1-2\cdot c(2n+1))</script><p>加扰序列采用31阶Gold序列生成，加扰序列的初始序列$c_{init}$如下式所示:</p><script type="math/tex;mode=display">c_{init} = (2^{17}(N_{symb}^{slot}n_{s,f}^{\mu}+l+1)(2N_{ID}^{n_{SCID}}+1)+2N_{ID}^{n_{SCID}}+n_{SCID})mod2^{31}</script><p>其中：</p><ul><li>$l$ 为时隙中的符号索引</li><li>$n_{s,f}$ 为时隙索引</li><li>$N_{symb}^{slot}$ 为一个时隙内的符号数量</li><li>$n_{SCID},N_{ID}^{n_{SCID}}$ :<br><strong>1) 对于C-RNTI/MCS-C-RNTI/CS-RNTI</strong><br>① DCI format 1_1 , $n_{SCID}$ 可由DMRS-DownlinkConfig IE中scramblingID0,scramblingID1配置,可以在$N_{ID}^0,N_{ID}^1$之间选择,$N_{ID}^{0},N_{ID}^{1}\in \{0,1,…,65535\}$。<br>② DCI format 1_1 , $n_{SCID}$ 可由DMRS-DownlinkConfig IE中scramblingID0配置,可以在$N_{ID}^0$之间选择,$N_{ID}^{0}\in \{0,1,…,65535\}$。<br>③ 如果①DMRS-DownlinkConfig IE中scramblingID0,scramblingID1都未配置,则$n_{SCID}=0,N_{ID}^{n_{SCID}}=N_{ID}^{cell}$。<br>④ 如果②DMRS-DownlinkConfig IE中scramblingID0未配置，则$n_{SCID}=0,N_{ID}^{n_{SCID}}=N_{ID}^{cell}$。<br><strong>２) 对于SI-RNTI/P-RNTI/RA-RNTI</strong><br>$n_{SCID}=0,N_{ID}^{n_{SCID}}=N_{ID}^{cell}$。</li></ul><p>高层配置参数DMRS-DownlinkConfig内容如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/DMRS-DLconfig.png" alt></p><h2 id="2-2-PDSCH-DMRS-频域位置"><a href="#2-2-PDSCH-DMRS-频域位置" class="headerlink" title="2.2 PDSCH DMRS 频域位置"></a>2.2 PDSCH DMRS 频域位置</h2><p>DMRS映射方式分为Configuration type 1 和configuration type 2 两种，有DMRS-DownlinkConfig中的drms-type指示，如果未配置，则默认为Configuration type 1。<br>序列映射到RE的公式如下所示：</p><script type="math/tex;mode=display">\alpha_{k,l}^{p,\mu}=\beta_{PDSCH}^{DMRS}w_f(k')w_t(l')r(2n+k')\\k = \begin{cases}4n+2k'+\Delta \quad \quad Configuration\quad type\quad1\\6n+k'+\Delta\quad \quad Configuration\quad type\quad 2 \end{cases}\\k'=0,1\\l=\overline{l}+l'\\n = 0,1,...</script><p>$k$为频域指示，$l$为时域指示。Configuration type 1 和configuration type 2，分别用于支持单用户MIMO和多用户MIMO。除此之外，由于类型1和类型2平均每个端口占用的RE数量不同，即每个端口的RE密度不同，所以各自有不同的适用场景。类型1更适合低信噪比、频域选择性较高的场景，类型2更适合高信噪比、时延扩展较小的场景。</p><p>频域指示$k$的参考点分两种情况：</p><ul><li>承载SIB1的PDSCH的DMRS，$k$的参考点为CORESET#0的RE0；</li><li>其余情况参考点为CRB#0的RE0即point A。</li></ul><p>以下图示分别展示了Configuration type 1 和configuration type 2两种情况下的DMRS频域位置，为了方便只选取了1RB左右大小，都是single symbol。<br>Configuration type 1：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/DMRS频域分析1.png" alt></p><p></p><p>Configuration type 2:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/DMRS频域分析2.png" alt></p><h2 id="2-3-PDSCH-DMRS-的符号位置"><a href="#2-3-PDSCH-DMRS-的符号位置" class="headerlink" title="2.3 PDSCH DMRS 的符号位置"></a>2.3 PDSCH DMRS 的符号位置</h2><p>DMRS的符号位置取决于PDSCH的mapping type，分为mapping type A和mapping type B，参考表格或者配置可以获得PDSCH的mapping type，以及对应的$k_0,S,L$。[TS 38.214 5.1.2.1]<br><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/Table5.1.2.1-1.png" alt><br><br>时域指示$l$的参考点分两种情况：</p><ul><li>PDSCH mapping type A：时域指示$l$的参考点为时隙的起始symbol，且DM-RS的第一个符号位置为3或4(表中S = 2，3)，由MIB中参数dmrs-TypeA-Position指示，主要考虑PDCCH的具体配置。</li><li>PDSCH mapping type B时，$l$的参考点为PDSCH的起始symbol，DM-RS从PDSCH调度区域的第一个符号开始传输。<br>两种情况如下图所示：<br>例子一：type A，$S = 3 , L = 7$, $l_0$ 的大小是与参考点的差值，表示DMRS的初始符号。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/DMRS时域1.png" alt></p><p>例子二：type B，$S = 6 , L = 4$, $l_0$ 的大小是与参考点的差值，表示DMRS的初始符号。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/DMRS时域2.png" alt></p><h2 id="2-4-DMRS-符号类型"><a href="#2-4-DMRS-符号类型" class="headerlink" title="2.4 DMRS 符号类型"></a>2.4 DMRS 符号类型</h2><p>DMRS两个symbol类型，single symbol 和 double symbol。取决于DMRS-DownlinkConfig中的maxLength参数的配置，maxLength配置为len1，则取值为len1（single-symbol）；如果配置为len2（double-symbol）。如果高层参数maxLength没有配置，则为single类型。</p><h2 id="2-5-添加导频"><a href="#2-5-添加导频" class="headerlink" title="2.5 添加导频"></a>2.5 添加导频</h2><p>在NR中的中/高速场景中，为了保证估计精度，除了前置导频(前文所描述的DMRS)外，加入了与前置导频TDM的附加导频，附加DM-RS结构与前置DM-RS的图样相同，在double symbol DM-RS情况下，最多可以配置1组附加导频，在single symbol前置DM-RS情况下最多可以配置3组附加导频。附加导频的数量与调度时长有关，时域位置由高层参数dmrs-AdditionalPosition指示,如下表所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/添加导频单符号.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/添加导频双符号.png" alt></p><p>当PDSCH mapping type B时，如果PDSCH的资源和CORESET相重叠，则PDSCH DM-RS要往后顺延到紧挨CORESET的后面，此时，如果PDSCH的duration为2时，DM-RS的起始位置不能超过PDSCH的第二个symbol，当PDSCH的duration为4时，DM-RS的起始位置不能超过PDSCH的第3个symbol，当PDSCH的duration为7时，DM-RS的第一个symbol不能超过PDSCH的第4个symbol。<br>(Note: 以上所说的PDSCH的duration，也就是$L$，同时也是$l_d$ ，都是一个意思)<br><br>举个例子来说明上面两个表的意思：<br>$S = 2,L=11$,maxLength配置为len1，即为single symbol ,按照第一个 表格，如果此时$l_d = 11$ PDSCH mapping type A , dmrs-AdditionalPosition指示为2，则代表在DMRS导频位置分别在DMRS初始位置$l_0$(若为$l_0=2$),#6,#9符号上。如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/添加导频例子.png" alt></p><h2 id="2-6-端口映射"><a href="#2-6-端口映射" class="headerlink" title="2.6 端口映射"></a>2.6 端口映射</h2><p>结合PDSCH DMRS序列生成及映射公式，以及下表可知：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/Table7.4.1.1.2-12.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/Table7.4.1.1.2-5.png" alt></p><ul><li>type 1，single symbol情况下，最多支持4个端口，端口0，1和2，3分别在不同的CDM group，每个CDM group内，比如端口0和1，又通过频域的OCC来实现正交，从而实现4个端口的正交。</li><li>type 1，double symbol情况下，最多支持8个端口，除了频域OCC外，还可以时域OCC来实现正交，所以可以支持更多的端口。</li><li>type 2，single symbol情况下，最多支持6个端口，共三个CDM group，每个group内又通过频域OCC实现正交。</li><li>type 2，double symbol情况下，最多支持12个端口，与类型1双符号情况同理，除了频域OCC外，还可以时域OCC，从而支持更多的端口。</li></ul><p>问题：端口，层方面</p><h1 id="3-PDSCH-PTRS"><a href="#3-PDSCH-PTRS" class="headerlink" title="3 PDSCH PTRS"></a>3 PDSCH PTRS</h1><h2 id="3-1-相位噪声"><a href="#3-1-相位噪声" class="headerlink" title="3.1 相位噪声"></a>3.1 相位噪声</h2><p>相位噪声指射频器件在各种噪声（如随机性白噪声、闪烁噪声）的作用下引起的系统输出信号相位的随机变化。相位噪声会恶化接收端的SNR（Signal-Noise Ratio信噪比）或EVM（Error Vector Magnitude误差向量幅度），造成大量的误码，这样就限制了高阶调制的使用，会严重影响系统的容量。<br>相对来说，相位噪声对低频段，也就是sub6G频段的影响较小一些。而高频段（毫米波）下，由于参考时钟源的倍频次数大幅增加以及器件的工艺水平和功耗等各方面的原因，相位噪声的影响也是大幅增加。<br>为了应对高频段下的相位噪声，除了增大子载波间隔、提高器件质量之外，5G NR引入了PT-RS（Phase Tracking Reference Signal）信号以及相位估计补偿算法。</p><h2 id="3-2-序列生成"><a href="#3-2-序列生成" class="headerlink" title="3.2 序列生成"></a>3.2 序列生成</h2><p>生成序列方式与PDSCH DMRS相同。</p><h2 id="3-3-高层配置"><a href="#3-3-高层配置" class="headerlink" title="3.3 高层配置"></a>3.3 高层配置</h2><p>下行是否配置了PT-RS，由DMRS-DownlinkConfig中的字段phaseTrackingRS来决定，如果该字段缺省或配置为released，则表示下行没有PT-RS信号。PT-RS的具体配置在PTRS-DownlinkConfig中：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/PTRS.png" alt></p><p><strong>frequencyDensity</strong><br>frequencyDensity提供了两个值，这两个值都在（1,276）的范围内，分别对应了[TS 38.214-Table5.1.6.3-2]中的$N_{RB0},N_{RB1}$，UE再通过DCI中的调度RB数查询该表，就可以确定PT-RS的频域密度$K_{PT−RSK}$ 。如果调度RB数过少，即$N_{RB}&lt;N_{RB0}$ 时，PT-RS的系统开销相对来说就太大了，这个时候下行没有PT-RS信号。</p><div class="table-container"><table><thead><tr><th style="text-align:center">scheduled bandwidth</th><th style="text-align:center">Frequency density ($K_{PT-RS}$)</th></tr></thead><tbody><tr><td style="text-align:center">$N_{RB}&lt;N_{RB0}$</td><td style="text-align:center">PT-RS is not present</td></tr><tr><td style="text-align:center">$N_{RB0}&lt;N_{RB}&lt;N_{RB1}$</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">$N_{RB1}&lt;N_{RB}$</td><td style="text-align:center">4</td></tr></tbody></table></div><p><strong>timeDensity</strong><br>timeDensity提供了三个范围在（0,29）的值，分别对应[TS 38.214-Table5.1.6.3-1]中的ptrs-MCS1、ptrs-MCS2、ptrs-MCS3，UE再通过DCI中的调度MCS信息就可以确定PT-RS的时域密度(间隔)$L_{PT−RS}$，表中的ptrs-MCS4没有在高层参数中明确配置，UE可以假定该值为当前可使用的最大MCS+1。</p><div class="table-container"><table><thead><tr><th style="text-align:center">scheduled MCS</th><th style="text-align:center">Time density ($L_{PT-RS}$)</th></tr></thead><tbody><tr><td style="text-align:center">$ptrs-MCS1\leq l_{MCS}&lt;ptrs-MCS2$</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">$ptrs-MCS2\leq l_{MCS}&lt;ptrs-MCS3$</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">$ptrs-MCS3\leq l_{MCS}&lt;ptrs-MCS4$</td><td style="text-align:center">1</td></tr></tbody></table></div><p><strong>epre-Ratio</strong><br>epre-Ratio通过[TS 38.214-Table4.1-2] 确定了PT-RS端口每层每个RE上PT-RS EPRE与PDSCH EPRE的比例，这个比例叫$\rho _{PTRS}$, 它与$\beta_{PTRS}$ 的关系为：$\beta_{PTRS}=10^{\frac {\rho_{PTRS}}{20}}$。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/PTRS参数.png" alt></p><p><strong>resourceElementOffset</strong> 见下文表格中参数，取值为{00,01,10,11}。</p><h2 id="3-4-资源映射"><a href="#3-4-资源映射" class="headerlink" title="3.4 资源映射"></a>3.4 资源映射</h2><p>如果PTRS存在，UE将按照按$\beta_{PT_RS}$缩放，并映射到资源单元中：</p><script type="math/tex;mode=display">\alpha_{k,l}^{p,\mu} = \beta_{PT-RS}\cdot r_k</script><h3 id="3-4-1-时域索引"><a href="#3-4-1-时域索引" class="headerlink" title="3.4.1 时域索引"></a>3.4.1 时域索引</h3><p>确定时域索引$l$的步骤如下：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set i &#x3D; 0 and l_&#123;ref&#125;&#x3D;0  </span><br><span class="line">if l_&#123;ref&#125;+iL_&#123;PTRS&#125;  overlaps with a symbol used for DM-RS according to clause 7.4.1.1.2</span><br><span class="line">- set i &#x3D; 1 </span><br><span class="line">- set l_&#123;ref&#125; to the number of the last DM-RS symbol in a sequence of time-contiguous DM-RS occasions</span><br><span class="line">add l_&#123;ref&#125; + iL_&#123;PTRS&#125; to the set of time indices for PT-RS</span><br><span class="line">increment  i by one</span><br><span class="line">repeat from step 2 above as long as l_&#123;ref&#125;+iL_&#123;PTRS&#125; is inside the PDSCH allocation</span><br></pre></td></tr></table></figure><p></p><p>简而言之，PT-RS时域的的范围，从调度的PDSCH的第一个符号开始，避开DMRS所在的位置，以$L_{PT−RS}$为间隔，一直到PDSCH结束。$L_{PT-RS}$不仅是PT-RS之间的间隔，还是与DMRS最后一个符号之间的间隔。如下图所示：<br>图中 仅选取了$1 RB*14 symbol$ 资源单元 ， $l_0 = 2 , L_{PT-RS} = 2$ , single symbol类型。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/PTRS时域图.png" alt></p><h3 id="3-4-2-频域索引"><a href="#3-4-2-频域索引" class="headerlink" title="3.4.2 频域索引"></a>3.4.2 频域索引</h3><p>首先，假定分配给PDSCH的RB为从0到$N_{RB}-1$，那么分配给PDSCH的子载波范围就是0-$N_{sc}^{RB}N_{RB}-1$。最终PTRS频域索引$k$，由下面公式得到：</p><script type="math/tex;mode=display">k=k_{ref}^{RE}+(iK_{PT-RS}+k_{ref}^{RB})N_{sc}^{RB}\\k_{ref}^{RB}= \begin{cases}n_{RNTI}modK_{PT-RS} \quad \quad \quad if N_{RB}modK_{PT-RS} = 0 \\n_{RNTI}mod(N_{RB}modK_{PT-RS})\quad \quad otherwise\end{cases}</script><p>$k_{ref}^{RE}$ 由下表获得[TS 38.311-Table 7.4.1.2.2-1]：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/频域索引.png" alt></p><p>由上可知，$K_{PT-RS}$为相邻 PTRS之间间隔的RB数，即相邻 PTRS之间相差$K_{PT-RS}\cdot N_{sc}^{RB}$ 个子载波，第一个PTRS 子载波定位是 $k_{ref}^{RE}+（0K_{PT-RS}+k_{ref}^{RB}）N_{sc}^{RB}$ 。大概的图样如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/PTRS频域图.png" alt></p><blockquote><p>主要参考：<br>博客：<a href="https://blog.csdn.net/littleBird_2/article/details/89408575" target="_blank" rel="noopener">https://blog.csdn.net/littleBird_2/article/details/89408575</a> (PDSCH)<br>博客：<a href="https://blog.csdn.net/kakamilan/article/details/104535554" target="_blank" rel="noopener">https://blog.csdn.net/kakamilan/article/details/104535554</a> (PDSCH-DMRS)<br>博客：<a href="https://blog.csdn.net/m0_45416816/article/details/103807853" target="_blank" rel="noopener">https://blog.csdn.net/m0_45416816/article/details/103807853</a> (PDSCH-DMRS)<br>博客：<a href="https://blog.csdn.net/littleBird_2/article/details/89683712" target="_blank" rel="noopener">https://blog.csdn.net/littleBird_2/article/details/89683712</a> (PDSCH-PTRS)<br>网页：<a href="http://www.sharetechnote.com" target="_blank" rel="noopener">http://www.sharetechnote.com</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>PDSCH</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-PDCCH学习</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:36 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>PDCCH信道主要承载的是DCI信息。不同的调度信息以DCI format区分，DCI format种类包括以下几种，用于调度PUSCH、PDSCH、TPC、SFI等 [TS 38.212 7.3.1]。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/DCI表格.png" alt></p><p>PDCCH传输过程主要如下图所示:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_01.png" alt></p><p>[TS 38.212 7.3] 中DCI的主要处理过程如下。</p><blockquote><ol><li>Information Element Multiplexing</li><li>CRC Attachment</li><li>Polar Coding</li><li>Rate Matching</li><li>Scrambling</li><li>Modulation</li><li>Resource Element Mapping</li></ol></blockquote><p>下图是一个更加详细的过程：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_02.png" alt></p><h1 id="2-PDCCH-Transport-Process"><a href="#2-PDCCH-Transport-Process" class="headerlink" title="2 PDCCH Transport Process"></a>2 PDCCH Transport Process</h1><h2 id="2-1-Information-Element-Multiplexing"><a href="#2-1-Information-Element-Multiplexing" class="headerlink" title="2.1 Information Element Multiplexing"></a>2.1 Information Element Multiplexing</h2><p>信息元素多路复用这是生成承载各种控制和调度信息的DCI的位串的过程[TS 38.212 7.3]。如果DCI数据长度小于12比特，则填充比特0作为padding。<br>每个字段都按照其在说明中出现的顺序进行映射，包括零填充位（如果有），其中第一个字段映射到最低顺序信息位，每个连续字段映射到较高顺序信息位。 每个字段的最高有效位映射到该字段的最低顺序信息位，例如第一个字段的最高有效位映射到$a_0$。</p><h2 id="2-2-CRC-Attachment"><a href="#2-2-CRC-Attachment" class="headerlink" title="2.2 CRC Attachment"></a>2.2 CRC Attachment</h2><h3 id="2-2-1-CRC-Attach"><a href="#2-2-1-CRC-Attach" class="headerlink" title="2.2.1 CRC Attach"></a>2.2.1 CRC Attach</h3><p>通过循环冗余校验（CRC）在DCI 传输上提供错误检测 [TS 38.212 7.3.2] ，操作流程如下图所示，其中最开始添加的24位数据全是1。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_CRC_01.png" alt></p><h3 id="2-2-2-Masking-with-RNTI"><a href="#2-2-2-Masking-with-RNTI" class="headerlink" title="2.2.2 Masking with RNTI"></a>2.2.2 Masking with RNTI</h3><p>在添加CRC后，最后16位被特定的RNTI加扰。使用该RNTI，UE可以确定DCI是针对哪个UE以及DCI的用途。 [TS 38.212 7.3.2]，操作流程如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_RNTI_Masking_01.png" alt></p><h2 id="2-3-Polar-Coding"><a href="#2-3-Polar-Coding" class="headerlink" title="2.3 Polar  Coding"></a>2.3 Polar Coding</h2><p>信息比特被传送到信道编码块<br>如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_ChannelCoding_01.png" alt></p><h2 id="2-4-Rate-Matching"><a href="#2-4-Rate-Matching" class="headerlink" title="2.4 Rate Matching"></a>2.4 Rate Matching</h2><p>速率匹配的输入比特序列是 $d_0,…,d_{N-1}$，通过设置根据 [TS 38.212 5.4.1] 执行速率匹配 $I_{BIL} = 0$，速率匹配后的输出比特序列表示为 $f_0,…,f_{E-1}$。<br>如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_RateMatching_01.png" alt></p><h2 id="2-5-Scrambling"><a href="#2-5-Scrambling" class="headerlink" title="2.5  Scrambling"></a>2.5 Scrambling</h2><h3 id="2-5-1-CCE"><a href="#2-5-1-CCE" class="headerlink" title="2.5.1 CCE"></a>2.5.1 CCE</h3><p>Rate matching根据分配给PDCCH的资源进行速率匹配，PDCCH分配的基本单位为<strong>CCE</strong>(Control Channel Element)，(1 CCE = 6 REG = 72 RE，1 REG = 1 OFDM symbol * 12 subcarrier = 12 RE)，对于一个PDCCH而言，其由一个或多个CCEs组成，而所分配的CCE数量根据聚合等级的不同而不同，换一句话说，也就是若干个CCE会聚合成PDCCH，聚合成PDCCH的CCE个数就是聚合度，PDCCH所支持的聚合等级下表所示。 [TS 38.211 7.3.1]</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/CCE.png" alt></p><h3 id="2-5-2-CORESET"><a href="#2-5-2-CORESET" class="headerlink" title="2.5.2 CORESET"></a>2.5.2 CORESET</h3><p>UE可被配置多个<strong>CORESET</strong>(Control-resource set, 控制资源集)，其位于BWP内，对于每个BWP最多被配置3个CORESET(包括common和UE-specific CORESETs)。<br>对于PDCCH而言，所传输控制信息的时频位置位于CORESET内，而一个CORESET时频位置的组成：<strong>频域</strong>由$N_{RB}^{CORESET}$个RB组成，<strong>时域</strong>由$N_{symb}^{CORESET} \in \{1,2,3\}$个符号组成。其中$N_{symb}^{CORESET} = 3$ 仅当高层参数 $dmrs-TypeA-Position = 3 $ 时才支持。<br>每个CORESET中有<strong>交织</strong>(分布式)和<strong>非交织</strong>(集中式)两种CCE-to-REG映射可选（由ControlResourceSet IE 中的高层参数cce-REGMappingType配置），但是每个CORESET仅能关联其中一种，其CCE-to-REG映射通过REG bundles描述：</p><p>- REG bundle 被定义为REG$\{iL,iL+1,…,iL+L−1\}$，其中L是REG bundle大小(由高层参数reg-BundleSize指定)，i = 0,1,…,$N_{REG}^{CORESET}/L-1$是， $N_{REG}^{CORESET}$是CORESET中REG数，$N_{REG}^{CORESET} = N_{RB}^{CORESET}\cdot N_{symb}^{CORESET}$；<br>- 最终CCE-REG的映射，是按照REG束来表示的，CCE $j$ 中包含了REG bundle ${f(6j/L),f(6j/L+1),…,f(6j/L+6/L−1)}$。</p><p>对于两种不同的映射方式，有如下描述：<br>- 非交织的 CCE to REG 映射 ， $L = 6\quad and\quad f(j) = j$<br>- 交织的 CCE to REG 映射 ，对于 $N_{symb}^{CORESET} = 1$ , $L\in \lbrace 2,6 \rbrace$；对于$N_{symb}^{CORESET} \in \lbrace 2 ,3 \rbrace$ , $L\in \lbrace N_{symb}^{CORESET} ,6 \rbrace$；$l$由高层参数reg-BundleSize配置。<br>交织器定义如下：</p><script type="math/tex;mode=display">f(j) = (rC+c+n_{shift})mod(N_{REG}^{CORESET}/L)\\j = cR+r\\r = 0,1,...,R-1\\c = 0,1,...,C-1\\C = N_{REG}^{CORESET}/(LR)</script><p>其中 $R\in \{2,3,6 \}$由高层参数interleaverSize给出。对于$n_{shift}$:</p><ul><li>对于PBCH或SIB1配置的CORESET中发送的PDCCH，$n_{shift} = N_{ID}^{cell}$</li><li>除此之外，$n_{shift}\in\{ 0,1,…,274 \}$ 由高层参数shiftIndex给出。</li></ul><p>对于交织和非交织方式，利用直观的例子说明操作过程，例子参考文献中摘抄。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/例子1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/例子2.png" alt></p><ul><li>如果高层参数precoderGranularity = sameAsREG-bundle，则在REG bundle内使用相同的预编码</li><li>如果高层参数precoderEranularity = allContiguousRBs，则在CORESET中的连续资源块集合中的所有资源单元组中使用相同的预编码</li></ul><p>对于由 PBCH配置的 CORESET，UE可以假设交织映射，$ L = 6 , R = 2$ ，以及在 REG bundle中使用的相同预编码。 [TS 38.211 7.3.2.1]</p><h3 id="2-5-3-Scrambling"><a href="#2-5-3-Scrambling" class="headerlink" title="2.5.3 Scrambling"></a>2.5.3 Scrambling</h3><p>UE应采用比特块 $b(0),…,b(M_{bit} -1)$ ($M_{bit}$ 是在物理信道上发送的比特数)，在调制之前被加扰，产生一个加扰比特块 $\widetilde b(0),…,\widetilde b(M_{bit})$ ，根据如下方式加扰：</p><script type="math/tex;mode=display">\widetilde b(i) = (b(i)+c(i))mod2</script><p>其中加扰序列 $c(i)$ 在[TS 38.211 5.2.1]给出，由$Gold$ 序列生成，此时初始化为 $c_{init} $由以下得出：</p><script type="math/tex;mode=display">c_{init} = (n_{RNTI}\cdot 2^{16} + n_{ID})mod2^{31}</script><p>对于$n_{ID}$：<br>- $n_{ID}\in \{0,2,…,65535\}$ = $pdcch-DMRS-ScramnlingID$ (如果已配置) ；<br>- 除此之外 $n_{ID} = N_{ID}^{cell}$。 [TS 38.213]</p><p>对于$n_{RNTI}$：<br>- 如果配置了高层参数 pdcch-DMRS-ScramnlingID，则由C-RNTI给出$UE$特定搜索空间；<br>- 除此之外$n_{RNTI} = 0$。</p><p>整体的流程如下图所展示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_Scrambling_01.png" alt></p><h2 id="2-6-Modulation"><a href="#2-6-Modulation" class="headerlink" title="2.6 Modulation"></a>2.6 Modulation</h2><p>UE应采用比特块 $\widetilde b(0),…,\widetilde b(M_{bit})$按照如[TS 38.211 5.1.3]所述进行 QPSK调制，得到一个复值调制符号块 $d(0),…,d(M_{bit} -1)$。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_Modulation_01.png" alt></p><h2 id="2-7-Resource-Element-Mapping"><a href="#2-7-Resource-Element-Mapping" class="headerlink" title="2.7 Resource Element Mapping"></a>2.7 Resource Element Mapping</h2><p>在用于被监视PDCCH的资源元素组中，UE将假定复数值符号块$\{d(0),…,d(M_{symb}-1))\}$将按比例因子$\beta_{PDCCH}$缩放并映射到资源单元$(k,l)_{p,\mu}$中，其顺序为先是时域，然后是频域，天线端口号$p = 2000$。</p><h2 id="2-8-PDCCH-DMRS"><a href="#2-8-PDCCH-DMRS" class="headerlink" title="2.8 PDCCH DMRS"></a>2.8 PDCCH DMRS</h2><h3 id="2-8-1-Sequence-generation"><a href="#2-8-1-Sequence-generation" class="headerlink" title="2.8.1 Sequence generation"></a>2.8.1 Sequence generation</h3><p>UE应采用如下方式定义参考信号序列$r_l(m)$：</p><script type="math/tex;mode=display">r_l(m) = \frac{1}{\sqrt{2} }(1-2*c(2m)) + j\frac{1}{\sqrt{2} }(1-2*c(2m+1))</script><p>加扰序列 $c(i)$ 在[TS 38.211 5.2.1]给出，由$Gold$ 序列生成，此时初始化为 $c_{init} $由以下得出：</p><script type="math/tex;mode=display">c_{init} = (2^{17}(14n_{s,f}^\mu+l+1)(2N_{ID}+1)+2N_{ID})mod2^{31}</script><p>其中：$l$ 是$slot$ 内OFDM符号编号，$n_{s,f}^\mu$ 是帧内的 $slot$ 号</p><p>对于$n_{ID}$：<br>- $n_{ID}\in \{0,2,…,65535\}$ = $pdcch-DMRS-ScramnlingID$ (如果已配置)；<br>- 除此之外 $n_{ID} = N_{ID}^{cell}$。 [TS 38.213]</p><h3 id="2-8-2-Resource-Element-Mapping"><a href="#2-8-2-Resource-Element-Mapping" class="headerlink" title="2.8.2 Resource Element Mapping"></a>2.8.2 Resource Element Mapping</h3><p>$UE$ 将$r_l(m)$ 映射到资源单元$(k,l)_{p,\mu}$ ，根据如下：</p><script type="math/tex;mode=display">\alpha_{k,l}^{p,\mu} = \beta_{DMRS}^{PDCCH}\cdot r_l(3n+k')\\ k = nN_{sc}^{RB}+4k'+1\\ k' = 0 ,1,2\\ n = 0,2,...</script><p>可以看出，每个RB上有3个DMRS RE，分别位于$4k’+1$ 的位置，即1、5、9号子载波。<br>$l$ 指在一个时隙内的OFDM符号；天线端口 $p$ 固定为2000。</p><p>对于precoderGranularity：<br>- 如果配置为 sameAsREG-bundle，那么该CORESET对应的DMRS仅在UE需要检测PDCCH的REG上；<br>- 如果配置为allContiguousRBs，则在组成CORESET的REG上都有DMRS映射。</p><p>对于参考点$k$：<br>- 如果CORCHET由PBCH或SIB1配置，则为CORESET中编号最小的资源块的子载波0，<br>- 否则，为公共资源块0中的子载波0</p><p>上述描述由下图可直观表示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/DMRS参考点.png" alt></p><blockquote><p>主要参考：<br>微信公众号：5G菜鸟成长日记<br>文章：Understanding the Heart of the 5G Air Interface: An Overview of Physical Downlink Control Channel for 5G New Radio (NR)<br>博客：<a href="https://blog.csdn.net/qq_33206497/article/details/89645976" target="_blank" rel="noopener">https://blog.csdn.net/qq_33206497/article/details/89645976</a><br>博客：<a href="https://blog.csdn.net/littleBird_2/article/details/88372875" target="_blank" rel="noopener">https://blog.csdn.net/littleBird_2/article/details/88372875</a><br>网页：<a href="http://www.sharetechnote.com/html/5G/5G_PDCCH.html#Ref_01" target="_blank" rel="noopener">http://www.sharetechnote.com/html/5G/5G_PDCCH.html#Ref_01</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>PDCCH</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-SSB学习</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Wed May 19 2021 11:14:37 GMT+0800 (GMT+08:00) --><a id="more"></a><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>SS/PBCU Block简称SSB，主要包含PSS、SSS以及PBCH。对于SSB的学习，主要采用如下步骤来学习，并加深理解的：</p><blockquote><ol><li>NR SSB 时域频域分析</li><li>PSS/SSS序列</li><li>PBCH payload 生成及处理</li><li>PBCH加扰/调制/RE映射</li><li>PBCH DMRS</li><li>UE SSB处理过程</li><li>同步过程理解</li></ol></blockquote><h1 id="二、学习进程"><a href="#二、学习进程" class="headerlink" title="二、学习进程"></a>二、学习进程</h1><h2 id="2-1-NR-SSB-时域频域分析"><a href="#2-1-NR-SSB-时域频域分析" class="headerlink" title="2.1 NR SSB 时域频域分析"></a>2.1 NR SSB 时域频域分析</h2><p>PSS和SSS主要用于UE获得时间同步和频率同步，获取小区ID；PBCH用于无线帧号同步以及SIB1的配置。与LTE的差异主要在于SSS序列都一样，不存在前后5 ms的差异且SSB的周期是可配置的，以及引入了beam index的概念。</p><h3 id="2-1-1-SSB时域分析"><a href="#2-1-1-SSB时域分析" class="headerlink" title="2.1.1 SSB时域分析"></a>2.1.1 SSB时域分析</h3><p>在5G中，每个SSB对应一个beam， SSB的最短时间跨度为5 ms，也就是半帧。一个半帧中可能存在多个SSB，我们将一个半帧中存在的一个或多个SSB称为SS Burst Set，一个SS Burst Set中的SSB包含的信息相同。两个SS Burst Set出现的时间，也就是存在SSB的半帧出现的时间是可以配置的，成为SS Burst Set Periodicity，5 ms–160 ms范围。默认为20 ms。<br>根据[TS 38.213]中的SSB的时间分布描述，总结成如下表所示。从表中可以看到，SSB符号的起始位置取决于Case类型以及所处频段，一个SSB在时域上占据4个符号。Num为SSB的总数。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/1.png" alt></p><p>以Case A，小于等于3 GHz为例，其符号位置如下图所示，SSB总数为4，各个SSB代表了不同的波束方向。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/2.png" alt></p><p>SSB的Case由Band决定，[TS 38.104]中规定</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/3.jpg" alt></p><h3 id="2-1-2-SSB频域分析"><a href="#2-1-2-SSB频域分析" class="headerlink" title="2.1.2 SSB频域分析"></a>2.1.2 SSB频域分析</h3><p>由上一节可知SSB时域是由4个symbol组成，而频域是由20个RB，也即240个子载波构成，它包含着set 0 ,PSS,SSS,PBCH,DMRS,结构如下表所示</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/4.png" alt></p><p>综合以上，下图更直观的显示SSB时域频域分布，横轴为频域，纵轴为时域。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/5.png" alt></p><p>与LTE中PSS和SSS固定在带宽的中间73个子载波不同，NR中SSB可能的频域位置有很多。NR中有一系列全局同步信道号GSCN，每个GSCN都会对应一个确定的、绝对的频率位置，系统会把SSB放在这些GSCN上，对齐方式为SSB的10号RB的0号子载波与GSCN对齐，UE就会在这些GSCN上挨个盲检SSB。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/GSCN.png" alt></p><p>不同的operating band是分配给不同运营商的，所以UE是知道自己处在哪个operating band上的，比如n28分配给广电的，那么接入广电网络的UE在搜索SSB的时候，就盲检1901 – $&lt;$1$&gt;$ – 2002这个范围内的GSCN(参考2.1.1表格)，并且只搜索15kHz子载波间隔、case A下的SSB。</p><p>确定整个CRB中SSB所处于的位置，需要通过$K_{ssb}$和CORESET#0相应的offsetRB来确定。[TS 38.211]中$K_{ssb}$来表示公共资源快$N_{CRB}^{SSB}$子载波0相对SSB子载波0的偏移。$K_{SSB}$的低4bit由MIB参数中的ssb-SubcarrerOffset给出。<br>对于SSB类型B，即（μ= 3 or 4）来说,$K_{SSB}$={0,…,11}, 4 bit足够。<br>对于SSB类型A，即（μ= 0 or 1）来说, $K_{SSB}$={0,…,23}, 4 bit不够，需要5 bit来表示，因此使用PBCH payload中$a_{\overline A+5}$来表示高比特位。下文会说明。<br>最终SSB在整个CRB中的位置如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/6.png" alt></p><h2 id="2-2-PSS-SSS序列"><a href="#2-2-PSS-SSS序列" class="headerlink" title="2.2 PSS/SSS序列"></a>2.2 PSS/SSS序列</h2><h3 id="2-2-1-PCI"><a href="#2-2-1-PCI" class="headerlink" title="2.2.1 PCI"></a>2.2.1 PCI</h3><p>PCI(Physical Cell Identifier)，物理小区标识，$N_{ID}^{cell}$定义如下：</p><script type="math/tex;mode=display">N_{ID}^{cell} = 3N_{ID}^{(1)} + N_{ID}^{(2)}\\N_{ID}^{cell}\in\lbrace 0,1,...,1007\rbrace\\N_{ID}^{(1)}\in\lbrace 0,1,...,355\rbrace\\N_{ID}^{(2)}\in \lbrace 0,1,2\rbrace</script><h3 id="2-2-2-PSS"><a href="#2-2-2-PSS" class="headerlink" title="2.2.2 PSS"></a>2.2.2 PSS</h3><p>PSS(Primary Synchronization Signal)，主同步信号，序列定义如下：</p><script type="math/tex;mode=display">d_{pss}(n) = 1 - 2x(m)\\m = (n + 43N_{ID}^{(2)})mod127\\0 ≤ n < 127</script><p>$x(m)$由如下序列得出：</p><script type="math/tex;mode=display">x(i+7) = (x(i+4)+x(i))mod2\\ [x(6)\quad x(5)\quad x(4)\quad x(3)\quad x(2)\quad x(1)\quad x(0)] = [1\quad 1\quad 1\quad 0\quad 1\quad 1\quad 0]</script><p>PSS部分映射在SSB中间12个RB上,占用144个子载波，PSS序列映射在56-182，前8个和后9个为保护间隔(guard band)。</p><h3 id="2-2-3-SSS"><a href="#2-2-3-SSS" class="headerlink" title="2.2.3 SSS"></a>2.2.3 SSS</h3><p>SSS(Secondary Synchronization Signal)，辅同步信号，序列定义如下：</p><script type="math/tex;mode=display">d_{sss}(n) = [1 - 2x_0((n + m_0)mod127)][1 - 2x_1((n + m_1)mod127)]\\m_0 = 15[\frac{N_{ID}^{(1)}}{112}] + 5N_{ID}^{(2)}\\m_1 = N_{ID}^{(1)}mod112\\0\quad \leq n < 127</script><p>$x_1(m)$和$x_2(m)$由如下序列得出：</p><script type="math/tex;mode=display">x_0(i+7) = (x_0(i+4)+x_0(i))mod2\\ x_1(i+7) = (x_1(i+1)+x_1(i))mod2\\ [x_0(6)\quad x_0(5)\quad x_0(4)\quad x_0(3)\quad x_0(2)\quad x_0(1)\quad x_0(0)] = [0\quad 0\quad 0\quad 0\quad 0\quad 0\quad 1]\\ [x_1(6)\quad x_1(5)\quad x_1(4)\quad x_1(3)\quad x_1(2)\quad x_1(1)\quad x_1(0)] = [0\quad 0\quad 0\quad 0\quad 0\quad 0\quad 1]</script><p>SSS与PSS相同，映射在SSB中间12个RB上,占用144个子载波，PSS序列映射在56-182，前8个和后9个为保护间隔(guard band)。</p><h2 id="2-3-PBCH-payload-生成及处理"><a href="#2-3-PBCH-payload-生成及处理" class="headerlink" title="2.3 PBCH payload 生成及处理"></a>2.3 PBCH payload 生成及处理</h2><p>PBCH payload 组成如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/7.png" alt></p><h3 id="2-3-1-BCCH"><a href="#2-3-1-BCCH" class="headerlink" title="2.3.1 BCCH"></a>2.3.1 BCCH</h3><p>BCCH共24比特，其中B如果指示的是MIB信息，其中MIB信息只有23比特。看[TS 38.311 ]中的BCCH-BCH-Message结构，其中有1比特Choice指示，指示是mib还是messageClassExtension。<br>MIB的内容如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/8.png" alt></p><p><strong>systemFrameNumer</strong>- 无线帧号指示，这里只有6比特，还有4比特在PBCH payload中添加; <strong>6 bit</strong><br><strong>subCarrierSpacingCommon</strong> - 指示SIB1的子载波间隔，FR1为15KHz或60KHz，FR2为30KHz或120KHz; <strong>1 bit</strong><br><strong>ssb-SubcarrerOffset</strong><br>是距离SSB底部距离RB边界位置的偏移$K_{SSB}$, <strong>4 bit</strong><br>对于FR2来说, $K_{SSB}$={0,…,11}足够<br>对于FR1来说，$K_{SSB}$={0,…,23}不够，需要在PBCH payload中添加一位共同指示，即$a_(A+5)$<br><strong>dmrs-TypeA Position </strong>- PUSCH/PDSCH DMRS位置参数 <strong>1 bit</strong><br><strong>pdcch-ConfigSIB1</strong>- 共8比特，确定SIB1调度的时频位置 <strong>8 bit</strong><br><strong>cellBarred</strong> - 小区是否被准许接入指示 <strong>1 bit</strong><br><strong>intraFreqReselection</strong> - 是否允许同频重选指示 <strong>1 bit</strong></p><h3 id="2-3-2-PBCH-payload中其他内容"><a href="#2-3-2-PBCH-payload中其他内容" class="headerlink" title="2.3.2 PBCH payload中其他内容"></a>2.3.2 PBCH payload中其他内容</h3><p>PBCH payload还需要加上SFN的低4比特，half-frame半帧信息（由于5ms内映射完所有SSB，需要1比特指示是在前5 ms还是后5 ms，$n_{hf}$=0时，表示前半帧；当$n_{hf}$=1，表示第二个半帧），以及3比特 SSB index(SSB index的高3比特)或者$k_{ssb}$信息（取决于SSB总数，即 NR SSB时域频域分布中根据band指示确定的SSB总数Num，或者$L_{max}$），最终PBCH payload共<strong>32比特</strong>。</p><h3 id="2-3-3-PBCH-payload-操作"><a href="#2-3-3-PBCH-payload-操作" class="headerlink" title="2.3.3 PBCH payload 操作"></a>2.3.3 PBCH payload 操作</h3><p><strong>step 1</strong> - 确定载荷中内容（由前文已知）<br><strong>step 2</strong> - reorder<br>根据比特信息重新进行排序，G(j)即为排序后的顺序。操作后 (<strong>32 比特</strong>) ，如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/9.png" alt></p><p><strong>step 3</strong> - scrambling<br>对于确定$v$值的无线帧号对应的$2^{nd}$/$3^{rd}$ LSB，半帧信息以及SSB index不进行加扰，加扰序列每80 ms进行初始化，$L_{max}$也即SSB总数。操作后(<strong>32 比特</strong>)，如下图所示：<br><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/10.png" alt></p><p><strong>step 4</strong> - CRC 添加循环冗余码后输出数据长度为32+24 = <strong>56 比特</strong><br><strong>step 5</strong> - Polar Coding 输出比特长度为N = $2^9$ = <strong>512比特</strong><br><strong>step 6</strong> - Rate Matching 输出数据长度为E = <strong>864 比特</strong>（E = 864即文章NR SSB时域频域分布中的PBCH所占RE个数432乘以2）</p><h2 id="2-4-PBCH加扰-调制-RE映射"><a href="#2-4-PBCH加扰-调制-RE映射" class="headerlink" title="2.4 PBCH加扰/调制/RE映射"></a>2.4 PBCH加扰/调制/RE映射</h2><h3 id="2-4-1-加扰"><a href="#2-4-1-加扰" class="headerlink" title="2.4.1 加扰"></a>2.4.1 加扰</h3><p>加扰部分相关参数取决于小区ID与SSB index。[TS 38.211 7.3.3.1] , 加扰由以下公式得出：</p><script type="math/tex;mode=display">\widetilde{b(i)} = (b(i)+c(i+vM_{bit}))mod2</script><p>加扰序列 $c(i)$ 在[TS 38.211 5.2.1]给出，由$Gold$ 序列生成，此时初始化为 $c_{init} = N_{ID}^{cell}$。<br>-对于 $L_{max} = 4$，$v$ is the 2 LSB of SSB index ;<br>-对于 $L_{max} = 8\quad or\quad 64 $，$v$ is the 3 LSB of SSB index ;</p><h3 id="2-4-2-调制"><a href="#2-4-2-调制" class="headerlink" title="2.4.2 调制"></a>2.4.2 调制</h3><p>PBCH使用QPSK调制方式。</p><h3 id="2-4-3-映射"><a href="#2-4-3-映射" class="headerlink" title="2.4.3 映射"></a>2.4.3 映射</h3><p>参照2.1节 NR SSB时域频域分布中的PBCH数据部分的RE映射，先时域后频域。</p><h2 id="2-5-PBCH-DMRS"><a href="#2-5-PBCH-DMRS" class="headerlink" title="2.5 PBCH DMRS"></a>2.5 PBCH DMRS</h2><h3 id="2-5-1-序列生成"><a href="#2-5-1-序列生成" class="headerlink" title="2.5.1 序列生成　"></a>2.5.1 序列生成</h3><p>UE应该采用参考信号序列$r(m)$对PBCH DMRS定义，相关参数取决于小区ID，SSB index还有半帧信息来觉得。由[TS 38.211 7.4.1.4.1]给出：</p><script type="math/tex;mode=display">r(m) = \frac{1}{ \sqrt{2} }(1-2*c(2m)) + j\frac{1}{ \sqrt{2} }(1-2*c(2m+1))</script><p>加扰序列 $c(i)$ 在[TS 38.211 5.2.1]给出，由$Gold$ 序列生成，此时初始化为 $c_{init} $由以下得出：</p><script type="math/tex;mode=display">c_{init} = 2^{11}( \overline{i}_{SSB}+1)([N_{ID}^{cell}/4]+1) + 2^6( \overline{i}_{SSB}+1)) + (N_{ID}^{cell}mod4)</script><p>-对于 $L_{max} = 4$，$\overline{i}_{SSB}$ 是SSB index 的2比特最低有效位和1比特半帧信息$n_{hf}$ (构成3比特，高位是半帧信息，也即$\overline{i}_{SSB} = {i}_{SSB} + 4n_{hf}$ );<br>-对于 $L_{max} = 8\quad or\quad 64 $，$\overline{i}_{SSB}$ 是SSB index 的3比特最低有效位(也即$\overline{i}_{SSB} = {i}_{SSB}$ )<br>-以上${i}_{SSB}$也即分别对应2.4.1中的$v$。</p><h3 id="2-5-2-映射"><a href="#2-5-2-映射" class="headerlink" title="2.5.2 映射"></a>2.5.2 映射</h3><p>参照2.1节 NR SSB时域频域分布中的PBCH DMRS数据部分的RE映射，$v = N_{ID}^{cell}mod4$(此时的v不同于上文)，先时域后频域。<strong>同频邻区设置不同的偏移有利于降低导频干扰</strong>。</p><h2 id="2-6-UE-SSB处理过程"><a href="#2-6-UE-SSB处理过程" class="headerlink" title="2.6 UE SSB处理过程"></a>2.6 UE SSB处理过程</h2><p>UE的处理过程即为上述过程的一个逆过程。</p><ol><li><p>通过PSS/SSS可以获得SSB的符号起始位置，小区ID；</p></li><li><p>通过小区ID，可以获得PBCH DMRS的频域位置，PBCH DMRS携带了3比特信息，具体代表的信息取决于$L_{max}$。PSS/SSS频点信息即确定了其所属Band，也就能够确定$L_{max}$的值，那么<br>1）$L_{max} = 4$，确定SSB index以及半帧指示；<br>2）$L_{max} = 8\quad or\quad 64$，确定SSB index低3比特；</p></li><li><p>PBCH RE解映射，解调制，2.4.1节处加扰对应的第一次解扰，此处解扰通过小区ID与由步骤2中确定SSB index的比特信息可以确定；</p></li><li><p>PBCH 解速率匹配，Polar译码，CRC校验，2.3.3节处加扰对应的第二次解扰，注意到无线帧号对应的2nd/3rd LSB未进行加扰，因此可以确定加扰序列，Cinit 80ms作为一次初始化，如下图所示：</p></li></ol><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/11.png" alt></p><ol><li>解交织，确定PBCH payload；</li></ol><h2 id="2-7-同步过程理解"><a href="#2-7-同步过程理解" class="headerlink" title="2.7 同步过程理解"></a>2.7 同步过程理解</h2><p>同步过程是移动终端获得无线网络的时间和频率的过程，是终端接入网络的前提。终端要知道网络在哪个时间，哪个频率上发送什么消息，才能正确接收网络下发的信息，而同步过程就是为了使终端知道这个时间和频率信息而进行的一系列操作。这些操作与2.6节<strong>UE SSB处理过程</strong>相互重叠。更形象的流程如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/概念.png" alt></p><p>第一步的时间与频率同步所指的是一般意义上，我们在通信系统课程中会学到的，接收端与发射端在时间域和频率域上的同步。它并不在5G协议的规定范围之内，一般都是由芯片厂家自己实现的。这一步常用的方法有互相关检测和自相关检测等，也就是通过将接收信号与已知信号(PSS)做互相关来检测已知信号的位置，或者通过对接收信号自身做自相关来检测循环前缀（CP）的位置。<br>这一步是为了获得OFDM的符号同步（时间同步）和检测同步信号所在频率（频率同步）。</p><p>一个可能的过程：<br>1、终端将射频接收机调谐到指定频点;<br>2、在时域对PSS做<strong>互相关检测</strong>以取得时域同步，同时获得$N_{ID}^{(2)}$; (在SSB的第一个symbol时间内，SSB频域范围内只有PSS信号，因此可以对它做相关检测; 相反，因为SSS所在的第三个symbol时间内还有PBCH，所以无法对它做时域相关检测）<br>3、根据PSS的位置可以获得SSS的位置，在频域对SSS做互相关检测，可以获得频域同步并同时获得$N_{ID}^{(1)}$;<br>4、由$N_{ID}^{(1)}$; 和$N_{ID}^{(2)}$; 可以获得PCI，由PCI又可以进一步解码PBCH DMRS, 从而获得SSB index和 half frame number $n_{hf}$;<br>5、最后利用对DMRS的信道估计，终端解码PBCH并获得系统消息MIB。</p><p>这里是一个matlab对上述过程的模拟程序：</p><blockquote><p><a href="https://www.mathworks.com/help/5g/examples/NR-Synchronization-Procedures.html" target="_blank" rel="noopener">https://www.mathworks.com/help/5g/examples/NR-Synchronization-Procedures.html</a></p></blockquote><p>由上一步可知，UE SSB处理过程与同步过程如出一辙，就是为了使终端知道这个时间和频率信息而进行的一系列操作。</p><blockquote><p>主要参考：<br>微信公众号：5G菜鸟成长日记，<br>博客：<a href="https://www.cnblogs.com/beilou310/p/11162798.html" target="_blank" rel="noopener">https://www.cnblogs.com/beilou310/p/11162798.html</a><br>博客：<a href="https://blog.csdn.net/qq_44113393/article/details/89844595" target="_blank" rel="noopener">https://blog.csdn.net/qq_44113393/article/details/89844595</a><br>博客：<a href="https://blog.csdn.net/m0_45416816/article/details/96605980" target="_blank" rel="noopener">https://blog.csdn.net/m0_45416816/article/details/96605980</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>SSB</tag>
      </tags>
  </entry>
</search>
