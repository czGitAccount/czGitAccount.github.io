<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>5G-NR-213协议补充</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<!-- build time:Mon May 04 2020 17:17:36 GMT+0800 (GMT+08:00) --><h1 id="TS-38-213-部分补充"><a href="#TS-38-213-部分补充" class="headerlink" title="TS 38.213 部分补充"></a>TS 38.213 部分补充</h1><h2 id="1-上行功率控制"><a href="#1-上行功率控制" class="headerlink" title="1. 上行功率控制"></a>1. 上行功率控制</h2><p>上行的主要几个信道/信号</p><ol><li>PUSCH</li><li>PUCCH</li><li>SRS</li><li>PRACH</li></ol><h3 id="1-1-PUSCH"><a href="#1-1-PUSCH" class="headerlink" title="1.1 PUSCH"></a>1.1 PUSCH</h3><p>UE首先需要基于$P_{PUSCH,b,f,c}(i,j,q_{d},l)$ 线性映射一个值 $P‘_{PUSCH,b,f,c}(i,j,q_{d},l)$</p><ul><li><em>b</em>：BWP</li><li><em>f</em>：carrier</li><li><em>c</em>：serving</li><li><em>j</em>：parameter configuration index</li><li><em>i</em> ：transmission occasion</li></ul><p>$P_{PUSCH,b,f,c}(i,j,q_{d},l)$ 取下列两项较小的值</p><ul><li>$P_{CMAX,f,c}(i)$，UE 的最大传输功率，由 [8-1, TS 38.101-1~2] 定义；</li><li>$P_{O_PUSCH,b,f,c}(j)+10log_{10}(2^{\mu}M_{RB,b,f,c}^{PUSCH}(i))+\alpha_{b,f,c}(j)PL_{b,f,c}(q_d)+\Delta_{TF,b,f,c}(i)+f_{b,f,c}(i,l)$</li></ul><p>参数说明：</p><ul><li>$P_{O_PUSCH,b,f,c}(j)$ 是 $P_{O_NOMINAL_PUSCH,f,c}(j)$ 和 $P_{O_UE_PUSCH,b,f,c}(j)$之和，由高层配置，具体见协议(下同)；</li><li>$\alpha_{b,f,c}(j)$ 需要高层配置，否则为1；</li><li>$M_{RB,b,f,c}^{PUSCH}(i))$ 是PUSCH资源的带宽，即RB数目[4,TS 38.211]</li><li>$PL_{b,f,c}(q_d)$ 是下行路径损耗估计；</li><li>$\Delta_{TF,b,f,c}(i)$ 由高层配置。</li></ul><h3 id="1-2-PUCCH"><a href="#1-2-PUCCH" class="headerlink" title="1.2 PUCCH"></a>1.2 PUCCH</h3><p>$P_{PUCCH,b,f,c}(i,q_u,q_{d},l)$ 取下列两项较小的值：</p><ul><li>$P_{CMAX,f,c}(i)$，UE的最大传输功率，由 [8-1, TS 38.101-1~2] 定义；</li><li>$P_{O_PUCCH,b,f,c}(q_u)+10log_{10}(2^{\mu}M_{RB,b,f,c}^{PUCCH}(i))+PL_{b,f,c}(q_d)+\Delta_{F_PUCCH(F)}+\Delta_{TF,b,f,c}(i)+g_{b,f,c}(i,l)$</li></ul><p>PUCCH的参数类似于PUSCH，具体的配置取决协议。</p><h3 id="1-3-SRS"><a href="#1-3-SRS" class="headerlink" title="1.3 SRS"></a>1.3 SRS</h3><p>$P_{SRS,b,f,c}(i,q_s,l)$ 取下列两项较小的值：</p><ul><li>$P_{CMAX,f,c}(i)$，UE的最大传输功率，由 [8-1, TS 38.101-1~2] 定义；</li><li>$P_{O_SRS,b,f,c}(q_s)+10log_{10}(2^{\mu}M_{RB,b,f,c}^{SRS}(i))+\alpha_{b,f,c}(q_s)PL_{b,f,c}(q_d)+h_{b,f,c}(i,l)$</li></ul><p>同上，具体的配置取决协议。</p><h3 id="1-4-PRACH"><a href="#1-4-PRACH" class="headerlink" title="1.4 PRACH"></a>1.4 PRACH</h3><p>$P_{PRACH,b,f,c}(i)=min\{P_{CMAX,f,c}(i),P_{PRACH,target,f,c}+PL_{b,f,c}\}$</p><p>其中：</p><ul><li>$P_{CMAX,f,c}(i)$ 是UE配置的最大输出功率，由 [8-1. TS 38.101-1~2]给出。</li><li>$P_{PRACH,target,f,c}$ 为PRACH 目标接收功率 <em>PREAMBLE_RECEIVED_TARGET_POWER</em> 由[11. TS 38.321] 给出计算公式：<em>PREAMBLE_RECEIVED_TARGET_POWER</em> = <em>preambleReceivedTargetPower</em> + <em>DELTA_PREAMBLE</em> + <em>(PREAMBLE_POWER_RAMPING_COUNTER -1)</em> <em></em>PREAMBLE_POWER_RAMPING_STEP*<ul><li><em>preambleReceivedTargetPower</em> 由参数 <em>preambleReceivedTargetPower</em> 给出</li><li><em>DELTA_PREAMBLE</em>可由[TS 38.321 Table 7.3-1~2] 获得</li><li><em>PREAMBLE_POWER_RAMPING_COUNTER</em> 对初始传输为1，依据重传次数自增一</li><li><em>PREAMBLE_POWER_RAMPING_STEP</em> 由参数 <em>powerRampingStep</em> 给出<br>（以上两条是为了功率攀升而设定的参数）</li></ul></li></ul><h2 id="2-用于监控-Type0-PDCCH-公共搜索空间的UE过程"><a href="#2-用于监控-Type0-PDCCH-公共搜索空间的UE过程" class="headerlink" title="2 用于监控 Type0-PDCCH 公共搜索空间的UE过程"></a>2 用于监控 Type0-PDCCH 公共搜索空间的UE过程</h2><p>其大部分的内容SSB中描述过，以下补充一些内容。</p><h3 id="2-1-简述"><a href="#2-1-简述" class="headerlink" title="2.1 简述"></a>2.1 简述</h3><p>UE获得了SSB信息后，MIB信息有限，还不足以驻留小区和进一步发起初始接入，UE还需要得到一些“必备”的系统信息SIB，这个系统信息在NR中被称为RMSI，可以认为SIB1。<br>NR中的SIB1信息，通过下行PDCCH信道发送，而PDSCH信道需要PDCCH信道的DCI来调度。UE需要在MIB中得到调度RMSI的PDCCH信道信息，在PDCCH上进行盲检，获得RMSI。MIB中通过8bit的<em>pdcch-ConfigSIB1</em>字段，指示UE获取RMSI调度的PDCCH的信息。</p><p>大致的过程如下图所描述：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p1-RMSI.png" alt></p><h3 id="2-2-k-SSB-字段"><a href="#2-2-k-SSB-字段" class="headerlink" title="2.2 $k_{SSB}$ 字段"></a>2.2 $k_{SSB}$ 字段</h3><p>SSB部分学习的描述了$k_{SSB}$，他的主要作用就是标记 SSB #0子载波与最近的CRB n #0 子载波的偏移量。<br>$k_{SSB}$的4bits LSB 由 MIB参数中的 ssb-SubcarrerOffset 给出。<br>对于SSB类型B (FR2)，即（μ= 3 or 4）来说, $k_{SSB}$ = {0,…,11}, 4 bits足够。<br>对于SSB类型A (FR1)，即（μ= 0 or 1）来说, $ k_{SSB}$ = {0,…,23}, 4 bits不够，需要5 bits来表示，因此使用PBCH payload中$a_{\overline A+5}$来表示高比特位。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p2-频移.png" alt></p><p>NR小区中，可以在不同频域位置有多个 SSB (用于终端测量)，而并不需要每个SSB都有其指向的 CORESET 0 。</p><p>如果再空闲状态下，当UE搜索到的SSB (没有指向CORESET 0)，UE期望基站最好能够通知UE下一个的SSB(有指向CORESET 0 )，以便于UE快速监听到。$K_{ssb}$ 字段不只是描述了RE级别的偏移，也起到了这个作用。</p><p>UE根据 $K_{ssb}$ 判定 Type0-PDCCH 公共搜索空间是否存在。若：</p><ul><li>$K_{ssb} &gt; 23,FR1$</li><li>$K_{ssb} &gt; 11,FR1$</li></ul><p>则：当前 SSB对应的Type0-PDCCH公共搜索空间不存在</p><p>UE通过 $K_{ssb}$ 发现当前Type0-PDCCH公共搜索空间不存在时，可以通过 $K_{ssb}$的值，在最近的GSCN上找下一个SSB 上的 RMSI 的搜索空间。当：</p><script type="math/tex;mode=display">24\leq k_{SSB} \leq 29 \quad FR1\quad 12\leq k_{SSB} \leq 13 \quad FR2</script><p>则下一个 SSB 对应的GSCN上频点 $N_{GSCN}^{Reference}+N_{GSCN}^{Offect}$</p><p>其中：<br>$N_{GSCN}^{Reference}$：当前SSB的GSCN上的频点<br>$N_{GSCN}^{Offect}$：下一个SSB的GSCN频点偏移，根据 $k_{SSB}$ 和MIB 中的 <em>pdcch-ConfigSIB1</em>，共同确定。参考以下表格：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/T1-213-13.16.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/T2-213-13.17.png" alt></p><p>如果在第二个SSB 上还是没有提供 RMSI CORESET 0，则UE忽略执行小区搜索的GSCN信息。</p><p>当 $k_{SSB}=31\quad FR1\quad k_{SSB}=15\quad FR2$ ，则表示SSB所在的GSCN一段频点范围(见下)内的SSB，都没有 CORESET 0；</p><script type="math/tex;mode=display">[N_{GSCN}^{Reference}-N_{GSCN}^{Start},N_{GSCN}^{Reference}+N_{GSCN}^{End}]</script><p>其中：<br>$N_{GSCN}^{Start}$ 和 $N_{GSCN}^{End}$ 分别为 <em>pdcch-ConfigSIB1</em> 中的<em>controlResourceSetZero</em> 和 <em>searchSpaceZero</em> 决定，也就是其 4 bits MSB 和 4 bits LSB。</p><p>UE 在一个时间周期内，都没有搜索到带 RMSI 的 CORESET 0 的SSB，则UE忽略执行小区搜索的GSCN信息。</p><h3 id="2-3-CORESET-0"><a href="#2-3-CORESET-0" class="headerlink" title="2.3 CORESET 0"></a>2.3 CORESET 0</h3><h4 id="2-3-1-CORESET-0-的时频域资源"><a href="#2-3-1-CORESET-0-的时频域资源" class="headerlink" title="2.3.1 CORESET 0 的时频域资源"></a>2.3.1 CORESET 0 的时频域资源</h4><p>CORESET 0的物理时频域资源和SSB之间存在三种复用模式： Pattern1/2/3，如下图所示 (摘抄自春天工作室)：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/P4-复用模式.png" alt></p><p>上图仅为示例，图中的时频域资源未必完全对其。</p><h4 id="2-3-2-CORESET-0-的频域资源"><a href="#2-3-2-CORESET-0-的频域资源" class="headerlink" title="2.3.2 CORESET 0 的频域资源"></a>2.3.2 CORESET 0 的频域资源</h4><p>SSB块和Type0-PDCCH 公共搜索空间的CORESET 0在时频域资源都有较大灵活性，两者之间的对应关系也比较复杂，而要用MIB中有限的 8bits 信息表示两者关系，必须对两者映射关系做一定约束。协议中定义了多种时频域映射组合关系。</p><p>pdcch-ConfigSIB1:</p><ul><li>4 bits MSB，SSB和CORESET 0 的SCS，符号数，PRB offset配置，对应 [TS 38.213 Table 13-1~10]</li><li>4 bits LSB，CORESET 0 的SFN，时隙索引等，时域相关配置，对应 [TS 38.213 Table 13-11~15]</li></ul><p>CORESET 0 的频域资源：Pattern1/2/3</p><ul><li>Pattern 1</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p5-pattern1例子一.png" alt></p><p>若 index = 0；</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p8-pattern1例子二.png" alt></p><p>若 index = 1;</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p9-pattern1例子三.png" alt></p><ul><li>pattern 2</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p6-pattern2例子一.png" alt></p><p>若 index = 6，index = 7;</p><p>$k_{SSB} = 0$</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p10-pattern2例子二.png" alt></p><p>$k_{SSB} &gt; 0$</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p11-pattern2例子三.png" alt></p><ul><li>pattern 3</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p7-pattern3例子一.png" alt></p><p>若 index = 6，index = 7;</p><p>$k_{SSB} = 0$</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p12-pattern3例子二.png" alt></p><p>$k_{SSB} &gt; 0$</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p13-pattern3例子三.png" alt></p><h4 id="2-3-2-CORESET-0-的时域资源"><a href="#2-3-2-CORESET-0-的时域资源" class="headerlink" title="2.3.2 CORESET 0 的时域资源"></a>2.3.2 CORESET 0 的时域资源</h4><p>对于复用pattern 2/3，CNRESET 0的时域分布相对简单明：</p><ol><li>CORESET 0，即Type 0 公共搜索空间周期等于SSB的周期</li><li>CORESET 0 和 SSB在同一个时隙内</li><li>时隙号 $n_c$ 和帧号 $SFN_c$ 在 [TS 38.213 Table 13-13~15] 中定义</li></ol><p>对于复用pattern 1，SSB 和 CORESET 0 时分复用，并且 SSB 在时域上有多个发送时刻，因此CORESET 0 和SSB之间的时域对应关系表达相对复杂，在[TS 38.213] 中定义：对于复用 pattern 1，终端监听 $n_0$ 开始的连续2个时隙。</p><script type="math/tex;mode=display">n_0=(O\cdot 2^{\mu}+\lfloor i\cdot M \rfloor)mod N_{slot}^{frame,\mu}\quad \mu\in \{0,1,2,3\}</script><p>CORESET 0 开始帧号，SFN满足</p><script type="math/tex;mode=display">当\quad \lfloor(O\cdot 2^{\mu}+\lfloor i\cdot M \rfloor)/N_{slot}^{frame,\mu}\rfloor mod 2 = 0 \quad  时\quad SFN_c mod2=0\\当\quad \lfloor(O\cdot 2^{\mu}+\lfloor i\cdot M \rfloor)/N_{slot}^{frame,\mu}\rfloor mod 2 = 1 \quad  时\quad SFN_c mod2=1</script><p>其中：<br><em>i</em> 为 SSB的 index，<em>O</em>，<em>M</em>，在规范中13-11 (FR 1) 到 13-12 (FR2) 表格定义。</p><ul><li>$O\cdot 2^{\mu}$，可以理解为 <em>O</em> ms (绝对时间)，当 $i=0$ 时 (第一个SSB) 所对应的CORESET 0 搜索空间，相对于偶数帧的开始时刻偏移了 <em>O</em> ms<ul><li>FR1时，<em>O</em> 取值为 0，2，5，7</li><li>FR2时，<em>O</em> 取值为 0，2.5，5，7.5</li></ul></li><li><em>N</em>，[TS 38.213 Table 13-11~12] 表中的 Number of search space sets per slot，每个时隙中的搜索空间个数</li><li><em>M</em>，[TS 38.213 Table 13-11~12] 表中的 <em>M</em> ，可以理解为前后两个SSB对应的CORESET 0 搜索空间的间隔，单位为 slot</li></ul><p>以下对应的三种情况 (图片摘自春天工作室)</p><ul><li>情形一</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p14-时域1.png" alt></p><ul><li>情形二</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p15-时域2.png" alt></p><ul><li>情形三</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-213%E5%8D%8F%E8%AE%AE%E8%A1%A5%E5%85%85/p16-时域3.png" alt></p><h2 id="3-RMSI-的获取"><a href="#3-RMSI-的获取" class="headerlink" title="3. RMSI 的获取"></a>3. RMSI 的获取</h2><p>通过以下步骤，UE获得了RMSI 的CORESET０的时频域资源，可以在CORESET 0 物理资源对应的Type 0 Common Search Space 使用 SI-RNTI 盲检RMSI的调度信息 (PDCCH信道上发送 SI-RNTI 加扰的DCI 1_0)。</p><h2 id="4-initial-DL-BWP"><a href="#4-initial-DL-BWP" class="headerlink" title="4. initial DL BWP"></a>4. initial DL BWP</h2><p>和LTE不同，NR中由于信道带宽可能会非常大，而UE没有必要支持全部信道带宽范围。因此，NR中频域上引入了 Bandwidth part (BWP) 的概念，UE可以被配置多个DL/UL BWP (BWP 根据UE能力配置，小于等于信道带宽)，UE同时只能工作在一个激活BWP中。NR中，频域资源的分配基于BWP内。</p><p>BWP的配置包括：子载波间隔，频域起始位置，带宽，CP类型;</p><p>UE要根据 CORESET 0 PDCCH 调度 DCI 1_0 得到 RMSI 的PDSCH的频域资源信息，首先要确定初始下行 BWP (Initial DL BWP)，[TS 38.213] 规定：Initial DL BWP 就是 CORESET 0 的频域大小 (子载波间隔，频域位置，连续RB，CP)。</p><h2 id="5-用于报告控制信息的UE过程"><a href="#5-用于报告控制信息的UE过程" class="headerlink" title="5. 用于报告控制信息的UE过程"></a>5. 用于报告控制信息的UE过程</h2><p>对应于协议的第九章 还没有看</p><h2 id="6-用于接收控制信息的UE过程"><a href="#6-用于接收控制信息的UE过程" class="headerlink" title="6. 用于接收控制信息的UE过程"></a>6. 用于接收控制信息的UE过程</h2><p>对应于协议的第十章 还没有看</p><blockquote><p>参考文献<br>公众号：5G菜鸟成长日记，春天工作室<br>网页：<a href="https://mp.weixin.qq.com/s/pYBUorrVeYUedqGJxVi9Xg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/pYBUorrVeYUedqGJxVi9Xg</a><br>博客：<a href="https://blog.csdn.net/milkbusy/article/details/81536306" target="_blank" rel="noopener">https://blog.csdn.net/milkbusy/article/details/81536306</a><br>协议：TS 38.213</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>TS 38.213</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-PUSCH学习</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Mon May 04 2020 17:17:36 GMT+0800 (GMT+08:00) --><h1 id="1-PUSCH信道处理流程"><a href="#1-PUSCH信道处理流程" class="headerlink" title="1 PUSCH信道处理流程"></a>1 PUSCH信道处理流程</h1><h2 id="1-1-TS-38-212对应处理过程"><a href="#1-1-TS-38-212对应处理过程" class="headerlink" title="1.1 TS 38.212对应处理过程"></a>1.1 TS 38.212对应处理过程</h2><h3 id="1-1-1-增加CRC校验"><a href="#1-1-1-增加CRC校验" class="headerlink" title="1.1.1 增加CRC校验"></a>1.1.1 增加CRC校验</h3><p>PUSCH数据$a_0,a_1,…,a_{A-1}$，首先判断传输块长度 A 的大小，来确定选择的 CRC方法：<br>$if$ $A &gt; 3824$<br>​ $g_{CRC24(D)}$ \\\ L = 24<br>$else$<br>​ $g_{CRC16(D)}$ \\\ L = 16</p><p>随后，$a_0,a_1,…,a_{A-1}$ 通过 $g_{CRC24(D)}$ 或 $g_{CRC16(D)}$ 来生成校验位 $p_0,p_1,…,p_{L-1}$</p><p>最后，将校验位$p_0,p_1,…,p_{L-1}$，附在 $a_0,a_1,…,a_{A-1}$ 后，形成添加CRC的数据，$a_0,…,a_{A-1},p_0,…,p_{L-1}$。即$b_0,b_1,…,b_{B-1}$，其中 $B = A+L$</p><h3 id="1-1-2-LDPC-base-graph-selection"><a href="#1-1-2-LDPC-base-graph-selection" class="headerlink" title="1.1.2 LDPC base graph selection"></a>1.1.2 LDPC base graph selection</h3><p>base graph 的选择有如下的规则：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A ≤ 292 ——————————————————————→ LDPC base graph 2</span><br><span class="line">A ≤ 3824 and R ≤ 0.67 ————————→ LDPC base graph 2</span><br><span class="line">R ≤ 0.25 —————————————————————→ LDPC base graph 2</span><br><span class="line">else  ————————————————————————→ LDPC base graph 1</span><br></pre></td></tr></table></figure><br>即：<br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p1-base graph选择.png" alt><p></p><p>可以近似理解为：<br>低码率/小TBS选择BG2；高码率/大TBS选择BG1。</p><h3 id="1-1-3-Code-block-码块分割和增加CRC"><a href="#1-1-3-Code-block-码块分割和增加CRC" class="headerlink" title="1.1.3 Code block 码块分割和增加CRC"></a>1.1.3 Code block 码块分割和增加CRC</h3><p>NR中LDPC编码，最大码块长度限定为：<br>LDPC base graph 1 $K_{cb} = 8448$ ;<br>LDPC base graph 2 $K_{cb} = 3840$;</p><p>因此TB块(含CRC)要根据LDPC码块长度分为多个码块。<br>待编码bit $b_0,b_1,…,b_{B-1}$</p><ul><li>当 $B\leq K_{cb}$， 码块个数 $C = 1$</li><li>当$B&gt; k_{cb}$，码块个数 $C = \lceil B/(K_{cb}-L)\rceil$，其中 $L = 24$ 为每个码块增加的CRC校验bit位数<br>如下图所示：</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p2-码块分割.png" alt></p><p>以上每个码块内含有的比特数为 $K’ = B’/C$，即$B/C + L$，因为 $B’ = B + C\cdot L$</p><p>简单的说就是每个分组的的码块长度是 K’ 有三种情况：</p><ul><li>如果$B$ ≤ $K_{cb}$，$K’ = B$；</li><li>如果$B$ &gt; $K_{cb}$，除了最后一个可能取整多余出来分组外，$K’ = K_{cb}$;</li><li>就上述最后一个分组，$K’ = B - (C-1)\cdot(K_{cb}-L) + L$;</li></ul><p>码块长度确定后，要根据不同BG，生成编码矩阵，首先要确定编码矩阵的<strong>列数</strong>。</p><ul><li>对于BG1，$K_b = 22$，即基础矩阵的最大系统列数22列</li><li>对于BG2：<br>$if\quad B&gt;640\quad K_b = 10;$<br>$elseif\quad B&gt;560\quad K_b = 9;$<br>$elseif\quad B&gt;192\quad K_b = 8;$<br>$else\quad K_b = 6$</li></ul><p><strong>lifting size $Z_c$ </strong>：满足 $K_b\cdot Z_c \leq K’$，且是表格中的最小值。设，BG1：$K = 22Z_c$；BG2：$K = 10Z_c$。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t3-38.212 5.3.2-1.png" alt></p><p>通过上图 $Z_c$ 所处在的集合，可以确定 Set Index ($i_{LS}$)。</p><h3 id="1-1-4-信道编码"><a href="#1-1-4-信道编码" class="headerlink" title="1.1.4 信道编码"></a>1.1.4 信道编码</h3><p>编码前，$c_0,c_1,c_2,…,c_{K-1}$，K由上文给出。<br>LDPC编码后，$d_0,d_1,d_2,…,d_{N-1}$，BG1：$N = 66Z_c$；BG2：$N = 50Z_c$。<br><strong>基矩阵</strong>：</p><ul><li>对于BG1：$H_{BG}$ 为 46$\times$68 的矩阵</li><li>对于BG2：$H_{BG}$ 为 42$\times$52 的矩阵</li></ul><p>$H_{BG}$ 中的元素通过 Set Index ($i_{LS}$) 查表获得：</p><blockquote><p>BG1：[TS 38.212 Table 5.3.2-2]<br>BG2：[TS 38.212 Table 5.3.2-3]</p></blockquote><p><strong>注</strong>：通过查表中的前两列可知 $H_{BG}$中对应的行列数元素值为1，其中没有的行列数对应的值为0，全部设置为0。表中 $V_{i,j}$ 则代表其奇偶校验矩阵对应的元素数值。</p><p>再利用Set Index ($i_{LS}$) 确定$V_{i,j}$后，根据$P_{i,j} = mod(V_{i,j},Z_c)$，获得编码矩阵的循环移位值，根据 $H_{BG}$ 生成编码校验矩阵 <strong>H</strong>，生成方式再协议中的描述如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p3-编码矩阵生成.png" alt></p><p>简单来说就是将$H_{BG}$中的每个元素用大小为 $Z_c\times Z_c$ 的矩阵代替。</p><ul><li>如果元素值为0，则用大小为 $Z_c\times Z_c$ 的零矩阵代替。</li><li>如果元素值为1，则用大小为 $Z_c\times Z_c$ 的单位矩阵经过循环移位后的矩阵 $I(P_{i,j})$ 来替换。其中循环移位值由之前的$P_{i,j} = mod(V_{i,j},Z_c)$ 给出。</li></ul><p>总结，若：<br>待编码的信息比特，<strong>c</strong> $=[ c_0,c_1,c_2,…,c_{K-1}]^T$<br>其校验比特， <strong>w</strong> $=[w_0,w_1,…,w_{N+2Z_c-K-1}]^T$，可以得到 $H\times \left[ \begin{matrix} c\\w \end{matrix}\right]=0$</p><p><strong>疑问</strong>：用来生成<strong>[<em>c|W</em>]</strong>的生成矩阵到底是什么? 按理来说使用信息比特与生成矩阵相乘，产生信息比特和校验比特 <strong>[<em>c|W</em>]</strong>，这个生成矩阵到底是上面的那个<strong>$H_{BG}$</strong>又不是啊，<strong><em>H</em></strong>又是校验矩阵。</p><h3 id="1-1-5-速率匹配"><a href="#1-1-5-速率匹配" class="headerlink" title="1.1.5 速率匹配"></a>1.1.5 速率匹配</h3><p>完成LDPC编码后，得到 $d_0,d_1,d_2,…,d_{N-1}$。需要对其进行 Rate matching 速率适配，包括</p><ul><li>Bit selection</li><li>Bit interleaving</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p4-速率匹配.png" alt></p><h3 id="1-1-6-码块串联"><a href="#1-1-6-码块串联" class="headerlink" title="1.1.6 码块串联"></a>1.1.6 码块串联</h3><p>将速率匹配完成后的数据码块按序重组。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p5-码块重组.png" alt></p><h2 id="1-2-TS-38-211对应处理过程"><a href="#1-2-TS-38-211对应处理过程" class="headerlink" title="1.2 TS 38.211对应处理过程"></a>1.2 TS 38.211对应处理过程</h2><h3 id="1-2-1-加扰"><a href="#1-2-1-加扰" class="headerlink" title="1.2.1 加扰"></a>1.2.1 加扰</h3><p>对于单码字传输时，$q = 0$。[TS 38.211 7.3.1.1]，每一个码字对应的原始数据 $b^{(q)}(0),…,b^{(q)}(M_{bit}^{(q)}-1)$ ,经过加扰处理生成加扰后的数据为 $\widetilde b^{(q)}(0),…,\widetilde b^{(q)}(M_{bit}^{(q)}-1)$ 。加扰处理如下伪代码所示：</p><p>$while$ $i$ &lt; $M_{bit}^{(q)}$</p><p>​ $if$ $b^{(q)}(i) = x$ // UCI placeholder bits</p><p>​ $\widetilde b^{(q)}(i) = 1$</p><p>$else$<br>$if$ $b^{(q)}(i)=y$ // UCI placeholder bits</p><p>​ $\widetilde b^{(q)}(i) = \widetilde b^{(q)}(i-1)$</p><p>​ $else$</p><p>​ $\widetilde b^{(q)}(i) = (b^{(q)}(i) + c^{(q)}(i))mod2$</p><p>​ $end$ $if$</p><p>​ $end$ $if$</p><p>​ $i=i+1$</p><p>$end$ $ while$</p><p>其中加扰序列$c^{(q)}(i)$是一个伪随机序列，由[TS 38.211 5.2.1]给出，加扰序列的初始为：</p><script type="math/tex;mode=display">C_{init} = n_{RNTI}\cdot2^{15}+n_{ID}</script><p>其中</p><ul><li>$n_{RNTI}$ = C-RNTI or CS-RNTI , 并且在公共搜索空间中不使用DCI forrmat 0_0调度传输</li><li>$n_{ID}\in \{0,1,…,1023\}$ , 其值等于<em>dataScramblingIdentityPUSCH</em>(如果配置)，否则 $n_{ID} = N_{ID}^{cell}$</li></ul><h3 id="1-2-2-调制"><a href="#1-2-2-调制" class="headerlink" title="1.2.2 调制"></a>1.2.2 调制</h3><p>每一个码字加扰后的比特块 $\widetilde b^{(q)}(0),…,\widetilde b^{(q)}(M_{bit}^{(q)}-1)$ 采用下表中的一种调制方式进行调制，得到一个复值调制符号块$d^{(q)}(0),…,d^{(q)}(M_{symb}^{(q)}-1)$。[TS 38.211 6.3.1.2-1]</p><table><tr><th colspan="2"><center>Transform precoding disabled</center></th><th colspan="2"><center>Transform precoding enabled</center></th></tr><tr><td><center>Modulation scheme</center></td><td><center>Modulation order</center></td><td><center>Modulation scheme</center></td><td><center>Modulation order</center></td></tr><tr><td><center></center></td><td><center></center></td><td><center>π/2-BPSK</center></td><td><center>1</center></td></tr><tr><td><center>QPSK</center></td><td><center>2</center></td><td><center>QPSK</center></td><td><center>2</center></td></tr><tr><td><center>16QAM</center></td><td><center>4</center></td><td><center>16QAM</center></td><td><center>4</center></td></tr><tr><td><center>64QAM</center></td><td><center>6</center></td><td><center>64QAM</center></td><td><center>6</center></td></tr><tr><td><center>256QAM</center></td><td><center>8</center></td><td><center>256QAM</center></td><td><center>8</center></td></tr></table><h3 id="1-2-3-层映射"><a href="#1-2-3-层映射" class="headerlink" title="1.2.3 层映射"></a>1.2.3 层映射</h3><p>对于单个码字$q = 0$ , 每一个码字生成的调制信号 $d^{(q)}(0),…,d^{(q)}(M_{symb}^{(q)}-1)$ 根据表[TS 38.211 7.3.1.3-1] 映射到4层$x(i)=[x^0{i} \cdots x^{v-1}(i)]^T$，$i = 0,1,…,M_{symb}^{layer}-1$，具体的矩阵形式如下所示 , $M_{symb}^{layer}$ 表示每层调制符号的数量，其中$v$表示层数。,需要注意的是PUSCH最多映射4层，PDSCH最多8层。</p><script type="math/tex;mode=display">x(i)=[x^0{i} \cdots x^{v-1}(i)]^T\quad i = 0,1,...,M_{symb}^{layer}-1\\=\left[ \begin{matrix} x^{(0)}(0)&x^{(0)}(1)&\cdots&x^{(0)}(M_{sysmb}^{layer}-1)\\x^{(1)}(0)&x^{(1)}(1)&\cdots&x^{(1)}(M_{sysmb}^{layer}-1)\\ \vdots&\vdots&\ddots&\vdots \\x^{(p-1)}(0)&x^{(p-1)}(1)&\cdots&x^{(p-1)}(M_{sysmb}^{layer}-1)\end{matrix} \right]</script><div class="table-container"><table><thead><tr><th style="text-align:center">层数</th><th style="text-align:center">码字数</th><th>码字到层映射<br>$i = 0,1,…,M_{symb}^{layer}-1$</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(i)$ $M_{symb}^{layer} = M_{symb}^{(0)}$</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(2i)$<br>$x^{(1)}(i) = d^{(0)}(2i+1)$ $M_{symb}^{layer} = M_{symb}^{(0)}/2$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(3i)$<br>$x^{(1)}(i) = d^{(0)}(3i+1)$ $M_{symb}^{layer} = M_{symb}^{(0)}/3$<br>$x^{(2)}(i) = d^{(0)}(3i+2)$</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(4i)$<br>$x^{(1)}(i) = d^{(0)}(4i+1)$<br>$x^{(2)}(i) = d^{(0)}(4i+2)$ $M_{symb}^{layer} = M_{symb}^{(0)}/4$<br>$x^{(3)}(i) = d^{(0)}(4i+3)$</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(2i)$<br>$x^{(1)}(i) = d^{(0)}(2i+1)$<br>$x^{(2)}(i) = d^{(1)}(3i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/2 = M_{symb}^{(1)}/3$<br>$x^{(3)}(i) = d^{(1)}(3i+1)$<br>$x^{(4)}(i) = d^{(1)}(3i+2)$</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(3i)$<br>$x^{(1)}(i) = d^{(0)}(3i+1)$<br>$x^{(2)}(i) = d^{(0)}(3i+2)$<br>$x^{(3)}(i) = d^{(1)}(3i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/3 = M_{symb}^{(1)}/3$<br>$x^{(4)}(i) = d^{(1)}(3i+1)$<br>$x^{(5)}(i) = d^{(1)}(3i+2)$</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(3i)$<br>$x^{(1)}(i) = d^{(0)}(3i+1)$<br>$x^{(2)}(i) = d^{(0)}(3i+2)$<br>$x^{(3)}(i) = d^{(1)}(4i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/3 = M_{symb}^{(1)}/4$<br>$x^{(4)}(i) = d^{(1)}(4i+1)$<br>$x^{(5)}(i) = d^{(1)}(4i+2)$<br>$x^{(6)}(i)=d^{(1)}(4i+3)$</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(4i)$<br>$x^{(1)}(i) = d^{(0)}(4i+1)$<br>$x^{(2)}(i) = d^{(0)}(4i+2)$<br>$x^{(3)}(i)=d^{(0)}(4i+3)$<br>$x^{(4)}(i) = d^{(1)}(4i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/4 = M_{symb}^{(1)}/4$<br>$x^{(5)}(i) = d^{(1)}(4i+1)$<br>$x^{(6)}(i) = d^{(1)}(4i+2)$<br>$x^{(7)}(i)=d^{(1)}(4i+3)$</td></tr></tbody></table></div><h3 id="1-2-4-变换预编码"><a href="#1-2-4-变换预编码" class="headerlink" title="1.2.4 变换预编码"></a>1.2.4 变换预编码</h3><p>为了降低PAPR峰均比，上行PUSCH可以支持Transform Precoding , 即采用DFT-s-OFDM的形式，通过RRC层参数和DCI指示。</p><p>仅当<em>PUSCH-Config -&gt; transformprecoder</em> 配置 或者<em>RACH-configCommon -&gt; msg3-transformPrecoding</em> 配置时使用。</p><ul><li>如果变换预编码不可用，对于层$\lambda = 0,1,…,v-1$，有 $y^{(\lambda)}(i) = x^{(\lambda)}(i)$。</li><li>如果变换预编码可用，$v = 1$ , 且复值符号块$x^{(0)}(0),…,x^{(0)}(M_{symb}^{layer}-1)$ 被分为$M_{symb}^{layer}/M_{sc}^{PUSCH}$个集合，每个集合对应于一个OFDM符号。变换预编码根据如下公式进行：<script type="math/tex;mode=display">y^{(0)}(l \cdot M_{sc}^{PUSCH}+k)=\frac{1}{\sqrt{M_{sc}^{PUSCH}}}\sum_{i=0}^{M_{sc}^{PUSCH}-1}\widetilde x^{(0)}(l \cdot M_{sc}^{PUSCH}+i)e^{-j\frac{2\pi ik}{M_{sc}^{PUSCH}}}\\k =0,1,...,M_{sc}^{PUSCH}-1\\l=0,1,...,M_{symb}^{layer}/M_{sc}^{PUSCH}-1</script></li></ul><p>得到复值符号块 $y^{(0)}(0),…,y^{(0)}(M_{symb}^{layer}-1)$ 。$M_{sc}^{PUSCH} = M_{RB}^{PUSCH}\cdot M_{sc}^{RB}$，其中$M_{RB}^{PUSCH}$ 就是RB而言的带宽，并且满足</p><script type="math/tex;mode=display">M_{RB}^{PUSCH} = 2^{\alpha_2}\cdot 3^{\alpha_3}\cdot 5^{\alpha_5}\leq N_{RB}^{UL}</script><p>其中 $\alpha_2,\alpha_3,\alpha_5$ 是非负整数集合。</p><h3 id="1-2-5-预编码"><a href="#1-2-5-预编码" class="headerlink" title="1.2.5 预编码"></a>1.2.5 预编码</h3><p>根据如下公式对向量块$[y^{(0)}(i),…,y^{(v-1)}(i)]^{T},i = 0,1,…,M_{symb}^{layer}-1$ 进行预编码处理：</p><script type="math/tex;mode=display">\left[\begin{matrix} z^{(0)}(i)\\ \vdots\\ z^{(p-1)}(i) \end{matrix} \right]=W\left[\begin{matrix} y^{(0)}(i)\\ \vdots \\ y^{(p-1)}(i) \end{matrix} \right]</script><p>其中 $i = 0,1,…,M_{symb}^{ap} -1, M_{symb}^{ap} =M_{symb}^{layer}$ 。</p><p>RRC 参数如下：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txConfig				ENUMERATED &#123;codebook,nonCodebook&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于基于非码本的传输，预编码矩阵<strong>W</strong> 为单位矩阵。<br>对于基于码本的传输，预编码矩阵<strong>W</strong>：</p><ul><li><p>When number of layer = 1, number of antenna port = 1，<strong>W</strong> = 1。</p></li><li><p>When number of layer $\geq$ 1 and number of antenna port $\geq$ 2 ，</p><p>根据DCI 0-1中的 “Precoding information and number of layers” 确定预编码矩阵<strong>W</strong>(参考如下表格)：</p><blockquote><p>[TS 38.211 Table 6.3.1.5-1]<br>[TS 38.211 Table 6.3.1.5-2]<br>[TS 38.211 Table 6.3.1.5-3]<br>[TS 38.211 Table 6.3.1.5-4]<br>[TS 38.211 Table 6.3.1.5-5]<br>[TS 38.211 Table 6.3.1.5-6]<br>[TS 38.211 Table 6.3.1.5-7]</p></blockquote></li></ul><p>按照层数，天线端口数，是否配置变换预编码，三者的参数，选取预编码矩阵，总结成如下表格：</p><div class="table-container"><table><thead><tr><th>Number of Layers</th><th>Number of Antenna</th><th>Transform Precoding</th><th>Precoding Matrix</th></tr></thead><tbody><tr><td>1</td><td>2</td><td></td><td>211 Table 6.3.1.5-1</td></tr><tr><td>1</td><td>4</td><td>enabled</td><td>211 Table 6.3.1.5-2</td></tr><tr><td>1</td><td>4</td><td>disabled</td><td>211 Table 6.3.1.5-3</td></tr><tr><td>2</td><td>2</td><td>disabled</td><td>211 Table 6.3.1.5-4</td></tr><tr><td>2</td><td>4</td><td>disabled</td><td>211 Table 6.3.1.5-5</td></tr><tr><td>3</td><td>4</td><td>disabled</td><td>211 Table 6.3.1.5-6</td></tr><tr><td>4</td><td>4</td><td>disabled</td><td>211 Table 6.3.1.5-7</td></tr></tbody></table></div><h3 id="1-2-6-映射到VRB"><a href="#1-2-6-映射到VRB" class="headerlink" title="1.2.6 映射到VRB"></a>1.2.6 映射到VRB</h3><p>对于用于传输PUSCH的每个天线端口，复值符号块 $z^{(p)}(0),…,z^{(p)}(M_{symb}^{ap}-1)$ 应与幅度缩放因子$\beta_{PUSCH}$相乘，以满足[5,TS 38.213]中规定的发射功率。<br>对于每个天线步骤，都会创建一个虚拟资源网格。在资源网格内，从RE的最低频率到较高频率的来自来填充PUSCH数据到每个RE中。一旦它以分配的PUSCH资源块的最高频率到达RE，则移至下一个OFDM符号的最低频率的RE。</p><h3 id="1-2-7-映射到PRB"><a href="#1-2-7-映射到PRB" class="headerlink" title="1.2.7 映射到PRB"></a>1.2.7 映射到PRB</h3><p>按照之前的协议：有交织和非交织两种模式，和PDSCH一样。参考PDSCH映射规则。<br>按照现在<strong>最新版本</strong>的协议，只有<strong>非交织</strong>的模式。如下所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p6-VRB映射1.png" alt><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p7-VRB映射2.png" alt></p><h1 id="2-PUSCH-DMRS"><a href="#2-PUSCH-DMRS" class="headerlink" title="2 PUSCH DMRS"></a>2 PUSCH DMRS</h1><h2 id="2-1-序列生成"><a href="#2-1-序列生成" class="headerlink" title="2.1 序列生成"></a>2.1 序列生成</h2><p>有两种条件下DMRS序列生成方式，Transform Precoding disabled，Transform Precoding enabled。</p><h3 id="2-1-1-Transform-Precoding-disabled"><a href="#2-1-1-Transform-Precoding-disabled" class="headerlink" title="2.1.1 Transform Precoding disabled"></a>2.1.1 Transform Precoding disabled</h3><p>这种情况的生成方式是与PDSCH DMRS一样的：<br>PUSCH DMRS序列有如下公式生成：</p><script type="math/tex;mode=display">r(n) = \frac{1}{\sqrt{2}}(1-2\cdot c(2n))+j\frac{1}{\sqrt{2}}(1-2\cdot c(2n+1))</script><p>加扰序列采用31阶Gold序列生成，加扰序列的初始序列$c_{init}$如下式所示:</p><script type="math/tex;mode=display">c_{init} = (2^{17}(N_{symb}^{slot}n_{s,f}^{\mu}+l+1)(2N_{ID}^{\overline n_{SCID}^{\overline \lambda}}+1)+2^{17}\lfloor\frac{\overline \lambda}{2} \rfloor+2N_{ID}^{\overline n_{SCID}^{\overline \lambda}}+\overline n_{SCID}^{\overline \lambda})mod2^{31}</script><p>其中： $l$ 为时隙中的符号索引， $n_{s,f}$ 为时隙索引， $N_{symb}^{slot}$ 为一个时隙内的符号数量。</p><ul><li>$N_{ID}^0,N_{ID}^1\in\{0,1,…,65535\}$：分别由高层参数 <em>scramblingID0</em> 和 <em>scramblingID1</em> 给出 （如果配置的话，且PUSCH由 DCI format 0_1,0_2调度，或者是具有配置的授权的PUSCH传输）；</li><li>$N_{ID}^0\in\{0,1,…,65535\}$：由 <em>DMRS-UplinkConfig -&gt; scramblingID0</em> 给出（如果配置的话，且PUSCH由被 C-RNTI，MSC-C-RNTI，或者 CS－RNTI 加扰的 DCI format 0_0 调度）；</li><li>$N_{ID}^0,N_{ID}^1\in\{0,1,…,65535\}$：对于每个msgA PUSCH 配置，分别由高层参数 <em>msgA-DMRS-Configuration</em> -&gt; <em>msgA-scramblingID0</em> , <em>msgA-scramblingID1</em>给出（如果配置的话，且PUSCH传输是由Type-2随机接入过程触发的）；</li><li>$N_{ID}^{\overline n_{SCID}^{\overline \lambda}}=N_{ID}^{cell}$ otherwise；</li><li>$\overline n_{SCID}^{\overline \lambda}$ and $\overline \lambda$ 由高层参数 <em>DMRS-UplinkConfig -&gt; dmrs-Uplink-r16</em>给出，其中 $\lambda$ 是CDM group：<script type="math/tex;mode=display">N_{ID}^{\overline n_{SCID}^{\overline \lambda}}=\begin{cases}n_{SCID}\quad\quad\quad \lambda=0\quad or\quad\lambda = 2\\1-n_{SCID}\quad\quad \lambda=1 \end{cases}\\\overline \lambda = \lambda</script>否则<script type="math/tex;mode=display">N_{ID}^{\overline n_{SCID}^{\overline \lambda}}=n_{SCID}\\ \overline \lambda = 0</script>其中 $n_{SCID}\in \{0,1\}$：</li><li>如果使用DCI format 0_1 或者 0_2，则在与PUSCH传输相关的DCI中使用 DM-RS初始化字段（如果存在）</li><li>由高层参数 <em>dmrs-SeqInitialization</em> 给出（如果存在，且是具有配置的授权的Type 1 PUSCH传输，或者PUSCH传输是由Type-2随机接入过程触发的）；</li><li>否则 $n_{SCID} = 0$；</li></ul><h3 id="2-1-2-Transform-Precoding-enabled"><a href="#2-1-2-Transform-Precoding-enabled" class="headerlink" title="2.1.2 Transform Precoding enabled"></a>2.1.2 Transform Precoding enabled</h3><p>生成公式如下：</p><script type="math/tex;mode=display">r(n)=r_{u,v}^{(\alpha,\delta)}(n)\\n=0,1,...,M_{sc}^{PUSCH}/2^{\delta}-1</script><p>其中 $r_{u,v}^{(\alpha,\delta)}(n)$ 中 $\delta = 1,\alpha =0$</p><ul><li>如果高层参数 <em>dmrsUplinkTransformPrecoding-r16</em> 已配置，PUSCH使用 $\pi/3-BPSK$ 调制 ，且此次PUSCH传输不是 msg3，并且这次传输在CCS中并没有使用 DCI format 0_0 调度，$r_{u,v}^{(\alpha,\delta)}(n)$ 为低均峰比序列，见[TS 38.211 5.2.2~3]。</li></ul><p>序列组 $u = (f_{gh}+n_{ID}^{RS})mod30$，其中$n_{ID}^{RS}$由下面给出：</p><ul><li><p>$n_{ID}^{RS}=n_{ID}^{PUSCH}$，如果 $n_{ID}^{PUSCH}$ 由高层参数<em>DMRS-UplinkConfig</em> -&gt; <em>nPUSCH-Identity</em> 配置，而高层参数<em>dmrsUplinkTransformPrecoding-r16</em> 为配置，而且PUSCH既不是由RAR UL调度，也不是由利用TC-RNTI加扰的DCI format 0_0 调度的；</p></li><li><p>$n_{ID}^{RS}=n_{ID}^{PUSCH}$，如果 $n_{ID}^{PUSCH}$ 由高层参数<em>dmrs-UplinkTransformPrecoding-r16</em>配置，PUSCH 使用 $\pi/2-BPSK$ 调制，且此次PUSCH传输不是 msg3，并且这次传输在 CCS中并没有使用 DCI format 0_0 调度。</p></li><li>$n_{ID}^{RS} = N_{ID}^{cell}$ otherwise；</li></ul><p>其中 $f_{gh}$ 和 序列数 $v$ 由下面给出：</p><ul><li>如果既没有组跳变也没有序列跳变<script type="math/tex;mode=display">f_{gh}=0\\v-0</script></li><li>如果配置了组跳变，未配置序列跳变<script type="math/tex;mode=display">f_{gh} = (\sum_{m = 0}^{7}2^mc(8(N_{symb}^{slot}n_{s,f}^{\mu}+l)+m))mod30\\v=0\\c_{init}=\lfloor n_{ID}^{RS}/30 \rfloor</script></li><li>如果序列跳变配置，组跳变未配置<script type="math/tex;mode=display">f_{gs} = 0\\v=\begin{cases}v = c(N_{symb}^{slot}n_{s,f}^{\mu}+l) \quad if\quad M_{ZC}\geq 6N_{sc}^{RB}\\0\quad\quad\quad\quad\quad\quad\quad\quad\quad otherwise \end{cases}\\c_{init}=n_{ID}^{RS}</script></li></ul><p>跳变模式(hopping mode)由高层参数控制：</p><ul><li>如果PUSCH传输是由RAR UL 调度的，或者是由由TC-RNTI 加扰的 DCI format 0_0 调度的，此时序列跳变禁用，组跳变禁用启用于否由高层参数 <em>groupHoppingEnabledTransformPrecoding</em> 决定；</li><li>其他传输时，序列跳变和组跳变的禁用启用与否分别由高层参数 <em>sequenceHopping , sequenceGroupHopping</em> 决定（如果这些参数配置的话，否则将采用和Msg3一样的hopping mode）。</li></ul><p>UE 是并不期待同时处理序列跳变和组跳变的。</p><h2 id="2-2-资源映射"><a href="#2-2-资源映射" class="headerlink" title="2.2 资源映射"></a>2.2 资源映射</h2><p>序列 $r(m)$ 被 映射中间值为 $\widetilde \alpha_{k,l}^{(\widetilde p_j,\mu)}$ ，根据如下：</p><ul><li>①if transform precoding is not enable,<script type="math/tex;mode=display">\widetilde \alpha_{k,l}^{(\widetilde p_j,\mu)}=w_f(k')w_t(l')r(2n+k')\\k = \begin{cases}4n+2k'+\Delta \quad \quad Configuration\quad type\quad1\\6n+k'+\Delta\quad \quad Configuration\quad type\quad 2 \end{cases}\\k'=0,1\\l=\overline{l}+l'\\n = 0,1,...\\j=0,1,...,v-1</script></li><li>②if transform precoding is enable<script type="math/tex;mode=display">\widetilde \alpha_{k,l}^{(\widetilde p_j,\mu)}=w_f(k')w_t(l')r(2n+k')\\k=4n+2k'+\Delta\\k'=0,1\\l=\overline l+l'\\n=0,1,...</script>中间值 $\widetilde \alpha_{k,l}^{(\widetilde p_j,\mu)}$ 会经过预编码矩阵 <strong><em>W</em></strong> 和缩放因子 $\beta_{PUSCH}^{DMRS}$ , 最终映射为 $\alpha_{k,l}^{( p_j,\mu)}$，如下所示：<script type="math/tex;mode=display">\left[ \begin{matrix}\alpha_{k,l}^{( p_0,\mu)}\\ \vdots\\\alpha_{k,l}^{( p_{\rho-1},\mu)}  \end{matrix}\right]=\beta_{PUSCH}^{DMRS}W\left[ \begin{matrix}\widetilde \alpha_{k,l}^{( \widetilde p_0,\mu)}\\ \vdots\\ \widetilde \alpha_{k,l}^{(\widetilde p_{\rho-1},\mu)} \end{matrix} \right]</script></li></ul><h3 id="2-2-1-频域索引"><a href="#2-2-1-频域索引" class="headerlink" title="2.2.1 频域索引"></a>2.2.1 频域索引</h3><p>由以上可知</p><ul><li>① 情形时，DMRS的映射情况和PUSCH DMRS 一致</li><li>② 情形时，其频域映射规则只有Configuration Type 1</li></ul><p>需要注意的是，对于两种情况的参考点</p><ul><li>①情形时，其参考点是PUSCH RB#0</li><li>②情形时，其参考点是CRB#0</li></ul><h3 id="2-2-2-时域索引"><a href="#2-2-2-时域索引" class="headerlink" title="2.2.2 时域索引"></a>2.2.2 时域索引</h3><p>DMRS的符号位置取决于PDSCH的mapping type，分为mapping type A 和 mapping type B，如下表所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t2-38.214 6.1.2.1-1.png" alt></p><p>PUSCH 与 PDSCH 的差别除了初始符号位置和符号长度的些许区别外，还在于PUSCH 还会配置 <em>frequency intra-slot hopping</em> 方式，是否hopping 的两种方式下DMRS符号会有些差异。所以DMRS也会略有不同。<br>但是PUSCH和PDSC和的DMRS类似，PUSCH DMRS也支持：</p><ul><li><em>Front-loaded DM-RS</em>：支持单前置，双前置</li><li><em>Additional DM-RS</em>：支持单符号和双符号</li></ul><p>两种hopping下的DMRS：</p><ul><li>对于不跳频：其时域映射和PDSCH DMRS 机制一样，参考表[TS 38.211 6.4.1.1.3-3~4]</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t9-211 6.4.1.1.3-3.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t12-211.png" alt><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t10-211 6.4.1.1.3-4.png" alt></p><ul><li>对于跳频：其时域映射,参考表[TS 38.211 6.4.1.1.3-6],注意此时<strong>仅支持</strong>单前置+additional DMRS。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t13-211 6.4.1.1.3-6.png" alt></p><h2 id="2-3-天线端口问题"><a href="#2-3-天线端口问题" class="headerlink" title="2.3 天线端口问题"></a>2.3 天线端口问题</h2><p>PUSCH DMRS Type 1 和 Type 2 多天线端口CDM group 定义和PDSCH DMRS相同，仅仅是天线端口的编号差异。参考表格[TS 38.211 6.1.1.3-1,2,5]如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t7-211 6.4.1.1.3-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t8-211 6.4.1.1.3-2.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t14-211 6.4.1.1.3-5.png" alt></p><ul><li>type 1，single symbol情况下，最多支持4个端口，端口0，1和2，3分别在不同的CDM group，每个CDM group内，比如端口0和1，又通过频域的OCC来实现正交，从而实现4个端口的正交。</li><li>type 1，double symbol情况下，最多支持8个端口，除了频域OCC外，还可以时域OCC来实现正交，所以可以支持更多的端口。</li><li>type 2，single symbol情况下，最多支持6个端口，共三个CDM group，每个group内又通过频域OCC实现正交。</li><li>type 2，double symbol情况下，最多支持12个端口，与类型1双符号情况同理，除了频域OCC外，还可以时域OCC，从而支持更多的端口。</li></ul><h1 id="3-PUSCH-PTRS"><a href="#3-PUSCH-PTRS" class="headerlink" title="3 PUSCH PTRS"></a>3 PUSCH PTRS</h1><h2 id="3-1-序列生成"><a href="#3-1-序列生成" class="headerlink" title="3.1 序列生成"></a>3.1 序列生成</h2><p>有两种条件下PTRS序列生成方式，Transform Precoding disabled，Transform Precoding enabled。</p><h3 id="3-1-1-Transform-Precoding-disabled"><a href="#3-1-1-Transform-Precoding-disabled" class="headerlink" title="3.1.1 Transform Precoding disabled"></a>3.1.1 Transform Precoding disabled</h3><p>如果未使用变换预编码，层j上子载波k上的PTRS由下式给出：</p><script type="math/tex;mode=display">r^{(\widetilde p_j)}(m) = \begin{cases}r(m)\quad\quad if\quad j=j'||j =  j''\\0\quad\quad\quad\quad otherwise \end{cases}</script><ul><li>序列$r(m)$与对应的PUSCH的DMRS相同</li><li>不论是否跳频，PTRS的时域位置都在所在子载波的第一个DMRS符号上。</li><li><h3 id="3-1-2-Transform-Precoding-enabled"><a href="#3-1-2-Transform-Precoding-enabled" class="headerlink" title="3.1.2 Transform Precoding enabled"></a>3.1.2 Transform Precoding enabled</h3>如果未使用变换预编码，PTRS再DFT之前插入，此时PTRS映射位置m取决于PTRS group数量和每个group内sample的数量以及PUSCH总共所占的子载波的数量。序列生成公式如下所示：<script type="math/tex;mode=display">r_{m}(m')=w(k')\frac{e^{j\frac{\pi}{2}(mmod2)}}{\sqrt{2}}[(1-2c(m'))+j(1-2c(m'))]\\m'=N_{samp}^{group}s'+k'\\s'=0,1,...N_{group}^{PT-RS}-1\\k' = 0,1,N_{samp}^{group}-1\\c_{init}=(2^{17}(N_{symb}^{slot}n_{s,f}^{\mu}+l+1)(2N_{ID}+1)+2N_{ID})mod2^{31}</script>$w(i)$ 由下表给出：</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t4-211 6.4.1.2.1.2-1.png" alt></p><h2 id="3-2-资源映射"><a href="#3-2-资源映射" class="headerlink" title="3.2 资源映射"></a>3.2 资源映射</h2><p>同样对应着有两种条件下PTRS序列映射方式，Transform Precoding disabled，Transform Precoding enabled。</p><h3 id="3-2-1-Transform-Precoding-disabled"><a href="#3-2-1-Transform-Precoding-disabled" class="headerlink" title="3.2.1 Transform Precoding disabled"></a>3.2.1 Transform Precoding disabled</h3><p>UE只在高层信令指示PTRS传输下才传输，且只在PUSCH内传输PTRS，映射到RE的公式如下</p><script type="math/tex;mode=display">\left[ \begin{matrix}a_{k.l}^{(p_0,\mu)}\\ \vdots\\ a_{k.l}^{(p_{\rho-1},\mu)} \end{matrix} \right]=\beta_{PT-RS}W\left[ \begin{matrix}r^{(\widetilde p_0)}(2n+k')\\ \vdots\\ r^{(\widetilde p_v-1{})}(2n+k') \end{matrix} \right]\\k=\begin{cases}4n+2k'+\Delta\quad\quad configuration\quad type1\\6n+k'+\Delta\quad\quad\quad configuration\quad type2 \end{cases}</script><p>其中：</p><ul><li>$l$ 是PUSCH所占OFDM符号数；</li><li>RE未被DMRS占用；</li><li>$k’$ and $\Delta$ 对应 $\widetilde p_0,…,\widetilde p_{v-1}$</li><li>W是预编码矩阵</li><li>$\beta_{PT-RS}$ 是功率因子</li></ul><h4 id="3-2-1-1-时域索引"><a href="#3-2-1-1-时域索引" class="headerlink" title="3.2.1.1 时域索引"></a>3.2.1.1 时域索引</h4><p>确定时域索引$l$的方式如下：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. set i&#x3D;0 and l_&#123;ref&#125; &#x3D; 0 </span><br><span class="line">2. if any symbol in the interval max(l_&#123;ref&#125;+(i-1)L_&#123;PT-RS&#125; + 1,l_&#123;ref&#125;),…,l_&#123;ref&#125; + iL_&#123;PT-RS&#125; overlaps with a symbol used for DM-RS according to clause 6.4.1.1.3</span><br><span class="line">-	set i&#x3D;1</span><br><span class="line">-	set l_&#123;ref&#125; to the symbol index of the DM-RS symbol in case of a single-symbol DM-RS or to the symbol index of the second DM-RS symbol in case of a double-symbol DM-RS</span><br><span class="line">-	repeat from step 2 as long as l_&#123;ref&#125; +iL_&#123;PT-RS&#125; is inside the PUSCH allocation</span><br><span class="line">3. add l_&#123;ref&#125; + iL_&#123;PT-RS&#125; to the set of time indices for PT-RS</span><br><span class="line">4. increment i by one</span><br><span class="line">5. repeat from step 2 above as long as l_&#123;ref&#125; +iL_&#123;PT-RS&#125; is inside the PUSCH allocation</span><br><span class="line">where L_&#123;PT-RS&#125;∈&#123;1，2，4&#125; is defined in Table 6.2.3.1-1 of [6,TS 38.214].</span><br></pre></td></tr></table></figure><br>以上步骤简单描述如下：<br>$L_{PT-RS}$ 表示PTRS再时域上的密度，也就是每 $L_{PT-RS}$ 个符号有一个PTRS符号。配置方式为：从PUSCH开始调度的位置开始，直到PUSCH结束，每个L符号配置PTRS，如果碰到了DMRS，则重新开始计数。例如，PUSCH在一个slot内调度，即从$i = 0$ 开始，$i = 13$ 结束，$L_{PT-RS} = 4$，DMRS在 $l = 2$ 的符号上，则PTRS时域配置情形如下图所示：<p></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/p8-PTRS1.png" alt></p><h4 id="3-2-1-2-频域索引"><a href="#3-2-1-2-频域索引" class="headerlink" title="3.2.1.2 频域索引"></a>3.2.1.2 频域索引</h4><p>(与PDSCH PTRS 几乎一样)<br>首先，假定分配给PUSCH的RB为从0到$N_{RB}-1$，那么分配给PUSCH的子载波范围就是0-$N_{sc}^{RB}N_{RB}-1$。最终PTRS频域索引$k$，由下面公式得到：</p><script type="math/tex;mode=display">k=k_{ref}^{RE}+(iK_{PT-RS}+k_{ref}^{RB})N_{sc}^{RB}\\k_{ref}^{RB}= \begin{cases}n_{RNTI}modK_{PT-RS} \quad \quad \quad if N_{RB}modK_{PT-RS} = 0 \\n_{RNTI}mod(N_{RB}modK_{PT-RS})\quad \quad otherwise\end{cases}</script><p>$k_{ref}^{RE}$ 由下表获得[TS 38.211-Table 6.4.1.2.2-1]：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t5-211 6.4.1.2.2.1-1.png" alt></p><p>由上可知，$K_{PT-RS}$为相邻 PTRS之间间隔的RB数，即相邻 PTRS之间相差$K_{PT-RS}\cdot N_{sc}^{RB}$ 个子载波，第一个PTRS 子载波定位是 $k_{ref}^{RE}+（0K_{PT-RS}+k_{ref}^{RB}）N_{sc}^{RB}$ 。大概的图样如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/PTRS频域图.png" alt></p><h3 id="3-2-2-Transform-Precoding-enabled"><a href="#3-2-2-Transform-Precoding-enabled" class="headerlink" title="3.2.2 Transform Precoding enabled"></a>3.2.2 Transform Precoding enabled</h3><p>此种情况PTRS是在DFT之前插入，插入的位置m与三个参数有关：PTRS的group数量，每个group内的sample数量和PUSCH所占子载波的数量，不同情况下的具体公式在下表中给出：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUSCH%E5%AD%A6%E4%B9%A0/blog/source/_posts/5G协议/5G-NR-PUSCH学习/t6-211 6.4.1.2.2.2-1.png" alt></p><blockquote><p>参考目录<br>微信公众号：春天工作室，5G菜鸟成长日记<br>网页：<a href="https://mp.weixin.qq.com/s/83D25ABb2YURSbLQ3fOYsg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/83D25ABb2YURSbLQ3fOYsg</a><br>网页：<a href="https://mp.weixin.qq.com/s/SZwf4bJEzWa8RfJDiCC-CA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SZwf4bJEzWa8RfJDiCC-CA</a><br>网页：<a href="http://www.sharetechnote.com/html/5G/5G_PUSCH.html" target="_blank" rel="noopener">http://www.sharetechnote.com/html/5G/5G_PUSCH.html</a><br>网页：<a href="http://www.sharetechnote.com/html/5G/5G_PUSCH_TxMode.html" target="_blank" rel="noopener">http://www.sharetechnote.com/html/5G/5G_PUSCH_TxMode.html</a><br>博客：<a href="https://blog.csdn.net/kakamilan/article/details/104759214/" target="_blank" rel="noopener">https://blog.csdn.net/kakamilan/article/details/104759214/</a> （DMRS）<br>博客：<a href="https://blog.csdn.net/m0_45416816/article/details/105097130" target="_blank" rel="noopener">https://blog.csdn.net/m0_45416816/article/details/105097130</a> （PTRS）</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>PUSCH</tag>
        <tag>DMRS</tag>
        <tag>PTRS</tag>
        <tag>LDPC</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-PUCCH学习</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Mon May 04 2020 17:17:36 GMT+0800 (GMT+08:00) --><h1 id="1-PUCCH-信道"><a href="#1-PUCCH-信道" class="headerlink" title="1 PUCCH 信道"></a>1 PUCCH 信道</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>NR 中PUCCH物理信道是用来发送上行控制信息 Uplink Control information (UCI) (UCI 也可以在PUSCH信道上发送)，UCI的内容包括：信道状态信息CSI，HARQ的ACK/NACK，调度请求Scheduling Request（SR）及组合信息。</p><h2 id="1-2-低PAPR序列"><a href="#1-2-低PAPR序列" class="headerlink" title="1.2 低PAPR序列"></a>1.2 低PAPR序列</h2><p>PUCCH的序列生成及PUCCH DMRS都涉及低PAPR序列。其中除了format 2之外其他的格式都要涉及低PAPR序列。</p><script type="math/tex;mode=display">r_{u,v}^{(\alpha,\delta)}(n) = e^{j \alpha n}\overline r_{u,v}(n) , \quad 0 \leq n \leq M_{ZC}-1\\M_{ZC} = mN_{sc}^{RB}/2^{\delta}\\u \in \{0,1,...,29\}\\(v=0)\quad1/2\leq m/2^\delta \leq 5\\(v=0,1)\quad 6\leq m/2^\delta \quad\quad</script><h3 id="1-2-1-基序列生成"><a href="#1-2-1-基序列生成" class="headerlink" title="1.2.1 基序列生成"></a>1.2.1 基序列生成</h3><p>基序列的生成方式与序列长度有关：<br>$36 \leq M_{ZC}$:</p><script type="math/tex;mode=display">\overline r_{u,v}(n)=x_q(n\cdot modN_{ZC})\\x_q(m) = e^{-j\frac{\pi qm(m+1)}{N_{ZC}}}\\q = \lfloor \overline q +1/2\rfloor+v\cdot(-1)^{\lfloor 2\overline q \rfloor}\\\overline q = N_{ZC}\cdot (u+1)/31\\ max\quad prime\quad number\quad N_{ZC}<M_{ZC}</script><p>$M_{ZC} \in \{6,12,18,24\}$ ：可查表[TS 38.211 Table 5.2.2.2-1~4]，来确定$\varphi(n)$</p><script type="math/tex;mode=display">\overline r_{u,v}(n) = e^{j \varphi(n) \pi /4} , \quad 0 \leq n \leq M_{ZC}-1</script><p>$M_{ZC} = 30$:</p><script type="math/tex;mode=display">\overline r_{u,v}(n) = e^{-j\frac{\pi(u+1)(n+1)(n+2)}{31}},0\leq n\leq M_{ZC}-1</script><h3 id="1-2-2-Group-and-sequence-hopping"><a href="#1-2-2-Group-and-sequence-hopping" class="headerlink" title="1.2.2 Group and sequence hopping"></a>1.2.2 Group and sequence hopping</h3><p>对于PUCCH format 0/1/3/4使用Low PAPR sequence，其中的u和v取决于配置pucch-GroupHopping。<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pucch-GroupHopping			ENUMERATED&#123;neither,enable,disable&#125;,</span><br><span class="line">hoppingId					INTEGER(0...1024)</span><br></pre></td></tr></table></figure><br>其中的 hoppingId 配置的是 $n_{ID}$ , 如果未配置，则 $n_{ID} = N_{ID}^{cell}$<p></p><p>$u=(f_{gh}+f_{ss})mod30$</p><p>当 <em>pucch-GroupHopping = neither</em>：</p><script type="math/tex;mode=display">f_{gh} = 0,f_{ss} = n_{ID} mod 30,v = 0</script><p>当 <em>pucch-GroupHopping = enable</em>：</p><script type="math/tex;mode=display">f_{gh} = (\sum_{m = 0}^{7}2^mc(8(2n_{s,f}^\mu+n_{hop})+m))mod30\\f_{ss} = n_{ID} mod 30\\v = 0\\c_{init} = \lfloor n_{ID}/30 \rfloor</script><p>当 <em>pucch-GroupHopping = disabled</em>：</p><script type="math/tex;mode=display">f_{gh} = 0\\f_{ss} = n_{ID} mod 30\\v = c(2n_{s,f}^{\mu}+n_{hop})\\c_{init}=2^5\lfloor n_{ID}/30 \rfloor+(n_{ID}mod30)</script><p>其中：$n_{s,f}^{\mu}$ 为无线帧时隙号，跳变与否要看序列长度决定，短序列$: v = 0$ ； 长序列$:v=0,1$</p><p>注意：PUCCHGroupHopping意味着基序列组和序列的跳变，而非跳频。</p><h3 id="1-2-3-循环移位-alpha"><a href="#1-2-3-循环移位-alpha" class="headerlink" title="1.2.3 循环移位 $\alpha$"></a>1.2.3 循环移位 $\alpha$</h3><script type="math/tex;mode=display">r_{u,v}^{(\alpha,\delta)}(n)=e^{j \alpha n}\overline r_{u,v}(n)\\\alpha_l=\frac{2\pi}{N_{sc}^{RB}}((m_0+m_{cs}+n_{cs}(n_{s,f}^{\mu},l+l'))modN_{sc}^{RB})\\n_{cs}(n_{s,f}^{\mu},l) = \sum_{m = 0}^{7}2^m c(14 \cdot 8n_{s,f}^{\mu}+8l+m)\\c_{init} = n_{ID}</script><p>其中</p><ul><li>$m_0$ - PUCCH format 0/1：由 <em>initialCyclicShift</em> 给出，PUCCH format 3 : $m_0 = 0$，PUCCH format 4 由38.211 Table 6.4.1.3.3.1-1确定。</li><li>$m_{cs}$ - PUCCH format 0：根据HARQ应答信息确定，PUCCH format 1/3/4 ：$m_{cs} = 0$</li></ul><h3 id="1-2-4-应用"><a href="#1-2-4-应用" class="headerlink" title="1.2.4 应用"></a>1.2.4 应用</h3><p>在PUCCH应用中的大致流程如下，通过参数生成低PAPR序列，其长度取决于PUCCH映射到频域的PRB数，不同时域应用的是不同循环移位的低PAPR序列。</p><h2 id="1-3-PUCCH-format"><a href="#1-3-PUCCH-format" class="headerlink" title="1.3 PUCCH format"></a>1.3 PUCCH format</h2><p>NR中支持5种格式PUCCH，根据PUCCH信道占用时域符号长度分为</p><ul><li>短PUCCH：1-2个符号，PUCCH format 0，PUCCH format 2 能够支持更快捷的HARQ 应答/信道状态反馈，可用于超低时延场景</li><li>长PUCCH：4-14个符号，PUCCH format 1，PUCCH format 3，PUCCH format 4</li></ul><p>PUCCH 信道格式定义</p><div class="table-container"><table><thead><tr><th>PUCCH format</th><th>length in OFDM sysbols<br>$N_{symb}^{PUCCH}$</th><th>Number of bits</th></tr></thead><tbody><tr><td>0</td><td>1 - 2</td><td>$\leq 2$</td></tr><tr><td>1</td><td>4 - 14</td><td>$\leq 2$</td></tr><tr><td>2</td><td>1 - 2</td><td>$&gt; 2$</td></tr><tr><td>3</td><td>4 - 14</td><td>$&gt; 2$</td></tr><tr><td>4</td><td>4 - 14</td><td>$&gt; 2$</td></tr></tbody></table></div><ul><li><p>长格式 PUCCH format 1，3，4 可以支持<strong>时隙内</strong>和<strong>时隙间</strong>跳频</p></li><li><p>短格式 PUCCH format 0，2 可以支持<strong>时隙内</strong>跳频（2个符号时）</p></li></ul><p>当使用时隙内跳频时，第一跳($1^{st}hop$)发送的符号的数位$\lfloor N_{symb}^{PUCCH}/2 \rfloor$，其余的为第二跳。</p><p>在一个时隙内，可以发1 - 2 个PUCCH，至少有一个PUCCH 0 或者PUCCH 2</p><h3 id="1-3-1-format-0"><a href="#1-3-1-format-0" class="headerlink" title="1.3.1 format 0"></a>1.3.1 format 0</h3><h4 id="1-3-1-1-序列生成"><a href="#1-3-1-1-序列生成" class="headerlink" title="1.3.1.1 序列生成"></a>1.3.1.1 序列生成</h4><p>PUCCH 0 用于发送HARQ的ACK/NACK反馈，也可以携带SR信息。<br>PUCCH 0 发送的信息bit为1或者2（对应调度的PDSCH信道的两个Codeword时，也就是对应两个独立的可调制的数据块流）。<br>PUCCH 0 在频域上占用一个RB，在时域上占用1-2个符号。没有DMRS。<br>如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p1-format0.png" alt></p><p>PUCCH 0 高层相关配置参数：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUCCH-format0 ::&#x3D;		SEQUENCE&#123;</span><br><span class="line">	initialCyclicShift		INTEGER(0..11),  &#x2F;&#x2F;初始循环移位</span><br><span class="line">	nrofSymbols				INTEGER(1..2),	&#x2F;&#x2F;符号个数</span><br><span class="line">	startingSymbolIndex		INTEGER(0..13)	 &#x2F;&#x2F;开始符号索引，时隙内任意位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>NR中，使用PUCCH 0 发送ACK/NACK反馈（0-NACK，1-ACK）时，信息bit不需要经过编码→调制→映射到物理资源的过程。<br>通过ACK和NACK信息来选择PUCCH序列循环移位表示, 见[TS 38.213 Table 9.2.3-3(4)]:</p><div class="table-container"><table><thead><tr><th>HARQ-ACK Value</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>Sequence cyclic shift</td><td>$m_{cs}=0$</td><td>$m_{cs}=6$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>HARQ-ACK Value</th><th>{0,0}</th><th>{0,1}</th><th>{1,0}</th><th>{1,1}</th></tr></thead><tbody><tr><td>Sequence cyclic shift</td><td>$m_{cs}=0$</td><td>$m_{cs}=3$</td><td>$m_{cs}=6$</td><td>$m_{cs}=9$</td></tr></tbody></table></div><p>当PUCCH format 0,如果在一个时隙内，同时传输HARQ-ACK与SR请求时候$m_{cs}$也由HARQ-ACK bit的内容确定，但是其取值和上述表格不同，通过$m_{cs}$的取值，网络就能识别PUCCH format 0上是否同时包含了SR请求。</p><div class="table-container"><table><thead><tr><th>HARQ-ACK Value</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>Sequence cyclic shift</td><td>$m_{cs}=3$</td><td>$m_{cs} = 9$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>HARQ-ACK Value</th><th>{0,0}</th><th>{0,1}</th><th>{1,0}</th><th>{1,1}</th></tr></thead><tbody><tr><td>Sequence cyclic shift</td><td>$m_{cs}=1$</td><td>$m_{cs}=4$</td><td>$m_{cs}=7$</td><td>$m_{cs}=10$</td></tr></tbody></table></div><p><em>initialCyclicShift</em> 决定参数 $m_0$。</p><h4 id="1-3-1-2-资源映射"><a href="#1-3-1-2-资源映射" class="headerlink" title="1.3.1.2 资源映射"></a>1.3.1.2 资源映射</h4><script type="math/tex;mode=display">x(l\cdot N_{sc}^{RB}+n)=r_{u,v}^{(\alpha,\delta)(n)}\\n = 0,1,...,N_{sc}^{RB}-1\\l = \begin{cases} 0 \quad\quad for\quad single\quad symbol\quad PUCCH\quad transmision\\0,1 \quad for\quad double\quad symbol\quad PUCCH\quad transmision \end{cases}</script><p>映射顺序先频域 $k$，在时域 $l$。<br>PUCCH 0/1/2/3/4 使用的天线端口都是 $p = 2000$</p><h3 id="1-3-2-format-1"><a href="#1-3-2-format-1" class="headerlink" title="1.3.2 format 1"></a>1.3.2 format 1</h3><h4 id="1-3-2-1-序列生成"><a href="#1-3-2-1-序列生成" class="headerlink" title="1.3.2.1 序列生成"></a>1.3.2.1 序列生成</h4><p>PUCCH 1 属于长PUCCH，在时域占用符号个数4-14个，<u>承载的信息bit最多2个</u>，用于HARQ的ACK/NACK反馈，也可以携带SR（Scheduling Rquest，调度请求机制）信息。PUCCH 1 在频域上占用1个RB。如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p2-format1.png" alt></p><p>PUCCH 1 高层相关配置参数<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUCCH-format 1::&#x3D;			SEQUENCE&#123;</span><br><span class="line">	initialCyclicShift		INTEGER(0..11),	 &#x2F;&#x2F;初始循环移位</span><br><span class="line">	nrofSymbols				INTEGER(4..14),	 &#x2F;&#x2F;符号个数</span><br><span class="line">	startingSymbolIndex		INTEGER(0..10),  &#x2F;&#x2F;开始符号索引</span><br><span class="line">	timeDomainOCC			INTEGER(0..6)    &#x2F;&#x2F;时域OCC配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>PUCCH 1 的ACK/NACK反馈信息 1或者2 bits —1 表示ACK，0表示NACK；分别采用 $\pi / 2$ BPSK (1 bit) 和 QPSK （2 bits）调制，调制后为一个复值符号。<br>PUCCH 1 使用的序列和PUCCH 0 一样 $r_{u,v}^{(\alpha , \delta)}(n) = e^{j \alpha n} \cdot \overline r_{u,v}(n),0 \leq n &lt; M_{ZC}$，同样支持pucch-GroupHopping 配置。<br>调制后的复值符号，映射到序列后 $y(n) = d(0)\cdot r_{u,v}^{(\alpha , \delta)}(n)$。<p></p><h4 id="1-3-2-2-正交序列及资源映射"><a href="#1-3-2-2-正交序列及资源映射" class="headerlink" title="1.3.2.2 正交序列及资源映射"></a>1.3.2.2 正交序列及资源映射</h4><p>和 PUCCH 0不同的是，PUCCH 1支持基于时域正交序列的复用。</p><script type="math/tex;mode=display">z(m'N_{sc}^{RB}N_{SF,0}^{PUCCH,1}+mN_{sc}^{RB}+n)=w_i(m)\cdot y(n)\\n = 0,1,...,N_{sc}^{RB}-1\\m = 0,1...,N_{SF,m'}^{PUCCH,1}-1\\m'=\begin{cases} 0 \quad\quad no\quad intra-slot\quad frequencyhopping\\0,1 \quad intra-slot\quad frequencyhopping\quad enabled \end{cases}</script><p>其中：</p><ul><li>$z(n)$映射到物理资源</li><li>正交序列$w_i(m)$ 取决于[TS 38.211 Table 6.3.2.4.1-1~2]，下标$i$ 由 <em>timeDomainOCC</em> 决定。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/t1-211 6.3.2.4.1-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/t2-211 6.3.2.4.1-2.png" alt></p><h4 id="1-3-2-3-DMRS"><a href="#1-3-2-3-DMRS" class="headerlink" title="1.3.2.3 DMRS"></a>1.3.2.3 DMRS</h4><script type="math/tex;mode=display">z(m'N_{sc}^{RB}N_{SF,0}^{PUCCH,1}+mN_{sc}^{RB}+n)=w_i(m)\cdot r_{u,v}^{(\alpha,\delta)}(n)\\n = 0,1,...,N_{sc}^{RB}-1\\m = 0,1...,N_{SF,m'}^{PUCCH,1}-1\\m'=\begin{cases} 0 \quad\quad no\quad intra-slot\quad frequencyhopping\\0,1 \quad intra-slot\quad frequencyhopping\quad enabled \end{cases}</script><p>DMRS生成方式和format 1 基本相同，但有两处差别：</p><ul><li>正交序列后乘的直接是低PAPR序列，而不是复值块d(0)</li><li>$N_{SF,m’}^{PUCCH,1}$ 定义的表格略有不同，DMRS采用的是[TS 38.211 Table 6.4.1.3.1.1-1]</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/t2-211 6.4.1.3.1.1-1.png" alt></p><p>DMRS资源映射：</p><script type="math/tex;mode=display">\alpha_{k,l}^{p,\mu} = \beta_{PUCCH,1}Z(m)\\l=0,2,4...</script><p>由此可知，format 1 DMRS映射在偶数符号位置，从符号0开始，结束位置和配置的PUCCH 1符号个数相关。</p><h4 id="1-3-2-4-应用举例"><a href="#1-3-2-4-应用举例" class="headerlink" title="1.3.2.4 应用举例"></a>1.3.2.4 应用举例</h4><p>参数配置如下：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrofSymbols &#x3D; 8；</span><br><span class="line">no intra-slot frequencyhopping;</span><br><span class="line">intra-slot frequencyhopping enabled;</span><br><span class="line">timeDomainOCC &#x3D; i (具体看表格选取)</span><br></pre></td></tr></table></figure><p></p><ol><li>非时隙内跳频</li></ol><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p3-format1-例子1.png" alt></p><ol><li>时隙内跳频</li></ol><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p4-format1-例子2.png" alt></p><h3 id="1-3-3-format-2"><a href="#1-3-3-format-2" class="headerlink" title="1.3.3 format 2"></a>1.3.3 format 2</h3><p>PUCCH 2 在时域上占用1-2个符号，在频域上可以占1-16个RB。PUCCH 2时域符号少，适合用于低时延场景，支持较大信息量的UCI，其时频域资源如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p5-format2.png" alt></p><p>format 2 高层相关配置参数如下:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUCCH-format 2::&#x3D;			SEQUENCE&#123;</span><br><span class="line">	nrofPRBs				INTEGER(1..16)	 &#x2F;&#x2F;PRB数</span><br><span class="line">	nrofSymbols				INTEGER(1..2),	 &#x2F;&#x2F;符号个数</span><br><span class="line">	startingSymbolIndex		INTEGER(0..13),  &#x2F;&#x2F;开始符号索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="1-3-3-1-数据处理"><a href="#1-3-3-1-数据处理" class="headerlink" title="1.3.3.1 数据处理"></a>1.3.3.1 数据处理</h4><p>PUCCH format 2数据在[TS 38.211]的处理过程，先进行加扰，调制，然后进行时频映射。<br><strong>1. 加扰</strong><br>编码后的bits流： $b(0),…,b(M_{bit}-1)$，$M_{bit}$ 为编码后bits长度<br>加扰公式定义如下：</p><script type="math/tex;mode=display">\widetilde b(i) = (b(i)+c(i))mod2\\c_{init} = n_{RNTI}\cdot 2^{15}+n_{ID}</script><p>其中$n_{ID}\in \{0,1,…,1023\}$</p><ul><li>由 <em>dataScramblingIdentityPUSCH</em> 配置</li><li>否则，$n_{ID}=N_{ID}^{cell}$</li></ul><p>加扰后的输出bits流 ：$\widetilde b(0),…,\widetilde b(M_{bit}-1)$</p><p><strong>2. 调制</strong><br>加扰后的输出bits流：$\widetilde b(0),…,\widetilde b(M_{bit}-1)$，进行QPSK调制。<br>输出复值符号：$d(0),…,d(M_{symb}-1),M_{symb} = M_{bit}/2$</p><p><strong>3. 映射</strong><br>映射到物理资源，按照先频域$k$，在时域$l$ 的顺序，不能使用DMRS资源。参考下文DMRS的映射图示。</p><h4 id="1-3-3-2-DMRS"><a href="#1-3-3-2-DMRS" class="headerlink" title="1.3.3.2 DMRS"></a>1.3.3.2 DMRS</h4><p>PUCCH format 2 DMRS序列使用的不是低PAPR序列，所以PUCCH format 2中的DMRS序列与其他format 中相关的$m_0,m_{cs}$ 参数无关。<br>由如下公式生成序列：</p><script type="math/tex;mode=display">r_l(m)=\frac{1}{\sqrt{2}}(1-2c(2m))+j\frac{1}{\sqrt{2}}(1-2c(2m+1))\\m = 0,1,..\\c_{init}=(2^{17}(N_{symb}^{slot}n_{s,f}^{\mu}+l+1)(2N_{ID}^0+1)+2N_{ID}^0)mod2^{31}</script><p>其中$N_{ID}^0 \in \{0,1,…,65535\}$：</p><ul><li>由<em>scramblingID0 in the DMRS-UplinkConfig</em> 配置</li><li>否则，$N_{ID}^0 = N_{ID}^{cell}$</li></ul><p>DMRS在频域的映射方式是与数据在频域进行复用。</p><script type="math/tex;mode=display">\alpha_{k,l}^{(p,\mu)}=\beta_{PUCCH,2}r(m)\\k = 3m+1</script><p>若1RB，2 OFDM symbol情况，则如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p6-format2-例子1.png" alt></p><h3 id="1-3-4-format-3-4"><a href="#1-3-4-format-3-4" class="headerlink" title="1.3.4 format 3/4"></a>1.3.4 format 3/4</h3><p>PUCCH 3 在时域上占用4-14个符号，在频域上可以占用1-16个RB（2/3/5的倍数）,物理资源位置图略。<br>PUCCH 4 在时域上占用4-14个符号，在频域只占用1个RB，物理资源位置图略。</p><script type="math/tex;mode=display">M_{RB}^{PUCCH,s} = \begin{cases} 2^{\alpha_2}\cdot 3^{\alpha_3}\cdot 5^{\alpha_5}\quad PUCCH\quad format\quad 3\\1\quad\quad\quad\quad\quad\quad PUCCH\quad format\quad4 \end{cases}\\s \in \{3,4\}</script><p>PUCCH 3 高层相关配置参数<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUCCH-format 3::&#x3D;			SEQUENCE&#123;</span><br><span class="line">	nrofPRBs				INTEGER(1..16)	 &#x2F;&#x2F;PRB数</span><br><span class="line">	nrofSymbols				INTEGER(4..14),	 &#x2F;&#x2F;符号个数</span><br><span class="line">	startingSymbolIndex		INTEGER(0..10),  &#x2F;&#x2F;开始符号索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结合上面的公式可知 nrofPRBs $\in \{1,2,3,4,5,6,8,9,10,12,15,16\}$<p></p><p>PUCCH 4 高层相关配置参数<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUCCH-format 4::&#x3D;			SEQUENCE&#123;</span><br><span class="line">	nrofSymbols				INTEGER(4..14),	         &#x2F;&#x2F;符号个数</span><br><span class="line">	occ-Length				ENUMERATED&#123;n2,n4&#125;,       &#x2F;&#x2F;正交码个数</span><br><span class="line">	occ-Index				ENUMERATED&#123;n0,n1,n2,n3&#125;, &#x2F;&#x2F;正交码索引</span><br><span class="line">	startingSymbolIndex		INTEGER(0..10),          &#x2F;&#x2F;开始符号索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="1-3-4-1-数据处理"><a href="#1-3-4-1-数据处理" class="headerlink" title="1.3.4.1 数据处理"></a>1.3.4.1 数据处理</h4><p>PUCCH 3/4 的数据处理部分，主要是[TS 38.211]中的处理过程。<br>PUCCH 3/4 UCI经过编码，加扰，调制，分块传播 ，变换预编码，映射。（format 3 没有经过Block-wise spreading 流程，也就是不支持OCC，format 4 支持）</p><p><strong>1. 加扰</strong><br>编码后的bits流： $b(0),…,b(M_{bit}-1)$，$M_{bit}$ 为编码后bits长度<br>加扰公式定义如下：</p><script type="math/tex;mode=display">\widetilde b(i) = (b(i)+c(i))mod2\\c_{init} = n_{RNTI}\cdot 2^{15}+n_{ID}</script><p>其中$n_{ID}\in \{0,1,…,1023\}$</p><ul><li>由 <em>dataScramblingIdentityPUSCH</em> 配置</li><li>否则，$n_{ID}=N_{ID}^{cell}$</li></ul><p>加扰后的输出bits流 ：$\widetilde b(0),…,\widetilde b(M_{bit}-1)$</p><p><strong>2. 调制</strong><br>加扰后的输出bits流：$\widetilde b(0),…,\widetilde b(M_{bit}-1)$，默认QPSK调制，若配置$\pi /2$-BPSK，则使用$\pi /2$-BPSK。<br>输出复值符号：$d(0),…,d(M_{symb}-1)$，对于QPSK： $M_{symb} = M_{bit}/2$，对于$\pi /2$-BPSK：$M_{symb} = M_{bit}$</p><p><strong>3. 分块传播</strong><br>对于format 3 ，不应用Block-wise spreading ：</p><script type="math/tex;mode=display">y(lM_{sc}^{PUCCH,3}+k)=d(lM_{sc}^{PUCCH,3}+k)\\k =0,1,...,M_{sc}^{PUCCH,3}-1\\l=0,1,...,(M_{symb}/M_{sc}^{PUCCH,3})-1\\N_{SF}^{PUCCH,3} = 1</script><p>对于format 4，应根据数据应用 Block-wise spreading ：</p><script type="math/tex;mode=display">y(lM_{sc}^{PUCCH,4}+k)=w_{n}(k)\cdot d(l\frac{M_{sc}^{PUCCH,4}}{N_{SF}^{PUCCH,4}}+kmod\frac{M_{sc}^{PUCCH,4}}{N_{SF}^{PUCCH,4}})\\k =0,1,...,M_{sc}^{PUCCH,4}-1\\l=0,1,...,(N_{SF}^{PUCCH,4}M_{symb}/M_{sc}^{PUCCH,4})-1</script><p>其中：</p><ul><li>$M_{RB}^{PUCCH,4} = 1,N_{SF}^{PUCCH,4} \in \{2,4\}$</li><li>$w_n$ 由[TS 38.211 Table 6.3.2.6.3-1~2]给出</li><li>n 由 <em>occ-Index</em> 给出，当<em>occ-Length</em> = 2时，<em>occ-Index</em>可以配置0，1；当<em>occ-Length</em> = 4时，occ-Index可以配置0，1，2，3。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/t4-211 6.3.2.6.3-1~2.png" alt></p><p><strong>4. 变换预编码</strong><br>因为format 3 在频域可能支持有多个PRB分配，为了降低PAPR，需要进行Transform precoding，即采用DFT-s-OFDM<br>复值符号块：$y(0),…,y(N_{SF}^{PUCCH ,s}M_{symb}-1)$ ，根据如下公式进行预编码：</p><script type="math/tex;mode=display">z(l \cdot M_{sc}^{PUCCH,s}+k)=\frac{1}{\sqrt{M_{sc}^{PUCCH,s}}}\sum_{m=0}^{M_{sc}^{PUCCH,s}-1}y(l \cdot M_{sc}^{PUCCH,s}+m)e^{-j\frac{2\pi mk}{M_{sc}^{PUCCH,s}}}\\k =0,1,...,M_{sc}^{PUCCH,4}-1\\l=0,1,...,(N_{SF}^{PUCCH,s}M_{symb}/M_{sc}^{PUCCH,s})-1</script><p>变换预编码后输出：$z(0),…,z(N_{SF}^{PUCCH,s}M_{sybm}-1)$</p><p><strong>5. 映射</strong><br>变换预编码后的复值符号映射到物理资源，$\alpha_{k,l}^{(p,\mu)}=\beta_{PUCCH,s}r(m)$，按照先频域 $k$，在时域 $l$ 的顺序，不能使用DMRS资源。具体映射图参考下文DMRS映射部分。<br>PUCCH 3，4 都支持时隙内跳频。</p><h4 id="1-3-4-2-DMRS"><a href="#1-3-4-2-DMRS" class="headerlink" title="1.3.4.2 DMRS"></a>1.3.4.2 DMRS</h4><p>PUCCH 4 DMRS使用低PAPR序列 $r_{u,v}^{(\alpha , \delta)}(n) = e^{j \alpha n} \cdot \overline r_{u,v}(n),0 \leq n &lt; M_{ZC}$。<br>PUCCH 3 DMRS 也使用低PAPR序列 $r_{u,v}^{(\alpha , \delta)}(n) = e^{j \alpha n} \cdot \overline r_{u,v}(n),0 \leq n &lt; M_{ZC}$，但与 format 0/1/4 不同的是，format 3 在频域可以配置多个PRB，所以序列长度 $M_{ZC}$ 可变。具体情况参考前文低PAPR序列描述。需要注意的是，对于PUCCH 3：$m_0 = 0,m_{cs} = 0$。对于PUCCH 4，其$m_{cs}=0，m_0$ 取决于[TS 38.311 Table 6.4.1.3.3.1-1]中，如下。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/t5-211 6.4.1.3.3.1-1.png" alt></p><p><strong>1. format 3/4 的DMRS序列</strong></p><script type="math/tex;mode=display">r_l(m) = r_{u,v}^{(\alpha , \delta)}(m)\\m=0,1,...,M_{sc}^{PUCCH,s}-1</script><p><strong>2. 映射到物理资源</strong></p><script type="math/tex;mode=display">\alpha_{k,l}^{(p,\mu)}=\beta_{PUCCH,s}r(m)\\m = 0,1,...,M_{sc}^{PUCCH,s}-1</script><p>$l$ 的位置定义如下：additional DM-RS 由高层参数配置，参考[TS 38.211 Table 6.4.1.3.3.2-1]，如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/t6.211 6.4.1.3.3.2-1.png" alt></p><p>若，format 4，PUCCH length = 14 ；资源映射如下图：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p7-format34.png" alt></p><h3 id="1-4-格式总结"><a href="#1-4-格式总结" class="headerlink" title="1.4 格式总结"></a>1.4 格式总结</h3><p>各种格式的配置情况总结如下图所示：图片摘自 ShareTechnote</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PUCCH%E5%AD%A6%E4%B9%A0/p8-格式总结.png" alt></p><h1 id="2-PUCCH-资源"><a href="#2-PUCCH-资源" class="headerlink" title="2 PUCCH 资源"></a>2 PUCCH 资源</h1><h2 id="2-1-PUCCH-资源确定"><a href="#2-1-PUCCH-资源确定" class="headerlink" title="2.1 PUCCH 资源确定"></a>2.1 PUCCH 资源确定</h2><h2 id="2-2-PUCCH-资源集选择"><a href="#2-2-PUCCH-资源集选择" class="headerlink" title="2.2 PUCCH 资源集选择"></a>2.2 PUCCH 资源集选择</h2><p>还没看完，没来得及总结</p><blockquote><p>参考文献<br>公众号：春天工作室，5G菜鸟成长日记<br>网页：<a href="https://mp.weixin.qq.com/s/83D25ABb2YURSbLQ3fOYsg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/83D25ABb2YURSbLQ3fOYsg</a><br>网页：<a href="http://www.sharetechnote.com/html/5G/5G_PUCCH.html" target="_blank" rel="noopener">http://www.sharetechnote.com/html/5G/5G_PUCCH.html</a><br>博客：<a href="https://blog.csdn.net/bluewhu/article/details/104196665" target="_blank" rel="noopener">https://blog.csdn.net/bluewhu/article/details/104196665</a><br>博客：<a href="https://blog.csdn.net/m0_45416816/article/details/104968797" target="_blank" rel="noopener">https://blog.csdn.net/m0_45416816/article/details/104968797</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>PUCCH</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-PRACH学习</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Mon May 04 2020 17:17:36 GMT+0800 (GMT+08:00) --><h1 id="1-PRACH-信道"><a href="#1-PRACH-信道" class="headerlink" title="1 PRACH 信道"></a>1 PRACH 信道</h1><h2 id="1-1-PRACH-preamble-生成"><a href="#1-1-PRACH-preamble-生成" class="headerlink" title="1.1 PRACH preamble 生成"></a>1.1 PRACH preamble 生成</h2><p>LTE系统中使用Zaddof-Chu (ZC) 序列作为PRACH信道的上行同步序列，因为其具有良好的<strong>自相关</strong>和<strong>互相关性</strong>，<strong>恒幅低峰均比</strong>等特性。</p><p>①<strong>自相关</strong>：对于任意ZC原始序列与其循环移位n位后所得到的序列互不相关；<br>②<strong>互相关</strong>：互相关和部分相关值接近零，便于接收端准确地把所需的信号检测出来；<br>③<strong>恒幅低峰均比</strong>：保证相应带宽内的每个频点经理相同的激励，便于实现想干检测中的无偏估计；<br>在PRACH信道上发送的ZC序列，也被称为PRACH Preamble，前导码。LTE支持两种长度的ZC序列，根据根索引序列，通过循环移位生成多个序列</p><script type="math/tex;mode=display">N_{ZC} = 839\\N_{ZC} = 139</script><p>NR 中的PRACH信道沿用了LTE的ZC序列设计，支持两种长度ZC序列，和LTE一致，也通过循环移位生成多个序列，只是符号名称不同，含义都是相同的。</p><script type="math/tex;mode=display">L_{RA} = 839\\L_{RA} = 139</script><p>ZC 序列定义：$x_u(i) = e^{-j \frac{\pi u(i+1)}{L_{RA}}},i = 0,1,…,L_{RA}-1$</p><p>经过循环移位后，ZC序列集合为：$x_{u,v}(n)=x_u((n+C_v)modL_{RA})$</p><p>具体的生成流程如下图所示:<br><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p1-preamble生成.png" alt></p><p>举例说明，参数如下：<br><em>prach-ConfigurationIndex</em> 2<br><em>zeroCorrelationZoneConfig</em> = 6<br><em>restrictedSetConfig</em> <em>unrestrictedSet</em><br><em>prach-RootSequenceIndex</em> l839 : 20</p><p>首先根据 <em>prach-ConfigurationIndex 2</em> ，查表[TS 38.211 Table 6.3.3.2-2] 可知 Format 0 即long symbol 类型，也就是$L_{RA} = 839$, 之后查表[TS 38.211 Table 6.3.3.1-3]<br>根据 <em>prach-RootSequenceIndex</em> l839 : 20 可知：$u = 2$ , 并通过ZC序列定义公式生成$x_2(n)$序列。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T4-38.211-6.3.3.1-3(4" alt>副本.png)</p><p>由 <em>zeroCorrelationZoneConfig</em> = 6；<em>restrictedSetConfig unrestrictedSet</em>。<br>查表[TS 38.211 Table 6.3.3.1-1]可知$\Delta f_{RA} = 1.25$KHz<br>再查表[TS 38.211 6.3.3.1-5]可知$N_{CS} = 32$。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/Inked38.211-6.3.3.1-5_LI.jpg" alt></p><p>根据公式可知$v = 0,1,…,\lfloor L_{RA}/N_{CS} \rfloor - 1 = 0,1,…,\lfloor 839/32 \rfloor -1 = 0,1,…,25$，所以$C_v = v \cdot N_{CS} = v \cdot 32 = [0,32,64,…,800]$，这样可以获得 $x_2(n)$ 的26种循环移位后的序列，也就是获得了26个preamble 序列。</p><p>因为 26 &lt; 64，所以根索引会递增为 <em>prach-RootSequenceIndex</em> l839 : 21，对应的$u = 837$，操作与上文相同，又可以生成26个preamble序列。<br>因为 52 &lt; 64，所以根索引会递增为 <em>prach-RootSequenceIndex</em> l839 : 22，对应的$u = 1$，操作与上文相同，这次只用生成12个preamble序列即可。</p><p>经过以上步骤，就获得了64个preamble序列，对其做DFT就是其频域表达。</p><h2 id="1-2-PRACH-preamble-格式"><a href="#1-2-PRACH-preamble-格式" class="headerlink" title="1.2 PRACH preamble 格式"></a>1.2 PRACH preamble 格式</h2><p>Preamble总体上分为两大类，long preamble和short preamble，分别对应$L_{RA} = 839,L_{RA} = 139$。其中long preamble分为四种Format,分别为Format 0/1/2/3，short preamble分为九种A1/A2/A3/B1/B2/B3/B4/C0/C2。配置如下表所示:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T1-38.211-6.3.3.1-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T2-38.211-6.3.3.1-2.png" alt></p><p>需要的一些基础参数如下：</p><script type="math/tex;mode=display">T_c = 1/(\Delta f_{max}\cdot N_f) = 1/(480\times 10^3\cdot 4096) = 0.509ns = 0.509\times10^{-6}ms\\T_s = 1/(\Delta f_{ref}\cdot N_{f,ref}) = 1/(15\times 10^3\cdot 2048) = 32.552ns = 32.552\times10^{-6}ms\\K = \frac{T_s}{T_c} = 64</script><p>Preamble结构一般由三部分组成：Cyclic Prefix(CP) + Preamble Sequence (重复) + Guard Period(GP)，其中核心部分preamble sequence可能重复多次，取决于不同的Format。</p><table><tr><td><center></center></td><td><center>PRACH preamble 格式</center></td><td><center>特点</center></td></tr><tr><th rowspan="4"><center>long preamble</center></th><td><center>Format 0</center></td><td><center>时长1ms; 用于普通场景</center></td></tr><tr><td><center>Format 1</center></td><td><center>时长3ms; 用于超远距离覆盖场景</center></td></tr><tr><td><center>Format 2</center></td><td><center>时长3.5ms; 其中sequence重复发送4次,用于需要覆盖增强场景(如室内)</center></td></tr><tr><td><center>Format 3</center></td><td><center>时长1ms; 用于高速移动场景</center></td></tr><tr><th rowspan="3"><center>short preamble</center></th><td><center>Format A1/A2/A3</center></td><td><center>时长和2,4,6个OFDM符号对齐; 没有GAP; 用于覆盖距离较近,UE位置集中的场景</center></td></tr><tr><td><center>Format B1/B2/B3/B4</center></td><td><center>时长和2,4,6,12个OFDM符号对齐; 有GAP</center></td></tr><tr><td><center>Format C0/C2</center></td><td><center>时长和2,6个OFDM符号对齐; 有GAP,且相对于其他类型较长; 用于较远距离场景</center></td></tr></table><p>以下为各种格式的细节:<strong>图片摘自ShareTechnote</strong></p><p><strong>long preamble 分为四种 Format , 分别为 Format 0/1/2/3</strong></p><p>Format 0:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p2-Format 0.png" alt></p><p>Format 1:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p3-format 1.png" alt></p><p>Format 2:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/format2.png" alt></p><p>Format 3:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p5-format 3.png" alt></p><p><strong>short preamble 分为九种 Format A1/A2/A3/B1/B2/B3/B4/C0/C2</strong></p><p>格式 A 没有定义GAP，适用于覆盖距离较近，UE位置集中的场景</p><p>Format A1: PRACH时长和 <strong>2 OFDM symbol</strong> 对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p6-format A1.png" alt></p><p>Format A2: PRACH时长和 <strong>4 OFDM symbol</strong> 对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p7-format A2.png" alt></p><p>Format A3: PRACH时长和 <strong>6 OFDM symbol</strong> 对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p8-format A3.png" alt></p><p>格式B 定义了GAP</p><p>Format B1: PRACH时长和 <strong>2 OFDM symbol </strong>对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p9-format B1.png" alt></p><p>Format B2: PRACH时长和 <strong>4 OFDM symbol </strong>对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p10-format B2.png" alt></p><p>Format B3: PRACH时长和 <strong>6 OFDM symbol</strong> 对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p11-format B3.png" alt></p><p>Format B4: PRACH时长和 <strong>12 OFDM symbol</strong> 对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p12-format B4.png" alt></p><p>格式C 定义了GAP，且GAP保护时长较大，适用于覆盖距离较远的场景</p><p>Format C0: PRACH时长和 <strong>2 OFDM symbol</strong> 对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p-13format C0.png" alt></p><p>Format C2: PRACH时长和 <strong>6 OFDM symbol</strong> 对齐</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p14-format C2.png" alt></p><p>补充： 如果PRACH Format指示为 A1/B1，A2/B2，A3/B3（混合格式）时，则一个PRACH时隙中最后一个PRACH Occasion 为Format B1/B2/B3，一个PRACH时隙中，前面位置的PRACH Occasion为Format A1/A2/A3。（Format A1/2/3，B1/2/3时长一致(2/4/6 OFDM 符号)，差别在于CP和GAP长度，Format A 无GAP）</p><h2 id="1-3-映射到物理资源"><a href="#1-3-映射到物理资源" class="headerlink" title="1.3 映射到物理资源"></a>1.3 映射到物理资源</h2><p>PRACH信道时域信号定义如下：</p><script type="math/tex;mode=display">s_l^{(p,\mu)}(t)=\sum_{k=0}^{L_{RA}-1}{a_k}^{(p,RA)}\cdot e^{j2\pi(k+Kk_1+\overline k)\Delta f_{RA}(t-N_{CP,l}^{RA}T_c-t_{start}^{RA})}\\K = \Delta f/\Delta f_{RA}\\k_1 = k_0^\mu+N_{BWP,i}^{start}N_{sc}^{RB}+n_{RA}N_{RB}^{RA}N_{sc}^{RB}-N_{grid}^{size,\mu}N_{sc}^{RB}/2\\k_0^\mu = (N_{grid}^{start,\mu}+N_{grid}^{size,\mu}/2)N_{sc}^{RB}-(N_{grid}^{start,\mu_0}+N_{grid}^{size,\mu_0}/2)N_{sc}^{RB}2^{\mu_0-\mu}</script><p>其中 $t_{start}^{RA}\leq t &lt;t_{start}^{RA}+(N_u+N_{CP,l}^{RA})T_c$<br>$\alpha_k^{(p,RA)} = \beta_{PRACH}\cdot y_{u,v}(k)$</p><p>$t_{start}^{RA}$ 表示PRACH preamble</p><ul><li>在一个子帧中的开始位置 —- （ $\Delta f_{RA} \in \{1.25,5,15,30\}$KHz ）</li><li>或者在一个60 KHz的时隙中的位置 —- （ $\Delta f_{RA} \in \{60，120\}$KHz ）</li></ul><h3 id="1-3-1-时域资源映射"><a href="#1-3-1-时域资源映射" class="headerlink" title="1.3.1 时域资源映射"></a>1.3.1 时域资源映射</h3><p>从公式着手：</p><script type="math/tex;mode=display">t_{start}^{RA} = t_{start,l}^\mu \\t_{start,l}^{\mu} = \begin {cases} 0 \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad l = 0\\ t_{start,l-1}^\mu +(N_u^\mu + N_{CP,l-1}^{\mu})T_c \quad \quad otherwise \end{cases}</script><p>符号位置$l$ , $l = l_0+n_t^{RA}N_{dur}^{RA}+14n_{slot}^{RA}$</p><p>其中：</p><ul><li>$l_0$ 为起始符号位置，根据配置表格获得</li><li>$n_t^{RA}$ 为一个PRACH时隙内的PRACH发送时刻，$n_t^{RA} \in \{0,…,N_t^{RA,slot}-1\}$, $L_{RA}= 839$ 时固定为1, $L_{RA} = 139$ 时根据配置表格得到</li><li>$N_{dur}^{RA}$ 根据PRACH配置索引表格得到，和各自格式对应</li><li>$\Delta f_{RA} \in \{1.25,5\}$KHz $\mu = 0$ , 其他情况下，$\mu$按照子载波间隔配置</li><li>$n_{slot}^{RA}$ : ① $\Delta f_{RA} \in \{1.25,5,15,60\}$KHz 时，$n_{slot}^{RA} = 0$ 。② $\Delta f_{RA} \in \{30,120\}$KHz 时，根据配置表格得到(倒数第三列)，如果配置为1，则$n_{slot}^{RA} = 1$ 。③ 其他情况，$n_{slot}^{RA}\in \{0,1\}$</li></ul><p>以上配置表格参考协议中的表格，见附录</p><blockquote><p>[TS 38.211 Table 6.3.3.2-2]<br>[TS 38.211 Table 6.3.3.2-3]<br>[TS 38.211 Table 6.3.3.2-4]</p></blockquote><p>对于时域资源的映射，只需要知道初始符号位置即可，应为特定的Format对应的preamble时域时长时确定的。</p><p>示例说明：<em>prach-ConfigurationIndex</em> = 103，查表可知参数如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p15-时域举例1-1 (1" alt>.png)<br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p16-时域举例1-2.png" alt></p><p>利用上文公式可知，时域资源映射位置，如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p17-时域举例1-3.png" alt><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p18-时域举例1-4.png" alt></p><h3 id="1-3-2-频域资源映射"><a href="#1-3-2-频域资源映射" class="headerlink" title="1.3.2 频域资源映射"></a>1.3.2 频域资源映射</h3><p>PRACH的频域资源主要由两个参数“<strong><em>msg1-FrequencyStart</em></strong>”和“<strong><em>msg1-FDM</em></strong>”决定。频域资源映射主要要确定PRACH频域资源的起始位置，以及PRACH频域占多少个RB。</p><ul><li>PRACH子载波间隔，1.25 5 15 30 60 120 KHz</li><li>PRACH资源在频域上的个数，即频域上的PRACH transmission Occasions, 也称为FDM个数，配置范围(1/2/4/8)个，对应高层参数为 <strong><em>msg1-FDM</em></strong></li><li>PRACH 第一个频域资源，在频域的起始位置，相对于上行激活BWP（上行初始BWP）中PRB 0的偏移位置，对应高层参数为 <strong><em>msg1-FrequencyStart</em></strong></li></ul><p>多个PRACH transmission occasions 在频域上连续放置。</p><p>PRACH频域资源具体情况，在[TS 38.211 Table 6.3.3.2-1]描述</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T3-38.211-6.3.3.2-1.png" alt></p><p>其中$\overline k $ 为下边缘子载波保护个数。分析表格可知，$(\Delta f/\Delta f^{RA}) \cdot N_{RB}^{RA} \cdot N_{sc}^{RB} $ 为 PRACH 占用的子载波数，实际发送使用$L_{RA}$ 个子载波。举个例子，对于第一行：PRACH占用的子载波数 = $(15/1.25)<em>6</em>12 = 864$ 个子载波，实际发送使用 <strong><em>839</em></strong> 个子载波。</p><p>根据1.3节上PRACH信道时域信号</p><p>其中：</p><ul><li>$\mu_0$ 为UE配置的子载波中最大的 $\mu$ 值</li><li>$N_{BWP,i}^{start}$ 为配置的上行初始BWP（或者激活上行BWP）的最低RB索引</li><li>$n_{RA}^{start}$ 为配置的PRACH频域资源在BWP（初始或激活）中的最低RB索引，对应高层参数<em>msg1-FrequencyStar</em></li><li>$n_{RA} \in \{0,1,…,M-1\}$ 表示PRACH transmission occasion 的索引，从0到M，M为配置的PRACH频域资源的PRACH频域资源个数对应的高层参数 <em>msg1-FDM</em> 其取值范围是1，2，4，8</li></ul><p>频域资源位置参考如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p19-频域映射.png" alt></p><h2 id="1-4-SSB和RACH信道配置"><a href="#1-4-SSB和RACH信道配置" class="headerlink" title="1.4 SSB和RACH信道配置"></a>1.4 SSB和RACH信道配置</h2><h3 id="1-4-1-概述"><a href="#1-4-1-概述" class="headerlink" title="1.4.1 概述"></a>1.4.1 概述</h3><p>基站按照前文步骤生成了 preamble，并通过广播发送给UE，UE也知道了PRACH的时频域资源位置，在把preamble放在某个PRACH上发出去之前，还差最关键的一步，那就是基站要确定PRACH与SSB的映射关系。<br>5G里面凡事都会涉及到Beam这个概念，RACH流程也不例外。一个5G小区会发射多个SSB，也就是说有很多个下行的beam。终端会monitor和测量这些beam，挑选一个信号最好的SSB或者beam进行驻留。很明显，终端要获得比较好的上下行传输性能，需要与基站建立一个beam pair(发送beam和接收beam)。这里要强调一点，beam是分发送和接收的，并不是只有发送有beam，接收也有。另外，说到发送beam和接收beam，这里要区分上下行。</p><ul><li>上行（UE -&gt; gNB）: beam pair指基站接收beam，终端发送beam</li><li>下行（gNB -&gt; UE）: beam pair指终端接收beam，基站发送beam</li></ul><p><strong>大致的流程</strong>如下：</p><ol><li>基站：根据逻辑根索引配置生成64个preamble，通过多组beam广播生成信息给UE。</li><li>UE：接收，并测量出最佳的波束方向，随机选取preamble index，选择一个CB preamble，然后以最佳的波束方向反向发送PRACH给基站。</li><li>基站：接收到UE的PRACH，并通过SSB与PRACH之间的关联（SSB仅与CB preamble相关联）确定基站与UE之间的最佳波束方向，以后通过该波束方向向UE发送后续数据。</li></ol><p>简而言之，就是PRACH的发送时刻（RO，RACH occasion，PRACH occasion）需要和SSB发送的时刻（SSB index）建立映射关系。基站根据UE上行PRACH的资源位置，决定下行RAR（RA response）发送的波束。</p><h3 id="1-4-2-SSB与RO映射顺序"><a href="#1-4-2-SSB与RO映射顺序" class="headerlink" title="1.4.2 SSB与RO映射顺序"></a>1.4.2 SSB与RO映射顺序</h3><p>RACH参数配置中<strong><em>ssb-perRACH-OccasionAndCB-PreamblesPerSSB</em></strong>用于配置：</p><ul><li>每个RACH时刻对应的SSB个数 N ，取值可以为 1/8 1/4 1/2 1 2 4 8 16</li><li>每个SSB在一个RO内所能使用的基于竞争的Preamble个数，R（其实就是按SSB数平分CB-preambles）</li></ul><p>① <strong><em>ssb-perRACH-Occasion</em></strong> &gt;=1,即 N &gt; = 1时，表示一个RACH Occasion 对应多个SSB<br>② <strong><em>ssb-perRACH-Occasion</em></strong> &lt;1 , 表示一个SSB对应多个RACH Occasion</p><p>SSB和RO的映射遵循以下原则：</p><ul><li>首先，在一个RO内按照preamble index的升序映射</li><li>其次，按照频域RO升序映射</li><li>然后，按照一个PRACH slot内时域RO升序映射</li><li>最后，按照PRACH slot升序映射</li></ul><p>以下举4个例子说明一下:<br>(1) <em>ssb-perRACH-Occasion</em> = 1/4 , <em>msg1-FDM</em> = 4 $L_{max} = 4$ (也即 SSB个数), SSB 与PRACH occasion映射示意图如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p20-SSB-PRACH例子1.png" alt></p><p>(2) <em>ssb-perRACH-Occasion</em> = 1/2 , <em>msg1-FDM</em> = 4 $L_{max} = 8$ , SSB 与PRACH occasion映射示意图如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p21-SSB-PRACH例子2.png" alt></p><p>(3) <em>ssb-perRACH-Occasion</em> = 1 , <em>msg1-FDM</em> = 4 $L_{max} = 8$ , SSB 与PRACH occasion映射示意图如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p22-SSB-PRACH例子3.png" alt></p><p>(4) <em>ssb-perRACH-Occasion</em> = 2 , <em>msg1-FDM</em> = 2 $L_{max} = 16$ , SSB 与PRACH occasion映射示意图如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p23-SSB-PRACH例子4.png" alt></p><h3 id="1-4-3-SSB-和-RACH-映射周期"><a href="#1-4-3-SSB-和-RACH-映射周期" class="headerlink" title="1.4.3 SSB 和 RACH 映射周期"></a>1.4.3 SSB 和 RACH 映射周期</h3><p>PRACH在时域和频域上有多个发送时刻，每个SSB块要和PRACH发送时刻建立映射关系。同时引入一个<strong><em>association period</em></strong> 映射周期的概念，即表示所有的SSB块全部映射到RO后，需要在时域上多少个PRACH周期。<br>映射周期从帧号0开始。所有SSB至少映射一次后，“多余”的RO，没有SSB映射的话，这些RO不用。<br><strong><em>Association pattern period</em></strong> — 映射图样周期，包含1个或者多个映射周期<strong><em>association periods</em></strong>，为160 ms ,每隔160 ms 重复进行PRACH和SSB的映射。</p><p>举例说明:<br>若<strong><em>ssb-perRACH-Occasion</em></strong> = 1/2 , <strong><em>msg1-FDM</em></strong> = 4 $L_{max} = 4$ , PRACH 周期为 1 Frame = 10 ms，每一个 Frame 中只有一个subFrame 有时域 Occasion ,每一个 subFrame 中 只有一个 时域 occasion 。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p24-SSB周期.png" alt></p><h1 id="2-随机接入过程"><a href="#2-随机接入过程" class="headerlink" title="2 随机接入过程"></a>2 随机接入过程</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>终端成功解出SSB后便获得了NR系统的下行同步，要想完成上行同步以并与NR网络建立RRC连接，那么随机接入RACH流程必不可少。</p><h3 id="2-1-1-随机接入触发场景"><a href="#2-1-1-随机接入触发场景" class="headerlink" title="2.1.1 随机接入触发场景"></a>2.1.1 随机接入触发场景</h3><p>下面这10条RACH触发原因摘自协议38.300。其中第7、9和10条是NR系统新出现的，也是在以往LTE中没有的。其中第7条是指由RRC_Inactive状态向RRC_Connected状态转换，RRC_Inactive状态是NR中新引入的一种RRC状态；第9条是指对于NR系统中一些不广播的系统消息Other SI，UE采用随机接入流程“按需索要”这些不广播的系统消息；第10条是指beam failure后的恢复流程。</p><blockquote><p>1）Initial access from RRC_IDLE;<br>2）RRC Connection Re-establishment procedure;<br>3）DL or UL data arrival during RRC_CONNECTED when UL synchronisation status is “non-synchronised”;<br>4）UL data arrival during RRC_CONNECTED when there are no PUCCH resources for SR available;<br>5）SR failure;<br>6）Request by RRC upon synchronous reconfiguration (e.g. handover);<br>7）Transition from RRC_INACTIVE;<br>8）To establish time alignment for a secondary TAG;<br>9）Request for Other SI;<br>10）Beam failure recovery.</p></blockquote><h3 id="2-1-2-随机接入流程"><a href="#2-1-2-随机接入流程" class="headerlink" title="2.1.2 随机接入流程　　"></a>2.1.2 随机接入流程</h3><p>随机接入过程可以分为竞争性随机接入过程（CBRA）和非竞争性随机接入（CFRA）。非竞争性随机接入是网络将特定的随机接入资源是分配给UE的，通过Random Access Preamble网络就能识别特定的UE。具体的流程如下图所示（摘自ShareTechnote）：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p26-contention-Based.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p27-contention-free.png" alt></p><p>以CBRA的4步(上图CDEF步骤)为例：</p><ul><li>Msg1: UE在合适的PRACH上向gNB发送Preamble；</li><li>Msg2: gNB向UE发送RAR，并包含TC-RNTI、UL timing和对Msg3的调度等信息；</li><li>Msg3/4: 用于竞争冲突解决（多个UE恰巧在同一PRACH时频资源上采用了同一个preamble做RACH）。</li></ul><h2 id="2-2-Msg1"><a href="#2-2-Msg1" class="headerlink" title="2.2 Msg1"></a>2.2 Msg1</h2><p>前文描述的内容也就是Msg1的大部分内容。在发送Msg1给基站之前, ① 要确定多大的功率发送Msg1的preamble；②要确定RAR是发给自己的，即需要一个身份认证，因此用到了RA-RNTI可以唯一标识Msg1发送的时频资源这一特性。</p><h3 id="2-2-1-Msg1的发射功率"><a href="#2-2-1-Msg1的发射功率" class="headerlink" title="2.2.1 Msg1的发射功率"></a>2.2.1 Msg1的发射功率</h3><p>根据[TS 38.213 7.4]，UE配置PRACH信道的发送功率为 $P_{PRACH,b,f,c}(i) $，其意义是基于服务小区C 的 DL RS 在上行激活带宽 b 载波 f上，在发送时刻 为 i 时的发射功率。</p><script type="math/tex;mode=display">P_{PRACH,b,f,c}(i) = min\{P_{CMAX,f,c}(i),P_{PRACH,target,f,c}+PL_{b,f,c}\}[dBm]</script><p>其中：</p><ul><li>$P_{CMAX,f,c}(i)$ 是UE配置的最大输出功率，由 [8-1. TS 38.101-1]和 [8-2. TS 38.101-2]给出。</li><li>$P_{PRACH,target,f,c}$ 为PRACH 目标接收功率 <em>PREAMBLE_RECEIVED_TARGET_POWER</em> 由[11. TS 38.321] 给出计算公式：<em>PREAMBLE_RECEIVED_TARGET_POWER</em> = <em>preambleReceivedTargetPower</em> + <em>DELTA_PREAMBLE</em> + <em>(PREAMBLE_POWER_RAMPING_COUNTER -1)</em> <em></em>PREAMBLE_POWER_RAMPING_STEP*<ul><li><em>preambleReceivedTargetPower</em> 由参数 <em>preambleReceivedTargetPower</em> 给出</li><li><em>DELTA_PREAMBLE</em>可由[TS 38.321 Table 7.3-1~2] 获得</li><li><em>PREAMBLE_POWER_RAMPING_COUNTER</em> 对初始传输为1，依据重传次数自增一</li><li><em>PREAMBLE_POWER_RAMPING_STEP</em> 由参数 <em>powerRampingStep</em> 给出<br>（以上两条是为了功率攀升而设定的参数）</li></ul></li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T13-213 7.3-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T14-213 7.3.1-2.png" alt></p><ul><li>$PL_{b,f,c}$ 为路径损耗。由参数 <em>referenceSignalPower</em> – <em>higher layer filtered RSRP</em> (in dBm) 获得。<ul><li><em>referenceSignalPower</em> 根据PRACH 关联的SSB或者CSI-RS，由参数 <em>ss-PBCH_BlockPowe</em>r 和 <em>powerControlOffsetSS</em> 决定。</li><li><em>higher layer filtered RSRP</em> 是发送PRACH时测得的 RSRP (Reference Signal Receiving Power)。</li></ul></li></ul><p>示例：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rach-ConfigGeneric</span><br><span class="line">&#123;</span><br><span class="line">prach-ConfigurationIndex 2,			\\ 可以确定format 0</span><br><span class="line">msg1-FDM one,</span><br><span class="line">msg1-FrequencyStart 2,</span><br><span class="line">zeroCorrelationZoneConfig 6,</span><br><span class="line">preambleReceivedTargetPower -100,	\\ -100</span><br><span class="line">preambleTransMax n10,				\\ 最大重传次数</span><br><span class="line">powerRampingStep dB4,				\\ 4</span><br><span class="line">ra-ResponseWindow sl20</span><br><span class="line">&#125;,</span><br><span class="line">ss-PBCH-BlockPower -8				\\ referenceSignalPower&#x3D;-8</span><br><span class="line">假设此时的RSRP为-94dBm</span><br></pre></td></tr></table></figure><p></p><p>则此时的Msg1的初始发射功率为：</p><script type="math/tex;mode=display">P = -100 + 0 + (1-1)*4 + [-8-(-94)] = -14dBm</script><p>如果发生Msg2或者Msg4失败，则会触发Msg1重传，Msg1的最大重传次数由参数<em>preambleTransMax</em>定义。如果发生Msg1的重传，每次重传功率会以<em>powerRampingStep</em>这个步长增大(功率攀升，Ramping)，直到最后达到UE的最大功率或者重传达到最大次数为止。<br>注意：</p><ul><li>当UE<strong>继续使用</strong>上次发送SSB波束重发Msg1时，需要功率攀升。</li><li>当UE<strong>更换</strong>SSB波束发送Msg1时，不需要进行功率攀升。</li></ul><h3 id="2-2-2-RA-RNTI的计算和使用"><a href="#2-2-2-RA-RNTI的计算和使用" class="headerlink" title="2.2.2 RA-RNTI的计算和使用"></a>2.2.2 RA-RNTI的计算和使用</h3><p>RA-RNTI可以表征Msg1发送时使用的时频资源，UE发送Msg1时会计算RA-RNTI并保存；gNB收到该Msg1后，同样会计算RA-RNTI，并使用该RA-RNTI对Msg2的PDCCH DCI format 1_0的CRC进行扰码。</p><p>RA-RNTI=1 + s_id + 14 $\times$ t_id +14$\times80\times$ f_id + $14\times80\times8\times$ ul_carrier_id</p><p>其中：</p><ul><li>s_id 是PRACH的起始符号索引 (0$\leq$ s_id &lt;14)</li><li>t_id 是系统帧内PRACH的起始时隙索引 (0$\leq$ t_id &lt;50)</li><li>f_id 是PRACH 频域位置索引 (0$\leq$ f_id &lt;8)</li><li>ul_carrier_id 是Msg1发送上行载波指示 (0 for NUL carrier, and 1 for SUL carrier)</li></ul><h2 id="2-2-Msg2"><a href="#2-2-Msg2" class="headerlink" title="2.2 Msg2"></a>2.2 Msg2</h2><h3 id="2-2-1-UE接收Msg2"><a href="#2-2-1-UE接收Msg2" class="headerlink" title="2.2.1 UE接收Msg2"></a>2.2.1 UE接收Msg2</h3><ol><li>UE首先需要去解析出用于Msg2的下行调度的PDCCH DCI。定义了一个window的概念，UE在这个窗口内去监听PDCCH。window的长度由参数 <em>ra-ResponseWindow</em> 规定（不能超过10ms），单位是slot。window的起点是距离PRACH发送之后至少间隔1个symbol的用于Typ1-PDCCH CSS的CORESET的首个symbol。一般情况都是PRACH发送完之后的那个下行slot作为起点。</li><li>要监听的DCI的格式是format 1_0。这个DCI需要去Type 1 PDCCH Common Search Space去找，由参数 <em>ra-SearchSpace</em> 定义。</li><li>基站对这个PDCCH DCI的CRC使用了RA-RNTI进行了扰码，所以终端需要在 <em>ra-searchspace</em>上面尝试使用RA-RNTI去解析PDCCH DCI。</li><li>如果UE成功的使用RA-RNTI解调了DCI（知道这个消息是发送给自己的）。接着它会去解PDSCH payload。</li><li>如果UE继续成功的解出了PDSCH，UE会检查其中 RAPID（random access preamble identity）是否与自己当时发送Msg1时使用的RACH preamble ID相同。如果相同，UE认为Msg2解调成功。</li><li>如果UE在<em>ra-ResponseWindow</em> 内没有使用RA-RNTI解出DCI，或者没有成功解出PDSCH payload，或者解出了PDSCH但是RAPID不匹配，UE都会认为Msg2接收失败，会触发Msg1重发。</li></ol><h3 id="2-2-2-Msg2内容"><a href="#2-2-2-Msg2内容" class="headerlink" title="2.2.2 Msg2内容"></a>2.2.2 Msg2内容</h3><blockquote><p><strong>6.1.5 MAC PDU (Random Access Response)</strong><br>A MAC PDU consists of one or more MAC subPDUs and optionally padding. Each MAC subPDU consists one of the following:</p><ul><li>a MAC subheader with Backoff Indicator only;</li><li>a MAC subheader with RAPID only (i.e. acknowledgment for SI request);</li><li>a MAC subheader with RAPID and MAC RAR.</li></ul></blockquote><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p28-Figure6.1.5-3.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p31-MAC-PDU.png" alt></p><p>上面的描述及图片摘自 [TS 38.213]，结构图摘自ShareTechnote，说明Msg2这个MAC PDU 肯能包含BI，RAPID 和 MAC RAR三部分。</p><ul><li>BI（Backoff Indicator）用于当Msg1重发的时候产生一个随机退避时间（0 - PREAMBLE_BACKOFF），当这个退避时间结束后，终端才能重发Msg1。Msg2里面的BI field对应的退避时间如下表[TS 38.321 Table 7.2-1]。如果不包含用于BI的MAC subPDU，那么重发Msg1时退避时间为0ms。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p30-7.2-1.png" alt></p><ul><li>RAPID，用于携带random access preamble ID，如上描述。</li><li>RAR，这个subPDU是Msg2里面最重要的部分。主要包括TA，UL GRANT信息和TC-RNTI，其中UL GRANT是用于后面的Msg3，包括PUSCH的时域，频域的资源分配，是否跳频，MCS，Msg3的功控(参考[TS 38.213 Table 8.2-2])和CSI request。具体结构如下图[TS 38.321 6.2.2-3]，UL_GRANT中的内容如下表[TS 38.213 Table 8.2-1]。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p29-Figure 6.2.3-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T-15-8.2-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T15-213-8.2-2.png" alt></p><h2 id="2-3-Msg3"><a href="#2-3-Msg3" class="headerlink" title="2.3 Msg3"></a>2.3 Msg3</h2><p>根据前文描述UE在Msg2中解析到MAC RAR，MAC RAR中包含着27 bit 的UL Grant，该UL Grant指示了PUSCH的时域，频域的资源分配，是否跳频，MCS，Msg3的功控和CSI request 等消息。</p><h3 id="2-3-1-Msg3的传输内容"><a href="#2-3-1-Msg3的传输内容" class="headerlink" title="2.3.1 Msg3的传输内容"></a>2.3.1 Msg3的传输内容</h3><p>Msg3传输的内容取决于随机接入的场景。</p><ul><li>UE已经拥有了合法的C-RNTI：UE在Mdg3上发送C-RNTI MAC CE (由LCID index 58)。</li><li>UE没有合法的C-RNTI：UE在Msg3上发送CCCH SDU (由LCID指示)，这些CCCH SDU里面包含竞争解决身份identity。<h3 id="2-3-2-Msg3的发送时刻"><a href="#2-3-2-Msg3的发送时刻" class="headerlink" title="2.3.2 Msg3的发送时刻"></a>2.3.2 Msg3的发送时刻</h3>假设接收Msg2末尾消息在slot $n$ , 则UE发送Msg3的 solt $n+k_2+\Delta$ , 其中的 $k_2, \Delta$ 由 [6. TS 38.214] 给出，如下图所示。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p32-K2.png" alt></p><p>Msg3的发送时刻与Msg2的最后一个symbol至少相隔 $N_{T,1}+N_{T,2}+0.5$ msec，其中 $N_{T,1}，N_{T,2}$ 是N个符号的持续时间，该时间与当配置 additional PDSCH DMRS时用于UE处理能力1,2 的PDSCH处理时间相对应。N 的对应取值由下表给出：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T20-214-6.4-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T21-214-6.4-2.png" alt></p><h2 id="2-4-Msg4"><a href="#2-4-Msg4" class="headerlink" title="2.4 Msg4"></a>2.4 Msg4</h2><p>Msg4 是 Contention Resolution 环节。竞争解决的方式取决于 Msg3 中是传输了CCCH SDU 还是 C-RNTI MAC CE。</p><ul><li><p>Msg3 中传输CCCH SDU</p><p>在这种情况下，Msg3发送对应PUSCH符号结束之后，则开启 <em>re-ContentionResolutionTimer</em> ，在TImer为未超时之前，在<em>ra-SearchSpace</em> 上检测 Temporay C-RNTI 的DCI format 1_0，在调度的PDSCH译码正确的情况下，如果解析到UE Contention Resolution Identity MAC CE，且其内容与发送的CCCH SDU 两者内容一致，则认为随机过程接入成功，之后停止 <em>ra-ContentionResolutionTimer</em>，并将TC-RNTI正式转化为C-RNTI。</p></li><li><p>Msg3 中传输 C-RNTI MAC CE</p><p>此种情况下，冲突解决的原理与传输CCCH SDU时相同，只是通过接收C-RNTI调度的DCI来判断竞争解决是否成功。</p></li></ul><h2 id="2-5-HARQ-ACK-for-Msg4"><a href="#2-5-HARQ-ACK-for-Msg4" class="headerlink" title="2.5 HARQ ACK for Msg4"></a>2.5 HARQ ACK for Msg4</h2><p>一旦UE成功解析出Msg4，UE在PUCCH中发送HARQ-ACK信息。反馈时间距离Msg4的最后一个symbol至少相隔$N_{T,1}+0.5$ msec (参考Msg3的准备时间)。</p><h2 id="2-6-流程时序图总结"><a href="#2-6-流程时序图总结" class="headerlink" title="2.6 流程时序图总结"></a>2.6 流程时序图总结</h2><p>流程时序如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p33-时序图.png" alt></p><p>其中：</p><ul><li><ol><li>gNB → UE：System information。</li></ol><ul><li>Configuration of PRACH transmission Parameters<ul><li>PRACH Preamble Format</li><li>Time Resources</li><li>Frequency Resources</li></ul></li><li>Parameters for determining the root sequences and their cyclic shifts in the PRACH Preamble sequence set<ul><li>index to logical root sequence table</li><li>Cyclic Shift(Ncs)</li><li>Set Type (unrestricted, restricted set A or restricted set B)</li></ul></li></ul></li><li><ol><li>UE → gNB：Msg1- PRACH Preamble。PRACH Preamble 频域资源由参数 <em>msg1-FDM</em> 和 <em>msg1-FrequencyStart</em> 决定；PRACH Preamble 时域资源由参数 <em>prach-ConfigurationIndex</em> 决定；</li></ol></li><li><ol><li>gNB → UE：Msg2。Msg2需要在ra-ResponseWindow内被UE接收。</li></ol></li><li><ol><li>UE → gNB：Msg3。Msg3发送时隙，与Msg2最后时隙相差 $k_2+\Delta$ ; 时间上至少相隔 $N_{T,1}+N_{T,2}+0.5$ ms 。</li></ol></li><li><ol><li>gNB → UE：Msg4。冲突解决环节，对应Msg3所传输的不同内容做出回应。Msg4需要在<em>ra-ContentionResolutionTimer</em> 内被UE接收。</li></ol></li><li><ol><li>UE → gNB：HARQ ACK。反馈时间距离Msg4的最后一个symbol至少相隔$N_{T,1}+0.5$ ms 。</li></ol></li></ul><h1 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3 扩展"></a>3 扩展</h1><blockquote><p>主要参考：<a href="https://blog.csdn.net/GiveMe5G/article/details/103847118" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/103847118</a></p></blockquote><p>主要是分析随机接入过程中的消息如何组合起来应用到实际的场景中去。参考中主要是归纳总结了随机接入的触发场景，并对三个重要场景下的RACH流程进行进一步的分析。</p><h2 id="3-1-RACH触发类型-场景-分类"><a href="#3-1-RACH触发类型-场景-分类" class="headerlink" title="3.1 RACH触发类型(场景)分类"></a>3.1 RACH触发类型(场景)分类</h2><p>RACH流程主要由三种触发类型：</p><ul><li>PDCCH order触发</li><li>MAC层触发</li><li>RRC层触发</li></ul><blockquote><p>The Random Access procedure described in this clause is initiated by a PDCCH order, by the MAC entity itself, or by RRC for the events in accordance with TS 38.300</p></blockquote><p>以下是参考文章作者根据 TS 38.300 系列整理的表格，归纳了各个场景以及其对应的触发类型：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p34-RACH场景.png" alt></p><h2 id="3-2-PDCCH-Order-RACH"><a href="#3-2-PDCCH-Order-RACH" class="headerlink" title="3.2 PDCCH Order RACH"></a>3.2 PDCCH Order RACH</h2><p>PDCCH Order 发起的随机接入主要用于上行失步后，当gNB有下行数据要发送时，会使用PDCCH Order 强制UE发起 RACH 以重新完成上行时间同步。PDCCH Order使用PDCCH DCI 1_0配置给UE。其字段的设置如下：</p><ul><li>Random Access Preamble index – 6 bits</li><li>UL/SUL indicator – 1 bit</li><li>SS/PBCH index – 6 bits</li><li>PRACH Mask index – 4 bits</li><li>Reserved bits – 10 bits</li></ul><p>从上述描述中可以看出，DCI 1_0中会告诉UE 用于RACH的preamble index 以便UE发起非竞争的随机接入，但是要注意这是有条件的，要求DCI 1_0中指示的preamble index非0，否则需要使用基于竞争的随机接入。</p><p>基于竞争和非竞争的PDCCH Order触发的RACH流程图如下所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p35-场景1.png" alt></p><h2 id="3-3-Beam-Failure-Recovery-RACH"><a href="#3-3-Beam-Failure-Recovery-RACH" class="headerlink" title="3.3 Beam Failure Recovery RACH"></a>3.3 Beam Failure Recovery RACH</h2><p>在5G当中引入了一个beam 级别的链路恢复机制，Beam failure recovery，后面简称为BFR。BFR分为基于竞争和基于非竞争两种。按照38321中的描述，如果RRC配置了用于BFR的RACH资源并且用于beam恢复的candidate beam（SSB/CSI-RS）中至少有一个beam的RSRP高于一定的门限，而且beamFailureRecoveryTimer没有超时，这时才能使用基于非竞争的BFR；否则需要使用基于竞争的BFR。<br>下面的两幅图是基于竞争和非竞争的BFR RACH流程。需要注意的是，对于基于非竞争的BFR流程的Msg2，其PDCCH是使用C-RNTI扰码的，而不是RA-RNTI。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p36-场景2.png" alt></p><h2 id="3-4-OSI-Other-System-Information-Request-RACH"><a href="#3-4-OSI-Other-System-Information-Request-RACH" class="headerlink" title="3.4 OSI (Other System Information) Request RACH"></a>3.4 OSI (Other System Information) Request RACH</h2><p>5G SA组网当中MIB和SIB1这两个系统消息一定是通过广播的方式通知UE的，但是其他的系统消息（OSI-Other System Information）可以采用像LTE的广播方式，也可以采用5G当中新引入的按需索要的方式（On Demond Request）。<br>对于按需索要的系统消息，会用到RACH 流程，具体分为Msg1 based和Msg3 based的两种RACH流程。注意，Msg1 based的请求需要基站在SIB1里面的SI-SchedulingInfo中配置专门用于OSI请求的RACH资源和Preamble，而且它的Msg2是一个只含有RAPID的MAC subPDU；而Msg3 based的其实是一种普通的基于竞争的RACH方式，只是这里面的Msg3引入了一个新的UL-CCCH消息，RRCSystemInfoRequest，用于请求UE想要的OSI。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/p37-场景3.png" alt></p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="附录A-相关表格"><a href="#附录A-相关表格" class="headerlink" title="附录A 相关表格"></a>附录A 相关表格</h2><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T1-38.211-6.3.3.1-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T2-38.211-6.3.3.1-2.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T3-38.211-6.3.3.2-1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T5-38.211-6.3.3.1-3(4" alt>.png)</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T6-38.211-6.3.3.1-5.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T7-38.211-6.3.3.1-6.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T8-38.211-6.3.3.1-7.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T9-38.211-6.3.3.2-2.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T10-38.211-6.3.3.2-3.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/T11-38.211-6.3.3.2-4.png" alt></p><h2 id="附录B-相关配置"><a href="#附录B-相关配置" class="headerlink" title="附录B 相关配置"></a>附录B 相关配置</h2><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/C1-RACH-Configuration.png" alt><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/C2-RACH-Configuration2.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/C3-RACH-ConfigDedicated1.png" alt><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/C4-RACH-ConfigDedicated2.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PRACH%E5%AD%A6%E4%B9%A0/C5-RACH-ConfigGeneric.png" alt></p><blockquote><p>参考文献<br>公众号：5G菜鸟成长日记，春天工作室<br>网页：<a href="https://mp.weixin.qq.com/s/LRpnHwaAmYmpUlhF6wcmZg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LRpnHwaAmYmpUlhF6wcmZg</a><br>网页：<a href="http://www.sharetechnote.com/html/5G/5G_RACH.html" target="_blank" rel="noopener">http://www.sharetechnote.com/html/5G/5G_RACH.html</a><br>博客：<a href="https://blog.csdn.net/qq_33206497/article/details/89980529" target="_blank" rel="noopener">https://blog.csdn.net/qq_33206497/article/details/89980529</a><br>博客：<a href="https://blog.csdn.net/GiveMe5G/article/details/102634057" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/102634057</a><br>博客：<a href="https://blog.csdn.net/GiveMe5G/article/details/102633678" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/102633678</a><br>博客：<a href="https://blog.csdn.net/GiveMe5G/article/details/102633541" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/102633541</a><br>博客：<a href="https://blog.csdn.net/GiveMe5G/article/details/103219499" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/103219499</a><br>博客：<a href="https://blog.csdn.net/GiveMe5G/article/details/103413805" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/103413805</a><br>博客：<a href="https://blog.csdn.net/GiveMe5G/article/details/103606304" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/103606304</a><br>博客：<a href="https://blog.csdn.net/GiveMe5G/article/details/103847118" target="_blank" rel="noopener">https://blog.csdn.net/GiveMe5G/article/details/103847118</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>PRACH</tag>
        <tag>随机接入</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-PDSCH学习</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Mon May 04 2020 17:17:36 GMT+0800 (GMT+08:00) --><h1 id="1-PDSCH-物理流程"><a href="#1-PDSCH-物理流程" class="headerlink" title="1 PDSCH 物理流程"></a>1 PDSCH 物理流程</h1><h2 id="1-1-加扰"><a href="#1-1-加扰" class="headerlink" title="1.1 加扰"></a>1.1 加扰</h2><p>双码字传输时，$q \in \{0,1\}$；单码字传输时，$q = 0$。[TS 38.211 7.3.1.1]<br>每一个码字对应的原始数据 $b^{(q)}(0),…,b^{(q)}(M_{bit}^{(q)}-1)$ ,经过加扰处理生成加扰后的数据为 $\widetilde b^{(q)}(0),…,\widetilde b^{(q)}(M_{bit}^{(q)}-1)$ 。加扰处理如下所示：</p><script type="math/tex;mode=display">\widetilde b^{(q)}(i) = (b^{(q)}(i) + c^{(q)}(i))mod2</script><p>加扰序列是一个伪随机序列，由[TS 38.211 5.2.1]给出，加扰序列的初始为：</p><script type="math/tex;mode=display">C_{init} = n_{RNTI}\cdot2^{15}+q\cdot2^{14}+n_{ID}</script><p>其中：</p><ul><li>$n_{ID}$ = dataScramblingIdentityPDSCH(如果配置)，并且RNTI = C-RNTI or CS-RNTI，在公共搜索空间中不使用DCI格式1_0调度传输。</li><li>除此之外 $n_{ID} = N_{ID}^{cell}$</li><li>$n_{RNTI}$ 就是PDSCH当前传输时相关联的RNTI</li></ul><h2 id="1-2-调制"><a href="#1-2-调制" class="headerlink" title="1.2 调制"></a>1.2 调制</h2><p>每一个码字加扰后的比特块 $\widetilde b^{(q)}(0),…,\widetilde b^{(q)}(M_{bit}^{(q)}-1)$ 采用下表中的一种调制方式进行调制，得到一个复值调制符号块$d^{(q)}(0),…,d^{(q)}(M_{symb}^{(q)}-1)$。[TS 38.211 7.3.1.2]</p><table><tr><td><center>Modulation scheme</center></td><td><center>Modulation order</center></td></tr><tr><td><center>QPSK</center></td><td><center>2</center></td></tr><tr><td><center>16QAM</center></td><td><center>4</center></td></tr><tr><td><center>64QAM</center></td><td><center>6</center></td></tr><tr><td><center>256QAM</center></td><td><center>8</center></td></tr></table><h2 id="1-3-层映射"><a href="#1-3-层映射" class="headerlink" title="1.3 层映射"></a>1.3 层映射</h2><p>每一个码字生成的调制信号 $d^{(q)}(0),…,d^{(q)}(M_{symb}^{(q)}-1)$ 根据下表映射到多个层$x(i)=[x^0{i} \cdots x^{v-1}(i)]^T$，$i = 0,1,…,M_{symb}^{layer}-1$，其中$v$表示层数，$M_{symb}^{layer}$ 表示每层调制符号的数量。[TS 38.211 7.3.1.3]</p><div class="table-container"><table><thead><tr><th style="text-align:center">层数</th><th style="text-align:center">码字数</th><th>码字到层映射<br>$i = 0,1,…,M_{symb}^{layer}-1$</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(i)$ $M_{symb}^{layer} = M_{symb}^{(0)}$</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(2i)$<br>$x^{(1)}(i) = d^{(0)}(2i+1)$ $M_{symb}^{layer} = M_{symb}^{(0)}/2$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(3i)$<br>$x^{(1)}(i) = d^{(0)}(3i+1)$ $M_{symb}^{layer} = M_{symb}^{(0)}/3$<br>$x^{(2)}(i) = d^{(0)}(3i+2)$</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td>$x^{(0)}(i) = d^{(0)}(4i)$<br>$x^{(1)}(i) = d^{(0)}(4i+1)$<br>$x^{(2)}(i) = d^{(0)}(4i+2)$ $M_{symb}^{layer} = M_{symb}^{(0)}/4$<br>$x^{(3)}(i) = d^{(0)}(4i+3)$</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(2i)$<br>$x^{(1)}(i) = d^{(0)}(2i+1)$<br>$x^{(2)}(i) = d^{(1)}(3i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/2 = M_{symb}^{(1)}/3$<br>$x^{(3)}(i) = d^{(1)}(3i+1)$<br>$x^{(4)}(i) = d^{(1)}(3i+2)$</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(3i)$<br>$x^{(1)}(i) = d^{(0)}(3i+1)$<br>$x^{(2)}(i) = d^{(0)}(3i+2)$<br>$x^{(3)}(i) = d^{(1)}(3i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/3 = M_{symb}^{(1)}/3$<br>$x^{(4)}(i) = d^{(1)}(3i+1)$<br>$x^{(5)}(i) = d^{(1)}(3i+2)$</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(3i)$<br>$x^{(1)}(i) = d^{(0)}(3i+1)$<br>$x^{(2)}(i) = d^{(0)}(3i+2)$<br>$x^{(3)}(i) = d^{(1)}(4i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/3 = M_{symb}^{(1)}/4$<br>$x^{(4)}(i) = d^{(1)}(4i+1)$<br>$x^{(5)}(i) = d^{(1)}(4i+2)$<br>$x^{(6)}(i)=d^{(1)}(4i+3)$</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">2</td><td>$x^{(0)}(i) = d^{(0)}(4i)$<br>$x^{(1)}(i) = d^{(0)}(4i+1)$<br>$x^{(2)}(i) = d^{(0)}(4i+2)$<br>$x^{(3)}(i)=d^{(0)}(4i+3)$<br>$x^{(4)}(i) = d^{(1)}(4i)$ $M_{symb}^{layer} = M_{symb}^{(0)}/4 = M_{symb}^{(1)}/4$<br>$x^{(5)}(i) = d^{(1)}(4i+1)$<br>$x^{(6)}(i) = d^{(1)}(4i+2)$<br>$x^{(7)}(i)=d^{(1)}(4i+3)$</td></tr></tbody></table></div><p>可以看到，单码字映射到1-4层，双码字映射到5-8层。</p><h2 id="1-4-天线端口映射"><a href="#1-4-天线端口映射" class="headerlink" title="1.4 天线端口映射"></a>1.4 天线端口映射</h2><p>经过层映射之后的数据按照如下方式映射到天线端口。[TS 38.211 7.3.1.4]</p><script type="math/tex;mode=display">\left[
\begin{matrix}
y^{(p_0)}(i)\\
\vdots\\
y^{(p_{v-1})}(i)\\
\end{matrix}
\right]= \left[
\begin{matrix}
x^{(0)}(i)\\
\vdots\\
x^{(v-1)}(i)
\end{matrix}
\right]</script><p>其中 $i=0,1,…,M_{symb}^{ap}-1$，$M_{symb}^{ap}=M_{symb}^{layer}$</p><h2 id="1-5-映射到虚拟资源快"><a href="#1-5-映射到虚拟资源快" class="headerlink" title="1.5 映射到虚拟资源快"></a>1.5 映射到虚拟资源快</h2><p>对于每个天线步骤，都会创建一个虚拟资源网格。在资源网格内，从RE的最低频率到较高频率的来自来填充PDSCH数据到每个RE中。一旦它以分配的PDSCH资源块的最高频率到达RE，则移至下一个OFDM符号的最低频率的RE。[TS 38.211 7.3.1.5]<br>但不应使用为以下目的而分配的RE：</p><ul><li>分配给与要发送的PDSCH相关的DMRS的RE</li><li>为DMRS分配给用于其他共同调度UE的RE</li><li>非零功率CSI-RS的RE，由MeasObjectNR IE中较高层参数CSI-RS-Resource-Mobility配置的非零功率CSI-RS除外。</li><li>PTRS的RE</li><li>声明为“不适用于PDSCH的RE”</li></ul><h2 id="1-6-从虚拟资源块映射到物理资源块"><a href="#1-6-从虚拟资源块映射到物理资源块" class="headerlink" title="1.6 从虚拟资源块映射到物理资源块"></a>1.6 从虚拟资源块映射到物理资源块</h2><p>从VRB到PRB的映射有交织和非交织两种。[TS 38.211 7.3.1.6]</p><h3 id="1-6-1-非交织"><a href="#1-6-1-非交织" class="headerlink" title="1.6.1 非交织"></a>1.6.1 非交织</h3><p>在公共搜索空间用DCI Format 1_0调度的PDSCH传输这种情况下,虚拟资源块$n$映射到物理资源块 $n + N_{start}^{CORESET}$ 上，其中$N_{start}^{CORESET}$是接受相应DCI的控制资源集中编号最小的物理资源块；<br>除此情况之外，虚拟资源块$n$就映射到物理资源块$n$上。<br>如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/non-interleave.png" alt></p><h3 id="1-6-2-交织"><a href="#1-6-2-交织" class="headerlink" title="1.6.2 交织"></a>1.6.2 交织</h3><p>交织映射模式，以资源块束(RB bundle)来定义，与PDCCH的RB bundle 相比PDSCH的资源块束有些不同，主要分三种情况：<br><strong>类型一</strong>：<br>在CORESET#0的Type0-PDCCH公共搜索空间，由SI-RNTI加扰，用DCI Format 1_0 调度的PDSCH传输。<br>下行初始激活的BWP，大小$N_{BWP,init}^{size}$，分为$N_{bundle} = \lceil N_{BWP,init}^{size}/L \rceil$ 个RB bundle，按照RB编号和束编号升序排序。其中$L$是bundle的大小，取值为２。如果$N_{BWP,init}^{size}$不能整数L，最后一个RB bundle包含 $N_{BWP,init}^{size}modL$个RB，其实由于$L = 2$所以最后一个不能整数的话那就剩下一个RB，能整数除最后一个RB bundle就是2个RB。<br>如下图所示：<br><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/interleaver1.png" alt></p><p><strong>类型二</strong>：<br>除上述情况外，在公共搜索空间由DCI Format 1_0调度的PDSCH传输。<br>BWP起始位置$N_{BWP,i}^{start}$，大小为$N_{BWP,init}^{size}$ 的VRB集合$\{0,1,…,N_{BWP,init}^{size}-1\}$ 分为$N_{bundle}$ 个虚拟RB bundle，相应的$N_{BWP,init}^{size}$ 个PRB集合$\{N_{start}^{CORESET},N_{start}^{CORESET}+1,…,N_{start}^{CORESET}+N_{BWP,init}^{size}\}$ 分为$N_{bundle}$ 个物理RB bundle，其中$N_{bundle}=\lceil (N_{BWP,init}^{size}+(N_{BWP.i}^{start}+N_{start}^{CORESET})modL)/L \rceil$ ，L是bundle的大小，取值为2，$N_{start}^{CORESET}$是接受相应DCI的控制资源集中编号最小的物理资源块。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/interleave2.png" alt></p><p>其RB bundle 包含的RB数如下描述：</p><ul><li>0号RB bundle 包含了$L-((N_{BWP,i}^{start}+N_{start}^{CONRESET})modL)$个RB；</li><li>如果$(N_{BWP,init}^{size}+N_{BWP,i}^{start}+N_{start}^{CONRESET})modL&gt;0$，则最后一个RB bundle包含了$(N_{BWP,init}^{size}+N_{BWP,i}^{start}+N_{start}^{CONRESET})modL$ 个RB，否则包含$L$个RB；</li><li>其余RB bundle 包含$L$ 个RB；<br>之所以要考虑进$N_{start}^{CONRESET}$，是因为38.214中规定，对于任何在PDCCH公共搜索空间中以DCI format 1_0调度的PDSCH传输，其RB编号从接受DCI的CORESET的最低RB开始。</li></ul><p><strong>类型三</strong>：<br>其他PDSCH传输。<br>BWP，i的起始位置$N_{BWP,i}^{start}$，大小$N_{BWP,i}^{size}$，分为$N_{bundle}$ 个RB bundle 且按照RB编号和束编号的升序排列，其中$N_bundle = \lceil(N_{BWP,init}^{size}+(N_{BWP,i}^{start}modL_i))/L_i \rceil$，$L_i$ 是bundle的大小，由高层参数vrb- ToPRB-Interleaver配置。<br><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/interleave3.png" alt></p><p>其RB bundle 包含的RB数如下描述：</p><ul><li>0号RB bundle包含了$L_i-(N_{BWP,i}^{start}modL_i)$个RB，目的是为了从下一个bundle开始，每个bundle的起始位置都是$L_i $的整数倍；</li><li>如果$(N_{BWP,i}^{start}+N_{BWP,i}^{size})modL_i&gt;0$，最后一个RB bundle包含了$(N_{BWP,i}^{start}+N_{BWP,i}^{size})modL_i$ 个RB，否则包含$L_i$ 个RB；</li><li>其余RB bundle 包含$L_i$ 个RB。</li></ul><p>举个例子来描述类型三：<br>例子：假设$N_{BWP,i}^{start} = 5,N_{BWP,i}^{size} = 21$<br>1) $L_i=5$<br>$N_bundle = \lceil(N_{BWP,init}^{size}+(N_{BWP,i}^{start}modL_i))/L_i \rceil = \lceil(21+(5mod5))/5 \rceil = 5$<br>$N_{bundle,0} = L_i-(N_{BWP,i}^{start}modL_i) = 5-(5mod5) =5$<br>$N_{bundle,end} = (N_{BWP,i}^{start}+N_{BWP,i}^{size})modL_i = (5+21)mod5 = 1$<br>$N_{bundle,other} = L_i = 5$<br>如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/case1.png" alt></p><p>2) $L_i=4$<br>$N_bundle = \lceil(N_{BWP,init}^{size}+(N_{BWP,i}^{start}modL_i))/L_i \rceil = \lceil(21+(5mod4))/4 \rceil = 6$<br>$N_{bundle,0} = L_i-(N_{BWP,i}^{start}modL_i) = 4-(5mod4) =3$<br>$N_{bundle,end} = (N_{BWP,i}^{start}+N_{BWP,i}^{size})modL_i = (5+21)mod4 = 2$<br>$N_{bundle,other} = L_i = 4$<br>如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/case2.png" alt></p><h3 id="1-6-3-VRB-bundle-到-PRB-bundle-的映射"><a href="#1-6-3-VRB-bundle-到-PRB-bundle-的映射" class="headerlink" title="1.6.3 VRB bundle 到 PRB bundle 的映射"></a>1.6.3 VRB bundle 到 PRB bundle 的映射</h3><p>本节来看属于$j\in \{0,1,…,N_{bundle}-1\}$ 区间内的虚拟RB向物理RB的映射：</p><ul><li>$N_bundle - 1$号虚拟RB bundle映射到$N_{bundle}-1$号物理RB bundle；</li><li>其余$j\in \{0,1,…,N_{bundle}-2\}$ 的虚拟RB bundle 遵循$f(j)$ 函数映射到物理RB bundle<script type="math/tex;mode=display">f(j) = rC+c\\j = cR+r\\r = 0,1,...,R-1\\c = 0,1,...,C-1\\R = 2\\C = \lfloor N_{bundle}/R \rfloor</script></li></ul><p>举个例子说明，运用上面的例子数据:<br>1) $R = 2; \quad C = \lfloor N_{bundle}/R \rfloor = \lfloor 5/2 \rfloor = 2;\quad r = 0,1,2;\quad c = 0,1,2$。</p><div class="table-container"><table><thead><tr><th>c</th><th>r</th><th>j: VRB bundle</th><th>$f(j)$: PRB bundle</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>2</td></tr><tr><td>1</td><td>0</td><td>2</td><td>1</td></tr><tr><td>1</td><td>1</td><td>3</td><td>3</td></tr></tbody></table></div><p>映射结果如图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/case31.png" alt></p><p>2) $R = 2; \quad C = \lfloor N_{bundle}/R \rfloor = \lfloor 6/2 \rfloor = 3;\quad r = 0,1;\quad c = 0,1,2$。</p><div class="table-container"><table><thead><tr><th>c</th><th>r</th><th>j: VRB bundle</th><th>$f(j)$: PRB bundle</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>3</td></tr><tr><td>1</td><td>0</td><td>2</td><td>1</td></tr><tr><td>1</td><td>1</td><td>3</td><td>4</td></tr><tr><td>2</td><td>0</td><td>4</td><td>2</td></tr><tr><td>2</td><td>1</td><td>5</td><td>5</td></tr></tbody></table></div><p>映射结果如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/case32.png" alt></p><h1 id="2-PDSCH-DMRS"><a href="#2-PDSCH-DMRS" class="headerlink" title="2 PDSCH DMRS"></a>2 PDSCH DMRS</h1><h2 id="2-1-序列生成"><a href="#2-1-序列生成" class="headerlink" title="2.1 序列生成"></a>2.1 序列生成</h2><p>PDSCH DMRS序列有如下公式生成：</p><script type="math/tex;mode=display">r(n) = \frac{1}{\sqrt{2}}(1-2\cdot c(2n))+j\frac{1}{\sqrt{2}}(1-2\cdot c(2n+1))</script><p>加扰序列采用31阶Gold序列生成，加扰序列的初始序列$c_{init}$如下式所示:</p><script type="math/tex;mode=display">c_{init} = (2^{17}(N_{symb}^{slot}n_{s,f}^{\mu}+l+1)(2N_{ID}^{n_{SCID}}+1)+2N_{ID}^{n_{SCID}}+n_{SCID})mod2^{31}</script><p>其中：</p><ul><li>$l$ 为时隙中的符号索引</li><li>$n_{s,f}$ 为时隙索引</li><li>$N_{symb}^{slot}$ 为一个时隙内的符号数量</li><li>$n_{SCID},N_{ID}^{n_{SCID}}$ :<br><strong>1) 对于C-RNTI/MCS-C-RNTI/CS-RNTI</strong><br>① DCI format 1_1 , $n_{SCID}$ 可由DMRS-DownlinkConfig IE中scramblingID0,scramblingID1配置,可以在$N_{ID}^0,N_{ID}^1$之间选择,$N_{ID}^{0},N_{ID}^{1}\in \{0,1,…,65535\}$。<br>② DCI format 1_1 , $n_{SCID}$ 可由DMRS-DownlinkConfig IE中scramblingID0配置,可以在$N_{ID}^0$之间选择,$N_{ID}^{0}\in \{0,1,…,65535\}$。<br>③ 如果①DMRS-DownlinkConfig IE中scramblingID0,scramblingID1都未配置,则$n_{SCID}=0,N_{ID}^{n_{SCID}}=N_{ID}^{cell}$。<br>④ 如果②DMRS-DownlinkConfig IE中scramblingID0未配置，则$n_{SCID}=0,N_{ID}^{n_{SCID}}=N_{ID}^{cell}$。<br><strong>２) 对于SI-RNTI/P-RNTI/RA-RNTI</strong><br>$n_{SCID}=0,N_{ID}^{n_{SCID}}=N_{ID}^{cell}$。</li></ul><p>高层配置参数DMRS-DownlinkConfig内容如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/DMRS-DLconfig.png" alt></p><h2 id="2-2-PDSCH-DMRS-频域位置"><a href="#2-2-PDSCH-DMRS-频域位置" class="headerlink" title="2.2 PDSCH DMRS 频域位置"></a>2.2 PDSCH DMRS 频域位置</h2><p>DMRS映射方式分为Configuration type 1 和configuration type 2 两种，有DMRS-DownlinkConfig中的drms-type指示，如果未配置，则默认为Configuration type 1。<br>序列映射到RE的公式如下所示：</p><script type="math/tex;mode=display">\alpha_{k,l}^{p,\mu}=\beta_{PDSCH}^{DMRS}w_f(k')w_t(l')r(2n+k')\\k = \begin{cases}4n+2k'+\Delta \quad \quad Configuration\quad type\quad1\\6n+k'+\Delta\quad \quad Configuration\quad type\quad 2 \end{cases}\\k'=0,1\\l=\overline{l}+l'\\n = 0,1,...</script><p>$k$为频域指示，$l$为时域指示。Configuration type 1 和configuration type 2，分别用于支持单用户MIMO和多用户MIMO。除此之外，由于类型1和类型2平均每个端口占用的RE数量不同，即每个端口的RE密度不同，所以各自有不同的适用场景。类型1更适合低信噪比、频域选择性较高的场景，类型2更适合高信噪比、时延扩展较小的场景。</p><p>频域指示$k$的参考点分两种情况：</p><ul><li>承载SIB1的PDSCH的DMRS，$k$的参考点为CORESET#0的RE0；</li><li>其余情况参考点为CRB#0的RE0即point A。</li></ul><p>以下图示分别展示了Configuration type 1 和configuration type 2两种情况下的DMRS频域位置，为了方便只选取了1RB左右大小，都是single symbol。<br>Configuration type 1：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/DMRS频域分析1.png" alt></p><p></p><p>Configuration type 2:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/DMRS频域分析2.png" alt></p><h2 id="2-3-PDSCH-DMRS-的符号位置"><a href="#2-3-PDSCH-DMRS-的符号位置" class="headerlink" title="2.3 PDSCH DMRS 的符号位置"></a>2.3 PDSCH DMRS 的符号位置</h2><p>DMRS的符号位置取决于PDSCH的mapping type，分为mapping type A和mapping type B，参考表格或者配置可以获得PDSCH的mapping type，以及对应的$k_0,S,L$。[TS 38.214 5.1.2.1]<br><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/Table5.1.2.1-1.png" alt><br><br>时域指示$l$的参考点分两种情况：</p><ul><li>PDSCH mapping type A：时域指示$l$的参考点为时隙的起始symbol，且DM-RS的第一个符号位置为3或4(表中S = 2，3)，由MIB中参数dmrs-TypeA-Position指示，主要考虑PDCCH的具体配置。</li><li>PDSCH mapping type B时，$l$的参考点为PDSCH的起始symbol，DM-RS从PDSCH调度区域的第一个符号开始传输。<br>两种情况如下图所示：<br>例子一：type A，$S = 3 , L = 7$, $l_0$ 的大小是与参考点的差值，表示DMRS的初始符号。</li></ul><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/DMRS时域1.png" alt></p><p>例子二：type B，$S = 6 , L = 4$, $l_0$ 的大小是与参考点的差值，表示DMRS的初始符号。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/DMRS时域2.png" alt></p><h2 id="2-4-DMRS-符号类型"><a href="#2-4-DMRS-符号类型" class="headerlink" title="2.4 DMRS 符号类型"></a>2.4 DMRS 符号类型</h2><p>DMRS两个symbol类型，single symbol 和 double symbol。取决于DMRS-DownlinkConfig中的maxLength参数的配置，maxLength配置为len1，则取值为len1（single-symbol）；如果配置为len2（double-symbol）。如果高层参数maxLength没有配置，则为single类型。</p><h2 id="2-5-添加导频"><a href="#2-5-添加导频" class="headerlink" title="2.5 添加导频"></a>2.5 添加导频</h2><p>在NR中的中/高速场景中，为了保证估计精度，除了前置导频(前文所描述的DMRS)外，加入了与前置导频TDM的附加导频，附加DM-RS结构与前置DM-RS的图样相同，在double symbol DM-RS情况下，最多可以配置1组附加导频，在single symbol前置DM-RS情况下最多可以配置3组附加导频。附加导频的数量与调度时长有关，时域位置由高层参数dmrs-AdditionalPosition指示,如下表所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/添加导频单符号.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/添加导频双符号.png" alt></p><p>当PDSCH mapping type B时，如果PDSCH的资源和CORESET相重叠，则PDSCH DM-RS要往后顺延到紧挨CORESET的后面，此时，如果PDSCH的duration为2时，DM-RS的起始位置不能超过PDSCH的第二个symbol，当PDSCH的duration为4时，DM-RS的起始位置不能超过PDSCH的第3个symbol，当PDSCH的duration为7时，DM-RS的第一个symbol不能超过PDSCH的第4个symbol。<br>(Note: 以上所说的PDSCH的duration，也就是$L$，同时也是$l_d$ ，都是一个意思)<br><br>举个例子来说明上面两个表的意思：<br>$S = 2,L=11$,maxLength配置为len1，即为single symbol ,按照第一个 表格，如果此时$l_d = 11$ PDSCH mapping type A , dmrs-AdditionalPosition指示为2，则代表在DMRS导频位置分别在DMRS初始位置$l_0$(若为$l_0=2$),#6,#9符号上。如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/添加导频例子.png" alt></p><h2 id="2-6-端口映射"><a href="#2-6-端口映射" class="headerlink" title="2.6 端口映射"></a>2.6 端口映射</h2><p>结合PDSCH DMRS序列生成及映射公式，以及下表可知：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/Table7.4.1.1.2-12.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/Table7.4.1.1.2-5.png" alt></p><ul><li>type 1，single symbol情况下，最多支持4个端口，端口0，1和2，3分别在不同的CDM group，每个CDM group内，比如端口0和1，又通过频域的OCC来实现正交，从而实现4个端口的正交。</li><li>type 1，double symbol情况下，最多支持8个端口，除了频域OCC外，还可以时域OCC来实现正交，所以可以支持更多的端口。</li><li>type 2，single symbol情况下，最多支持6个端口，共三个CDM group，每个group内又通过频域OCC实现正交。</li><li>type 2，double symbol情况下，最多支持12个端口，与类型1双符号情况同理，除了频域OCC外，还可以时域OCC，从而支持更多的端口。</li></ul><p>问题：端口，层方面</p><h1 id="3-PDSCH-PTRS"><a href="#3-PDSCH-PTRS" class="headerlink" title="3 PDSCH PTRS"></a>3 PDSCH PTRS</h1><h2 id="3-1-相位噪声"><a href="#3-1-相位噪声" class="headerlink" title="3.1 相位噪声"></a>3.1 相位噪声</h2><p>相位噪声指射频器件在各种噪声（如随机性白噪声、闪烁噪声）的作用下引起的系统输出信号相位的随机变化。相位噪声会恶化接收端的SNR（Signal-Noise Ratio信噪比）或EVM（Error Vector Magnitude误差向量幅度），造成大量的误码，这样就限制了高阶调制的使用，会严重影响系统的容量。<br>相对来说，相位噪声对低频段，也就是sub6G频段的影响较小一些。而高频段（毫米波）下，由于参考时钟源的倍频次数大幅增加以及器件的工艺水平和功耗等各方面的原因，相位噪声的影响也是大幅增加。<br>为了应对高频段下的相位噪声，除了增大子载波间隔、提高器件质量之外，5G NR引入了PT-RS（Phase Tracking Reference Signal）信号以及相位估计补偿算法。</p><h2 id="3-2-序列生成"><a href="#3-2-序列生成" class="headerlink" title="3.2 序列生成"></a>3.2 序列生成</h2><p>生成序列方式与PDSCH DMRS相同。</p><h2 id="3-3-高层配置"><a href="#3-3-高层配置" class="headerlink" title="3.3 高层配置"></a>3.3 高层配置</h2><p>下行是否配置了PT-RS，由DMRS-DownlinkConfig中的字段phaseTrackingRS来决定，如果该字段缺省或配置为released，则表示下行没有PT-RS信号。PT-RS的具体配置在PTRS-DownlinkConfig中：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/PTRS.png" alt></p><p><strong>frequencyDensity</strong><br>frequencyDensity提供了两个值，这两个值都在（1,276）的范围内，分别对应了[TS 38.214-Table5.1.6.3-2]中的$N_{RB0},N_{RB1}$，UE再通过DCI中的调度RB数查询该表，就可以确定PT-RS的频域密度$K_{PT−RSK}$ 。如果调度RB数过少，即$N_{RB}&lt;N_{RB0}$ 时，PT-RS的系统开销相对来说就太大了，这个时候下行没有PT-RS信号。</p><div class="table-container"><table><thead><tr><th style="text-align:center">scheduled bandwidth</th><th style="text-align:center">Frequency density ($K_{PT-RS}$)</th></tr></thead><tbody><tr><td style="text-align:center">$N_{RB}&lt;N_{RB0}$</td><td style="text-align:center">PT-RS is not present</td></tr><tr><td style="text-align:center">$N_{RB0}&lt;N_{RB}&lt;N_{RB1}$</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">$N_{RB1}&lt;N_{RB}$</td><td style="text-align:center">4</td></tr></tbody></table></div><p><strong>timeDensity</strong><br>timeDensity提供了三个范围在（0,29）的值，分别对应[TS 38.214-Table5.1.6.3-1]中的ptrs-MCS1、ptrs-MCS2、ptrs-MCS3，UE再通过DCI中的调度MCS信息就可以确定PT-RS的时域密度(间隔)$L_{PT−RS}$，表中的ptrs-MCS4没有在高层参数中明确配置，UE可以假定该值为当前可使用的最大MCS+1。</p><div class="table-container"><table><thead><tr><th style="text-align:center">scheduled MCS</th><th style="text-align:center">Time density ($L_{PT-RS}$)</th></tr></thead><tbody><tr><td style="text-align:center">$ptrs-MCS1\leq l_{MCS}&lt;ptrs-MCS2$</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">$ptrs-MCS2\leq l_{MCS}&lt;ptrs-MCS3$</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">$ptrs-MCS3\leq l_{MCS}&lt;ptrs-MCS4$</td><td style="text-align:center">1</td></tr></tbody></table></div><p><strong>epre-Ratio</strong><br>epre-Ratio通过[TS 38.214-Table4.1-2] 确定了PT-RS端口每层每个RE上PT-RS EPRE与PDSCH EPRE的比例，这个比例叫$\rho _{PTRS}$, 它与$\beta_{PTRS}$ 的关系为：$\beta_{PTRS}=10^{\frac {\rho_{PTRS}}{20}}$。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/PTRS参数.png" alt></p><p><strong>resourceElementOffset</strong> 见下文表格中参数，取值为{00,01,10,11}。</p><h2 id="3-4-资源映射"><a href="#3-4-资源映射" class="headerlink" title="3.4 资源映射"></a>3.4 资源映射</h2><p>如果PTRS存在，UE将按照按$\beta_{PT_RS}$缩放，并映射到资源单元中：</p><script type="math/tex;mode=display">\alpha_{k,l}^{p,\mu} = \beta_{PT-RS}\cdot r_k</script><h3 id="3-4-1-时域索引"><a href="#3-4-1-时域索引" class="headerlink" title="3.4.1 时域索引"></a>3.4.1 时域索引</h3><p>确定时域索引$l$的步骤如下：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set i &#x3D; 0 and l_&#123;ref&#125;&#x3D;0  </span><br><span class="line">if l_&#123;ref&#125;+iL_&#123;PTRS&#125;  overlaps with a symbol used for DM-RS according to clause 7.4.1.1.2</span><br><span class="line">- set i &#x3D; 1 </span><br><span class="line">- set l_&#123;ref&#125; to the number of the last DM-RS symbol in a sequence of time-contiguous DM-RS occasions</span><br><span class="line">add l_&#123;ref&#125; + iL_&#123;PTRS&#125; to the set of time indices for PT-RS</span><br><span class="line">increment  i by one</span><br><span class="line">repeat from step 2 above as long as l_&#123;ref&#125;+iL_&#123;PTRS&#125; is inside the PDSCH allocation</span><br></pre></td></tr></table></figure><p></p><p>简而言之，PT-RS时域的的范围，从调度的PDSCH的第一个符号开始，避开DMRS所在的位置，以$L_{PT−RS}$为间隔，一直到PDSCH结束。$L_{PT-RS}$不仅是PT-RS之间的间隔，还是与DMRS最后一个符号之间的间隔。如下图所示：<br>图中 仅选取了$1 RB*14 symbol$ 资源单元 ， $l_0 = 2 , L_{PT-RS} = 2$ , single symbol类型。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/PTRS时域图.png" alt></p><h3 id="3-4-2-频域索引"><a href="#3-4-2-频域索引" class="headerlink" title="3.4.2 频域索引"></a>3.4.2 频域索引</h3><p>首先，假定分配给PDSCH的RB为从0到$N_{RB}-1$，那么分配给PDSCH的子载波范围就是0-$N_{sc}^{RB}N_{RB}-1$。最终PTRS频域索引$k$，由下面公式得到：</p><script type="math/tex;mode=display">k=k_{ref}^{RE}+(iK_{PT-RS}+k_{ref}^{RB})N_{sc}^{RB}\\k_{ref}^{RB}= \begin{cases}n_{RNTI}modK_{PT-RS} \quad \quad \quad if N_{RB}modK_{PT-RS} = 0 \\n_{RNTI}mod(N_{RB}modK_{PT-RS})\quad \quad otherwise\end{cases}</script><p>$k_{ref}^{RE}$ 由下表获得[TS 38.311-Table 7.4.1.2.2-1]：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/频域索引.png" alt></p><p>由上可知，$K_{PT-RS}$为相邻 PTRS之间间隔的RB数，即相邻 PTRS之间相差$K_{PT-RS}\cdot N_{sc}^{RB}$ 个子载波，第一个PTRS 子载波定位是 $k_{ref}^{RE}+（0K_{PT-RS}+k_{ref}^{RB}）N_{sc}^{RB}$ 。大概的图样如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDSCH%E5%AD%A6%E4%B9%A0/PTRS频域图.png" alt></p><blockquote><p>主要参考：<br>博客：<a href="https://blog.csdn.net/littleBird_2/article/details/89408575" target="_blank" rel="noopener">https://blog.csdn.net/littleBird_2/article/details/89408575</a> (PDSCH)<br>博客：<a href="https://blog.csdn.net/kakamilan/article/details/104535554" target="_blank" rel="noopener">https://blog.csdn.net/kakamilan/article/details/104535554</a> (PDSCH-DMRS)<br>博客：<a href="https://blog.csdn.net/m0_45416816/article/details/103807853" target="_blank" rel="noopener">https://blog.csdn.net/m0_45416816/article/details/103807853</a> (PDSCH-DMRS)<br>博客：<a href="https://blog.csdn.net/littleBird_2/article/details/89683712" target="_blank" rel="noopener">https://blog.csdn.net/littleBird_2/article/details/89683712</a> (PDSCH-PTRS)<br>网页：<a href="http://www.sharetechnote.com" target="_blank" rel="noopener">http://www.sharetechnote.com</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>PDSCH</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-PDCCH学习</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Mon May 04 2020 17:17:36 GMT+0800 (GMT+08:00) --><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>PDCCH信道主要承载的是DCI信息。不同的调度信息以DCI format区分，DCI format种类包括以下几种，用于调度PUSCH、PDSCH、TPC、SFI等 [TS 38.212 7.3.1]。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/DCI表格.png" alt></p><p>PDCCH传输过程主要如下图所示:</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_01.png" alt></p><p>[TS 38.212 7.3] 中DCI的主要处理过程如下。</p><blockquote><ol><li>Information Element Multiplexing</li><li>CRC Attachment</li><li>Polar Coding</li><li>Rate Matching</li><li>Scrambling</li><li>Modulation</li><li>Resource Element Mapping</li></ol></blockquote><p>下图是一个更加详细的过程：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_02.png" alt></p><h1 id="2-PDCCH-Transport-Process"><a href="#2-PDCCH-Transport-Process" class="headerlink" title="2 PDCCH Transport Process"></a>2 PDCCH Transport Process</h1><h2 id="2-1-Information-Element-Multiplexing"><a href="#2-1-Information-Element-Multiplexing" class="headerlink" title="2.1 Information Element Multiplexing"></a>2.1 Information Element Multiplexing</h2><p>信息元素多路复用这是生成承载各种控制和调度信息的DCI的位串的过程[TS 38.212 7.3]。如果DCI数据长度小于12比特，则填充比特0作为padding。<br>每个字段都按照其在说明中出现的顺序进行映射，包括零填充位（如果有），其中第一个字段映射到最低顺序信息位，每个连续字段映射到较高顺序信息位。 每个字段的最高有效位映射到该字段的最低顺序信息位，例如第一个字段的最高有效位映射到$a_0$。</p><h2 id="2-2-CRC-Attachment"><a href="#2-2-CRC-Attachment" class="headerlink" title="2.2 CRC Attachment"></a>2.2 CRC Attachment</h2><h3 id="2-2-1-CRC-Attach"><a href="#2-2-1-CRC-Attach" class="headerlink" title="2.2.1 CRC Attach"></a>2.2.1 CRC Attach</h3><p>通过循环冗余校验（CRC）在DCI 传输上提供错误检测 [TS 38.212 7.3.2] ，操作流程如下图所示，其中最开始添加的24位数据全是1。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_CRC_01.png" alt></p><h3 id="2-2-2-Masking-with-RNTI"><a href="#2-2-2-Masking-with-RNTI" class="headerlink" title="2.2.2 Masking with RNTI"></a>2.2.2 Masking with RNTI</h3><p>在添加CRC后，最后16位被特定的RNTI加扰。使用该RNTI，UE可以确定DCI是针对哪个UE以及DCI的用途。 [TS 38.212 7.3.2]，操作流程如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_RNTI_Masking_01.png" alt></p><h2 id="2-3-Polar-Coding"><a href="#2-3-Polar-Coding" class="headerlink" title="2.3 Polar  Coding"></a>2.3 Polar Coding</h2><p>信息比特被传送到信道编码块<br>如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_ChannelCoding_01.png" alt></p><h2 id="2-4-Rate-Matching"><a href="#2-4-Rate-Matching" class="headerlink" title="2.4 Rate Matching"></a>2.4 Rate Matching</h2><p>速率匹配的输入比特序列是 $d_0,…,d_{N-1}$，通过设置根据 [TS 38.212 5.4.1] 执行速率匹配 $I_{BIL} = 0$，速率匹配后的输出比特序列表示为 $f_0,…,f_{E-1}$。<br>如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_RateMatching_01.png" alt></p><h2 id="2-5-Scrambling"><a href="#2-5-Scrambling" class="headerlink" title="2.5  Scrambling"></a>2.5 Scrambling</h2><h3 id="2-5-1-CCE"><a href="#2-5-1-CCE" class="headerlink" title="2.5.1 CCE"></a>2.5.1 CCE</h3><p>Rate matching根据分配给PDCCH的资源进行速率匹配，PDCCH分配的基本单位为<strong>CCE</strong>(Control Channel Element)，(1 CCE = 6 REG = 72 RE，1 REG = 1 OFDM symbol * 12 subcarrier = 12 RE)，对于一个PDCCH而言，其由一个或多个CCEs组成，而所分配的CCE数量根据聚合等级的不同而不同，换一句话说，也就是若干个CCE会聚合成PDCCH，聚合成PDCCH的CCE个数就是聚合度，PDCCH所支持的聚合等级下表所示。 [TS 38.211 7.3.1]</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/CCE.png" alt></p><h3 id="2-5-2-CORESET"><a href="#2-5-2-CORESET" class="headerlink" title="2.5.2 CORESET"></a>2.5.2 CORESET</h3><p>UE可被配置多个<strong>CORESET</strong>(Control-resource set, 控制资源集)，其位于BWP内，对于每个BWP最多被配置3个CORESET(包括common和UE-specific CORESETs)。<br>对于PDCCH而言，所传输控制信息的时频位置位于CORESET内，而一个CORESET时频位置的组成：<strong>频域</strong>由$N_{RB}^{CORESET}$个RB组成，<strong>时域</strong>由$N_{symb}^{CORESET} \in \{1,2,3\}$个符号组成。其中$N_{symb}^{CORESET} = 3$ 仅当高层参数 $dmrs-TypeA-Position = 3 $ 时才支持。<br>每个CORESET中有<strong>交织</strong>(分布式)和<strong>非交织</strong>(集中式)两种CCE-to-REG映射可选（由ControlResourceSet IE 中的高层参数cce-REGMappingType配置），但是每个CORESET仅能关联其中一种，其CCE-to-REG映射通过REG bundles描述：</p><p>- REG bundle 被定义为REG$\{iL,iL+1,…,iL+L−1\}$，其中L是REG bundle大小(由高层参数reg-BundleSize指定)，i = 0,1,…,$N_{REG}^{CORESET}/L-1$是， $N_{REG}^{CORESET}$是CORESET中REG数，$N_{REG}^{CORESET} = N_{RB}^{CORESET}\cdot N_{symb}^{CORESET}$；<br>- 最终CCE-REG的映射，是按照REG束来表示的，CCE $j$ 中包含了REG bundle ${f(6j/L),f(6j/L+1),…,f(6j/L+6/L−1)}$。</p><p>对于两种不同的映射方式，有如下描述：<br>- 非交织的 CCE to REG 映射 ， $L = 6\quad and\quad f(j) = j$<br>- 交织的 CCE to REG 映射 ，对于 $N_{symb}^{CORESET} = 1$ , $L\in \lbrace 2,6 \rbrace$；对于$N_{symb}^{CORESET} \in \lbrace 2 ,3 \rbrace$ , $L\in \lbrace N_{symb}^{CORESET} ,6 \rbrace$；$l$由高层参数reg-BundleSize配置。<br>交织器定义如下：</p><script type="math/tex;mode=display">f(j) = (rC+c+n_{shift})mod(N_{REG}^{CORESET}/L)\\j = cR+r\\r = 0,1,...,R-1\\c = 0,1,...,C-1\\C = N_{REG}^{CORESET}/(LR)</script><p>其中 $R\in \{2,3,6 \}$由高层参数interleaverSize给出。对于$n_{shift}$:</p><ul><li>对于PBCH或SIB1配置的CORESET中发送的PDCCH，$n_{shift} = N_{ID}^{cell}$</li><li>除此之外，$n_{shift}\in\{ 0,1,…,274 \}$ 由高层参数shiftIndex给出。</li></ul><p>对于交织和非交织方式，利用直观的例子说明操作过程，例子参考文献中摘抄。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/例子1.png" alt></p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/例子2.png" alt></p><ul><li>如果高层参数precoderGranularity = sameAsREG-bundle，则在REG bundle内使用相同的预编码</li><li>如果高层参数precoderEranularity = allContiguousRBs，则在CORESET中的连续资源块集合中的所有资源单元组中使用相同的预编码</li></ul><p>对于由 PBCH配置的 CORESET，UE可以假设交织映射，$ L = 6 , R = 2$ ，以及在 REG bundle中使用的相同预编码。 [TS 38.211 7.3.2.1]</p><h3 id="2-5-3-Scrambling"><a href="#2-5-3-Scrambling" class="headerlink" title="2.5.3 Scrambling"></a>2.5.3 Scrambling</h3><p>UE应采用比特块 $b(0),…,b(M_{bit} -1)$ ($M_{bit}$ 是在物理信道上发送的比特数)，在调制之前被加扰，产生一个加扰比特块 $\widetilde b(0),…,\widetilde b(M_{bit})$ ，根据如下方式加扰：</p><script type="math/tex;mode=display">\widetilde b(i) = (b(i)+c(i))mod2</script><p>其中加扰序列 $c(i)$ 在[TS 38.211 5.2.1]给出，由$Gold$ 序列生成，此时初始化为 $c_{init} $由以下得出：</p><script type="math/tex;mode=display">c_{init} = (n_{RNTI}\cdot 2^{16} + n_{ID})mod2^{31}</script><p>对于$n_{ID}$：<br>- $n_{ID}\in \{0,2,…,65535\}$ = $pdcch-DMRS-ScramnlingID$ (如果已配置) ；<br>- 除此之外 $n_{ID} = N_{ID}^{cell}$。 [TS 38.213]</p><p>对于$n_{RNTI}$：<br>- 如果配置了高层参数 pdcch-DMRS-ScramnlingID，则由C-RNTI给出$UE$特定搜索空间；<br>- 除此之外$n_{RNTI} = 0$。</p><p>整体的流程如下图所展示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_Scrambling_01.png" alt></p><h2 id="2-6-Modulation"><a href="#2-6-Modulation" class="headerlink" title="2.6 Modulation"></a>2.6 Modulation</h2><p>UE应采用比特块 $\widetilde b(0),…,\widetilde b(M_{bit})$按照如[TS 38.211 5.1.3]所述进行 QPSK调制，得到一个复值调制符号块 $d(0),…,d(M_{bit} -1)$。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/NR_PDCCH_Modulation_01.png" alt></p><h2 id="2-7-Resource-Element-Mapping"><a href="#2-7-Resource-Element-Mapping" class="headerlink" title="2.7 Resource Element Mapping"></a>2.7 Resource Element Mapping</h2><p>在用于被监视PDCCH的资源元素组中，UE将假定复数值符号块$\{d(0),…,d(M_{symb}-1))\}$将按比例因子$\beta_{PDCCH}$缩放并映射到资源单元$(k,l)_{p,\mu}$中，其顺序为先是时域，然后是频域，天线端口号$p = 2000$。</p><h2 id="2-8-PDCCH-DMRS"><a href="#2-8-PDCCH-DMRS" class="headerlink" title="2.8 PDCCH DMRS"></a>2.8 PDCCH DMRS</h2><h3 id="2-8-1-Sequence-generation"><a href="#2-8-1-Sequence-generation" class="headerlink" title="2.8.1 Sequence generation"></a>2.8.1 Sequence generation</h3><p>UE应采用如下方式定义参考信号序列$r_l(m)$：</p><script type="math/tex;mode=display">r_l(m) = \frac{1}{\sqrt{2} }(1-2*c(2m)) + j\frac{1}{\sqrt{2} }(1-2*c(2m+1))</script><p>加扰序列 $c(i)$ 在[TS 38.211 5.2.1]给出，由$Gold$ 序列生成，此时初始化为 $c_{init} $由以下得出：</p><script type="math/tex;mode=display">c_{init} = (2^{17}(14n_{s,f}^\mu+l+1)(2N_{ID}+1)+2N_{ID})mod2^{31}</script><p>其中：$l$ 是$slot$ 内OFDM符号编号，$n_{s,f}^\mu$ 是帧内的 $slot$ 号</p><p>对于$n_{ID}$：<br>- $n_{ID}\in \{0,2,…,65535\}$ = $pdcch-DMRS-ScramnlingID$ (如果已配置)；<br>- 除此之外 $n_{ID} = N_{ID}^{cell}$。 [TS 38.213]</p><h3 id="2-8-2-Resource-Element-Mapping"><a href="#2-8-2-Resource-Element-Mapping" class="headerlink" title="2.8.2 Resource Element Mapping"></a>2.8.2 Resource Element Mapping</h3><p>$UE$ 将$r_l(m)$ 映射到资源单元$(k,l)_{p,\mu}$ ，根据如下：</p><script type="math/tex;mode=display">\alpha_{k,l}^{p,\mu} = \beta_{DMRS}^{PDCCH}\cdot r_l(3n+k')\\ k = nN_{sc}^{RB}+4k'+1\\ k' = 0 ,1,2\\ n = 0,2,...</script><p>可以看出，每个RB上有3个DMRS RE，分别位于$4k’+1$ 的位置，即1、5、9号子载波。<br>$l$ 指在一个时隙内的OFDM符号；天线端口 $p$ 固定为2000。</p><p>对于precoderGranularity：<br>- 如果配置为 sameAsREG-bundle，那么该CORESET对应的DMRS仅在UE需要检测PDCCH的REG上；<br>- 如果配置为allContiguousRBs，则在组成CORESET的REG上都有DMRS映射。</p><p>对于参考点$k$：<br>- 如果CORCHET由PBCH或SIB1配置，则为CORESET中编号最小的资源块的子载波0，<br>- 否则，为公共资源块0中的子载波0</p><p>上述描述由下图可直观表示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-PDCCH%E5%AD%A6%E4%B9%A0/DMRS参考点.png" alt></p><blockquote><p>主要参考：<br>微信公众号：5G菜鸟成长日记<br>文章：Understanding the Heart of the 5G Air Interface: An Overview of Physical Downlink Control Channel for 5G New Radio (NR)<br>博客：<a href="https://blog.csdn.net/qq_33206497/article/details/89645976" target="_blank" rel="noopener">https://blog.csdn.net/qq_33206497/article/details/89645976</a><br>博客：<a href="https://blog.csdn.net/littleBird_2/article/details/88372875" target="_blank" rel="noopener">https://blog.csdn.net/littleBird_2/article/details/88372875</a><br>网页：<a href="http://www.sharetechnote.com/html/5G/5G_PDCCH.html#Ref_01" target="_blank" rel="noopener">http://www.sharetechnote.com/html/5G/5G_PDCCH.html#Ref_01</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>PDCCH</tag>
      </tags>
  </entry>
  <entry>
    <title>5G-NR-SSB学习</title>
    <url>/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Mon May 04 2020 17:17:36 GMT+0800 (GMT+08:00) --><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>SS/PBCU Block简称SSB，主要包含PSS、SSS以及PBCH。对于SSB的学习，主要采用如下步骤来学习，并加深理解的：</p><blockquote><ol><li>NR SSB 时域频域分析</li><li>PSS/SSS序列</li><li>PBCH payload 生成及处理</li><li>PBCH加扰/调制/RE映射</li><li>PBCH DMRS</li><li>UE SSB处理过程</li><li>同步过程理解</li></ol></blockquote><h1 id="二、学习进程"><a href="#二、学习进程" class="headerlink" title="二、学习进程"></a>二、学习进程</h1><h2 id="2-1-NR-SSB-时域频域分析"><a href="#2-1-NR-SSB-时域频域分析" class="headerlink" title="2.1 NR SSB 时域频域分析"></a>2.1 NR SSB 时域频域分析</h2><p>PSS和SSS主要用于UE获得时间同步和频率同步，获取小区ID；PBCH用于无线帧号同步以及SIB1的配置。与LTE的差异主要在于SSS序列都一样，不存在前后5 ms的差异且SSB的周期是可配置的，以及引入了beam index的概念。</p><h3 id="2-1-1-SSB时域分析"><a href="#2-1-1-SSB时域分析" class="headerlink" title="2.1.1 SSB时域分析"></a>2.1.1 SSB时域分析</h3><p>在5G中，每个SSB对应一个beam， SSB的最短时间跨度为5 ms，也就是半帧。一个半帧中可能存在多个SSB，我们将一个半帧中存在的一个或多个SSB称为SS Burst Set，一个SS Burst Set中的SSB包含的信息相同。两个SS Burst Set出现的时间，也就是存在SSB的半帧出现的时间是可以配置的，成为SS Burst Set Periodicity，5 ms–160 ms范围。默认为20 ms。<br>根据[TS 38.213]中的SSB的时间分布描述，总结成如下表所示。从表中可以看到，SSB符号的起始位置取决于Case类型以及所处频段，一个SSB在时域上占据4个符号。Num为SSB的总数。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/1.png" alt></p><p>以Case A，小于等于3 GHz为例，其符号位置如下图所示，SSB总数为4，各个SSB代表了不同的波束方向。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/2.png" alt></p><p>SSB的Case由Band决定，[TS 38.104]中规定</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/3.jpg" alt></p><h3 id="2-1-2-SSB频域分析"><a href="#2-1-2-SSB频域分析" class="headerlink" title="2.1.2 SSB频域分析"></a>2.1.2 SSB频域分析</h3><p>由上一节可知SSB时域是由4个symbol组成，而频域是由20个RB，也即240个子载波构成，它包含着set 0 ,PSS,SSS,PBCH,DMRS,结构如下表所示</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/4.png" alt></p><p>综合以上，下图更直观的显示SSB时域频域分布，横轴为频域，纵轴为时域。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/5.png" alt></p><p>与LTE中PSS和SSS固定在带宽的中间73个子载波不同，NR中SSB可能的频域位置有很多。NR中有一系列全局同步信道号GSCN，每个GSCN都会对应一个确定的、绝对的频率位置，系统会把SSB放在这些GSCN上，对齐方式为SSB的10号RB的0号子载波与GSCN对齐，UE就会在这些GSCN上挨个盲检SSB。</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/GSCN.png" alt></p><p>不同的operating band是分配给不同运营商的，所以UE是知道自己处在哪个operating band上的，比如n28分配给广电的，那么接入广电网络的UE在搜索SSB的时候，就盲检1901 – $&lt;$1$&gt;$ – 2002这个范围内的GSCN(参考2.1.1表格)，并且只搜索15kHz子载波间隔、case A下的SSB。</p><p>确定整个CRB中SSB所处于的位置，需要通过$K_{ssb}$和CORESET#0相应的offsetRB来确定。[TS 38.211]中$K_{ssb}$来表示公共资源快$N_{CRB}^{SSB}$子载波0相对SSB子载波0的偏移。$K_{SSB}$的低4bit由MIB参数中的ssb-SubcarrerOffset给出。<br>对于SSB类型B，即（μ= 3 or 4）来说,$K_{SSB}$={0,…,11}, 4 bit足够。<br>对于SSB类型A，即（μ= 0 or 1）来说, $K_{SSB}$={0,…,23}, 4 bit不够，需要5 bit来表示，因此使用PBCH payload中$a_{\overline A+5}$来表示高比特位。下文会说明。<br>最终SSB在整个CRB中的位置如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/6.png" alt></p><h2 id="2-2-PSS-SSS序列"><a href="#2-2-PSS-SSS序列" class="headerlink" title="2.2 PSS/SSS序列"></a>2.2 PSS/SSS序列</h2><h3 id="2-2-1-PCI"><a href="#2-2-1-PCI" class="headerlink" title="2.2.1 PCI"></a>2.2.1 PCI</h3><p>PCI(Physical Cell Identifier)，物理小区标识，$N_{ID}^{cell}$定义如下：</p><script type="math/tex;mode=display">N_{ID}^{cell} = 3N_{ID}^{(1)} + N_{ID}^{(2)}\\N_{ID}^{cell}\in\lbrace 0,1,...,1007\rbrace\\N_{ID}^{(1)}\in\lbrace 0,1,...,355\rbrace\\N_{ID}^{(2)}\in \lbrace 0,1,2\rbrace</script><h3 id="2-2-2-PSS"><a href="#2-2-2-PSS" class="headerlink" title="2.2.2 PSS"></a>2.2.2 PSS</h3><p>PSS(Primary Synchronization Signal)，主同步信号，序列定义如下：</p><script type="math/tex;mode=display">d_{pss}(n) = 1 - 2x(m)\\m = (n + 43N_{ID}^{(2)})mod127\\0 ≤ n < 127</script><p>$x(m)$由如下序列得出：</p><script type="math/tex;mode=display">x(i+7) = (x(i+4)+x(i))mod2\\ [x(6)\quad x(5)\quad x(4)\quad x(3)\quad x(2)\quad x(1)\quad x(0)] = [1\quad 1\quad 1\quad 0\quad 1\quad 1\quad 0]</script><p>PSS部分映射在SSB中间12个RB上,占用144个子载波，PSS序列映射在56-182，前8个和后9个为保护间隔(guard band)。</p><h3 id="2-2-3-SSS"><a href="#2-2-3-SSS" class="headerlink" title="2.2.3 SSS"></a>2.2.3 SSS</h3><p>SSS(Secondary Synchronization Signal)，辅同步信号，序列定义如下：</p><script type="math/tex;mode=display">d_{sss}(n) = [1 - 2x_0((n + m_0)mod127)][1 - 2x_1((n + m_1)mod127)]\\m_0 = 15[\frac{N_{ID}^{(1)}}{112}] + 5N_{ID}^{(2)}\\m_1 = N_{ID}^{(1)}mod112\\0\quad \leq n < 127</script><p>$x_1(m)$和$x_2(m)$由如下序列得出：</p><script type="math/tex;mode=display">x_0(i+7) = (x_0(i+4)+x_0(i))mod2\\ x_1(i+7) = (x_1(i+1)+x_1(i))mod2\\ [x_0(6)\quad x_0(5)\quad x_0(4)\quad x_0(3)\quad x_0(2)\quad x_0(1)\quad x_0(0)] = [0\quad 0\quad 0\quad 0\quad 0\quad 0\quad 1]\\ [x_1(6)\quad x_1(5)\quad x_1(4)\quad x_1(3)\quad x_1(2)\quad x_1(1)\quad x_1(0)] = [0\quad 0\quad 0\quad 0\quad 0\quad 0\quad 1]</script><p>SSS与PSS相同，映射在SSB中间12个RB上,占用144个子载波，PSS序列映射在56-182，前8个和后9个为保护间隔(guard band)。</p><h2 id="2-3-PBCH-payload-生成及处理"><a href="#2-3-PBCH-payload-生成及处理" class="headerlink" title="2.3 PBCH payload 生成及处理"></a>2.3 PBCH payload 生成及处理</h2><p>PBCH payload 组成如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/7.png" alt></p><h3 id="2-3-1-BCCH"><a href="#2-3-1-BCCH" class="headerlink" title="2.3.1 BCCH"></a>2.3.1 BCCH</h3><p>BCCH共24比特，其中B如果指示的是MIB信息，其中MIB信息只有23比特。看[TS 38.311 ]中的BCCH-BCH-Message结构，其中有1比特Choice指示，指示是mib还是messageClassExtension。<br>MIB的内容如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/8.png" alt></p><p><strong>systemFrameNumer</strong>- 无线帧号指示，这里只有6比特，还有4比特在PBCH payload中添加; <strong>6 bit</strong><br><strong>subCarrierSpacingCommon</strong> - 指示SIB1的子载波间隔，FR1为15KHz或60KHz，FR2为30KHz或120KHz; <strong>1 bit</strong><br><strong>ssb-SubcarrerOffset</strong><br>是距离SSB底部距离RB边界位置的偏移$K_{SSB}$, <strong>4 bit</strong><br>对于FR2来说, $K_{SSB}$={0,…,11}足够<br>对于FR1来说，$K_{SSB}$={0,…,23}不够，需要在PBCH payload中添加一位共同指示，即$a_(A+5)$<br><strong>dmrs-TypeA Position </strong>- PUSCH/PDSCH DMRS位置参数 <strong>1 bit</strong><br><strong>pdcch-ConfigSIB1</strong>- 共8比特，确定SIB1调度的时频位置 <strong>8 bit</strong><br><strong>cellBarred</strong> - 小区是否被准许接入指示 <strong>1 bit</strong><br><strong>intraFreqReselection</strong> - 是否允许同频重选指示 <strong>1 bit</strong></p><h3 id="2-3-2-PBCH-payload中其他内容"><a href="#2-3-2-PBCH-payload中其他内容" class="headerlink" title="2.3.2 PBCH payload中其他内容"></a>2.3.2 PBCH payload中其他内容</h3><p>PBCH payload还需要加上SFN的低4比特，half-frame半帧信息（由于5ms内映射完所有SSB，需要1比特指示是在前5 ms还是后5 ms，$n_{hf}$=0时，表示前半帧；当$n_{hf}$=1，表示第二个半帧），以及3比特 SSB index(SSB index的高3比特)或者$k_{ssb}$信息（取决于SSB总数，即 NR SSB时域频域分布中根据band指示确定的SSB总数Num，或者$L_{max}$），最终PBCH payload共<strong>32比特</strong>。</p><h3 id="2-3-3-PBCH-payload-操作"><a href="#2-3-3-PBCH-payload-操作" class="headerlink" title="2.3.3 PBCH payload 操作"></a>2.3.3 PBCH payload 操作</h3><p><strong>step 1</strong> - 确定载荷中内容（由前文已知）<br><strong>step 2</strong> - reorder<br>根据比特信息重新进行排序，G(j)即为排序后的顺序。操作后 (<strong>32 比特</strong>) ，如下图所示：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/9.png" alt></p><p><strong>step 3</strong> - scrambling<br>对于确定$v$值的无线帧号对应的$2^{nd}$/$3^{rd}$ LSB，半帧信息以及SSB index不进行加扰，加扰序列每80 ms进行初始化，$L_{max}$也即SSB总数。操作后(<strong>32 比特</strong>)，如下图所示：<br><br><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/10.png" alt></p><p><strong>step 4</strong> - CRC 添加循环冗余码后输出数据长度为32+24 = <strong>56 比特</strong><br><strong>step 5</strong> - Polar Coding 输出比特长度为N = $2^9$ = <strong>512比特</strong><br><strong>step 6</strong> - Rate Matching 输出数据长度为E = <strong>864 比特</strong>（E = 864即文章NR SSB时域频域分布中的PBCH所占RE个数432乘以2）</p><h2 id="2-4-PBCH加扰-调制-RE映射"><a href="#2-4-PBCH加扰-调制-RE映射" class="headerlink" title="2.4 PBCH加扰/调制/RE映射"></a>2.4 PBCH加扰/调制/RE映射</h2><h3 id="2-4-1-加扰"><a href="#2-4-1-加扰" class="headerlink" title="2.4.1 加扰"></a>2.4.1 加扰</h3><p>加扰部分相关参数取决于小区ID与SSB index。[TS 38.211 7.3.3.1] , 加扰由以下公式得出：</p><script type="math/tex;mode=display">\widetilde{b(i)} = (b(i)+c(i+vM_{bit}))mod2</script><p>加扰序列 $c(i)$ 在[TS 38.211 5.2.1]给出，由$Gold$ 序列生成，此时初始化为 $c_{init} = N_{ID}^{cell}$。<br>-对于 $L_{max} = 4$，$v$ is the 2 LSB of SSB index ;<br>-对于 $L_{max} = 8\quad or\quad 64 $，$v$ is the 3 LSB of SSB index ;</p><h3 id="2-4-2-调制"><a href="#2-4-2-调制" class="headerlink" title="2.4.2 调制"></a>2.4.2 调制</h3><p>PBCH使用QPSK调制方式。</p><h3 id="2-4-3-映射"><a href="#2-4-3-映射" class="headerlink" title="2.4.3 映射"></a>2.4.3 映射</h3><p>参照2.1节 NR SSB时域频域分布中的PBCH数据部分的RE映射，先时域后频域。</p><h2 id="2-5-PBCH-DMRS"><a href="#2-5-PBCH-DMRS" class="headerlink" title="2.5 PBCH DMRS"></a>2.5 PBCH DMRS</h2><h3 id="2-5-1-序列生成"><a href="#2-5-1-序列生成" class="headerlink" title="2.5.1 序列生成　"></a>2.5.1 序列生成</h3><p>UE应该采用参考信号序列$r(m)$对PBCH DMRS定义，相关参数取决于小区ID，SSB index还有半帧信息来觉得。由[TS 38.211 7.4.1.4.1]给出：</p><script type="math/tex;mode=display">r(m) = \frac{1}{ \sqrt{2} }(1-2*c(2m)) + j\frac{1}{ \sqrt{2} }(1-2*c(2m+1))</script><p>加扰序列 $c(i)$ 在[TS 38.211 5.2.1]给出，由$Gold$ 序列生成，此时初始化为 $c_{init} $由以下得出：</p><script type="math/tex;mode=display">c_{init} = 2^{11}( \overline{i}_{SSB}+1)([N_{ID}^{cell}/4]+1) + 2^6( \overline{i}_{SSB}+1)) + (N_{ID}^{cell}mod4)</script><p>-对于 $L_{max} = 4$，$\overline{i}_{SSB}$ 是SSB index 的2比特最低有效位和1比特半帧信息$n_{hf}$ (构成3比特，高位是半帧信息，也即$\overline{i}_{SSB} = {i}_{SSB} + 4n_{hf}$ );<br>-对于 $L_{max} = 8\quad or\quad 64 $，$\overline{i}_{SSB}$ 是SSB index 的3比特最低有效位(也即$\overline{i}_{SSB} = {i}_{SSB}$ )<br>-以上${i}_{SSB}$也即分别对应2.4.1中的$v$。</p><h3 id="2-5-2-映射"><a href="#2-5-2-映射" class="headerlink" title="2.5.2 映射"></a>2.5.2 映射</h3><p>参照2.1节 NR SSB时域频域分布中的PBCH DMRS数据部分的RE映射，$v = N_{ID}^{cell}mod4$(此时的v不同于上文)，先时域后频域。<strong>同频邻区设置不同的偏移有利于降低导频干扰</strong>。</p><h2 id="2-6-UE-SSB处理过程"><a href="#2-6-UE-SSB处理过程" class="headerlink" title="2.6 UE SSB处理过程"></a>2.6 UE SSB处理过程</h2><p>UE的处理过程即为上述过程的一个逆过程。</p><ol><li><p>通过PSS/SSS可以获得SSB的符号起始位置，小区ID；</p></li><li><p>通过小区ID，可以获得PBCH DMRS的频域位置，PBCH DMRS携带了3比特信息，具体代表的信息取决于$L_{max}$。PSS/SSS频点信息即确定了其所属Band，也就能够确定$L_{max}$的值，那么<br>1）$L_{max} = 4$，确定SSB index以及半帧指示；<br>2）$L_{max} = 8\quad or\quad 64$，确定SSB index低3比特；</p></li><li><p>PBCH RE解映射，解调制，2.4.1节处加扰对应的第一次解扰，此处解扰通过小区ID与由步骤2中确定SSB index的比特信息可以确定；</p></li><li><p>PBCH 解速率匹配，Polar译码，CRC校验，2.3.3节处加扰对应的第二次解扰，注意到无线帧号对应的2nd/3rd LSB未进行加扰，因此可以确定加扰序列，Cinit 80ms作为一次初始化，如下图所示：</p></li></ol><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/11.png" alt></p><ol><li>解交织，确定PBCH payload；</li></ol><h2 id="2-7-同步过程理解"><a href="#2-7-同步过程理解" class="headerlink" title="2.7 同步过程理解"></a>2.7 同步过程理解</h2><p>同步过程是移动终端获得无线网络的时间和频率的过程，是终端接入网络的前提。终端要知道网络在哪个时间，哪个频率上发送什么消息，才能正确接收网络下发的信息，而同步过程就是为了使终端知道这个时间和频率信息而进行的一系列操作。这些操作与2.6节<strong>UE SSB处理过程</strong>相互重叠。更形象的流程如下：</p><p><img src="/5G%E5%8D%8F%E8%AE%AE/5G-NR-SSB%E5%AD%A6%E4%B9%A0/概念.png" alt></p><p>第一步的时间与频率同步所指的是一般意义上，我们在通信系统课程中会学到的，接收端与发射端在时间域和频率域上的同步。它并不在5G协议的规定范围之内，一般都是由芯片厂家自己实现的。这一步常用的方法有互相关检测和自相关检测等，也就是通过将接收信号与已知信号(PSS)做互相关来检测已知信号的位置，或者通过对接收信号自身做自相关来检测循环前缀（CP）的位置。<br>这一步是为了获得OFDM的符号同步（时间同步）和检测同步信号所在频率（频率同步）。</p><p>一个可能的过程：<br>1、终端将射频接收机调谐到指定频点;<br>2、在时域对PSS做<strong>互相关检测</strong>以取得时域同步，同时获得$N_{ID}^{(2)}$; (在SSB的第一个symbol时间内，SSB频域范围内只有PSS信号，因此可以对它做相关检测; 相反，因为SSS所在的第三个symbol时间内还有PBCH，所以无法对它做时域相关检测）<br>3、根据PSS的位置可以获得SSS的位置，在频域对SSS做互相关检测，可以获得频域同步并同时获得$N_{ID}^{(1)}$;<br>4、由$N_{ID}^{(1)}$; 和$N_{ID}^{(2)}$; 可以获得PCI，由PCI又可以进一步解码PBCH DMRS, 从而获得SSB index和 half frame number $n_{hf}$;<br>5、最后利用对DMRS的信道估计，终端解码PBCH并获得系统消息MIB。</p><p>这里是一个matlab对上述过程的模拟程序：</p><blockquote><p><a href="https://www.mathworks.com/help/5g/examples/NR-Synchronization-Procedures.html" target="_blank" rel="noopener">https://www.mathworks.com/help/5g/examples/NR-Synchronization-Procedures.html</a></p></blockquote><p>由上一步可知，UE SSB处理过程与同步过程如出一辙，就是为了使终端知道这个时间和频率信息而进行的一系列操作。</p><blockquote><p>主要参考：<br>微信公众号：5G菜鸟成长日记，<br>博客：<a href="https://www.cnblogs.com/beilou310/p/11162798.html" target="_blank" rel="noopener">https://www.cnblogs.com/beilou310/p/11162798.html</a><br>博客：<a href="https://blog.csdn.net/qq_44113393/article/details/89844595" target="_blank" rel="noopener">https://blog.csdn.net/qq_44113393/article/details/89844595</a><br>博客：<a href="https://blog.csdn.net/m0_45416816/article/details/96605980" target="_blank" rel="noopener">https://blog.csdn.net/m0_45416816/article/details/96605980</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>5G协议</category>
      </categories>
      <tags>
        <tag>PSS&amp;SSS</tag>
        <tag>PBCH</tag>
      </tags>
  </entry>
</search>
