<!-- build time:Wed Jun 30 2021 17:24:23 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next muse use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Server_Programming,"><meta property="og:type" content="article"><meta property="og:title" content="Linux 高性能服务器编程 examples"><meta property="og:url" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/index.html"><meta property="og:site_name" content="CongZ&#39;s Blog"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_1_result.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_2_result_too_many_users%201.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_2_result_too_many_users2.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_2_result_server.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_2_result_client.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_3_result_tcp.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_3_result_udp.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_4_result_lt.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_4_result_lt1.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_4_result_et.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_5_result.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/2_result_line.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/2_result_get_server.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/2_result_get_client.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/2_result_post_server.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/2_result_post_server.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/3_1_result.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/4_2_result_10.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/4_2_result_20.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/5_1_result_too_many_users%20(1"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/5_1_result_too_many_users%20(2"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/5_1_result_chat2.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/5_1_result_chat.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/5_1_result_kill.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/5_1_result_too_many_users%20(2"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/6_1_result.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/flowchart1.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/flowchart2.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/flowchart3.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/7_3_result_websrv_start.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/7_3_result_client_start.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/7_3_result_client_write_and_read.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/7_3_result_websrv_read_and_write.png"><meta property="og:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/WebSrv1_flowchart.png"><meta property="article:published_time" content="2021-06-30T09:25:42.000Z"><meta property="article:modified_time" content="2021-06-30T09:23:50.349Z"><meta property="article:author" content="从之丶"><meta property="article:tag" content="Server_Programming"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://czgitaccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_1_result.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:"ture",onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://czGitAccount.github.io/Server_Programming/Linux高性能服务器编程examples/"><title>Linux 高性能服务器编程 examples | CongZ's Blog</title><meta name="generator" content="Hexo 4.2.0"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">CongZ's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">择其善者而从之，其不善者而改之 !</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://czGitAccount.github.io/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="从之丶"><meta itemprop="description" content=""><meta itemprop="image" content="/images/logo.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="CongZ's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Linux 高性能服务器编程 examples</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-30T17:25:42+08:00">2021-06-30 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Server-Programming/" itemprop="url" rel="index"><span itemprop="name">Server_Programming</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">10.1k </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">42</span></div></div></header><div class="post-body" itemprop="articleBody"><div class="out-img-topic"><img src="/Server_Programming/Linux高性能服务器编程examples/美食.jpg" class="img-topic"></div><div class="post-button text-center"><div>很有食欲的样子 🤤</div></div><a id="more"></a><h1 id="Linux-高性能服务器编程-examples"><a href="#Linux-高性能服务器编程-examples" class="headerlink" title="Linux 高性能服务器编程 examples"></a>Linux 高性能服务器编程 examples</h1><h2 id="raising-hand-man-说明"><a href="#raising-hand-man-说明" class="headerlink" title=":raising_hand_man: 说明"></a>:raising_hand_man: 说明</h2><p>主要针对 <strong>《Linux 高性能服务器编程》</strong> 中一些重要的例子进行实践。</p><p>:blue_book: 实践内容如下：</p><p>:orange: <strong><font color="008F88">IO 复用</font></strong> ：</p><p>:one: <strong>select</strong> ：处理带外数据 （P148）</p><p>​ :two: <strong>poll</strong> ：聊天室程序 （P165）</p><p>​ :three: <strong>epoll</strong> ：同时处理 TCP 和 UDP 服务 （P171）</p><p>​ :four: <strong>LT 和 ET 模式</strong> ：LT 和 ET 模式（P154）</p><p>​ :five: <strong>epoll + ET + EPOLLONESHOT</strong> ：使用 EPOLLONESHOT 事件 （P157）</p><p>:lemon: <strong><font color="008F88">有限状态机</font></strong> ：HTTP 请求读取和分析 （P137）</p><p>:apple: <strong><font color="008F88">统一事件源</font></strong> ： 统一事件源 （P184）</p><p>:pineapple: <strong><font color="008F88">定时器</font></strong> ：</p><p>​ :one: 基于升序链表的定时器 （P196）</p><p>​ :two: 处理非活动连接 （P200）</p><p>:peach: <strong><font color="008F88">共享内存</font></strong> ：聊天室服务器程序（ <strong>进阶</strong> ：使用共享内存）（P255）</p><p>:watermelon: <strong><font color="008F88">进程池与线程池</font></strong> ：</p><p>​ :one: 半同步/半异步进程池 （P289）</p><p>​ :two: 用进程池实现简单的 CGI 服务器 （P298）</p><p>​ :three: 半同步/半反应堆线程池 （P301）</p><p>:grapes: <strong><font color="008F88">web 服务器</font></strong> ：</p><p>​ :one: http_conn 类 （P304）</p><p>​ :two: main 函数 （P318）</p><p>​ :three: 压力测试 （P329）</p><blockquote><p>参考：《Linux 高性能服务器编程》</p><p>笔记：<a href="https://czgitaccount.github.io/Server_Programming/Linux高性能服务器编程examples/">Linux 高性能服务器编程 examples</a></p><p>代码见仓库:house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h2 id="1-IO-复用"><a href="#1-IO-复用" class="headerlink" title="1 IO 复用"></a>1 IO 复用</h2><h3 id="1-1-同时接收普通数据和带外数据"><a href="#1-1-同时接收普通数据和带外数据" class="headerlink" title="1.1 同时接收普通数据和带外数据"></a>1.1 同时接收普通数据和带外数据</h3><p>服务器代码使用 <strong>select</strong> 监听可读事件，以及异常事件，接收到客户端发送的数据后输出。</p><p>:small_blue_diamond: 服务器接收数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听读事件 异常事件</span></span><br><span class="line">ret = select(connfd + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, &amp;exception_fds, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(connfd, &amp;read_fds)) &#123;</span><br><span class="line">	ret = recv(connfd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 输出语句 ...</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 对于异常事件，采用带 MSG_OOB 标志的 recv 函数读取数据</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (FD_ISSET(connfd, &amp;exception_fds)) &#123;</span><br><span class="line">	ret = recv(connfd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, MSG_OOB);</span><br><span class="line">	<span class="comment">// 输出语句 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 客户端发送数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* oob_data = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* normal_data = <span class="string">"123"</span>;</span><br><span class="line"></span><br><span class="line">send(sockfd, normal_data, <span class="built_in">strlen</span>(normal_data), <span class="number">0</span>);</span><br><span class="line">send(sockfd, oob_data, <span class="built_in">strlen</span>(oob_data), MSG_OOB);</span><br><span class="line">send(sockfd, normal_data, <span class="built_in">strlen</span>(normal_data), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>:star: 运行结果：</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_1_result.png" style="zoom:80%"></p><p><strong><font color="FF8888">发现</font></strong> ​ :eyes: ：客户端发送给服务器的 3 字节的带外数据 “abc” 中仅有最后一个字符 “c” 被服务器当成了真正的带外数据接收。</p><p><strong><font color="FF8888">补充</font></strong> :raising_hand:</p><p>在 Linux 环境下，内核通知应用程序带外数据到达主要有两种方法：</p><p>:small_blue_diamond: IO 复用技术，<strong>select</strong> 等系统调用在接收到带外数据时返回，并向应用程序报告 socket 上的异常事件，如1.1的例子。</p><p>:small_orange_diamond: 使用 SIGURG 信号，见代码清单 10-3 ： 用 <strong>SIGURG</strong> 检测带外数据是否到达。</p><p>服务器代码：<code>1_1_server.cpp</code> 客户端代码：<code>1_1_client.cpp</code></p><blockquote><p>详细代码见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h3 id="1-2-聊天室程序"><a href="#1-2-聊天室程序" class="headerlink" title="1.2 聊天室程序"></a>1.2 聊天室程序</h3><p>该聊天室能够让所有用户同时在线群聊，它分为客户端和服务器两个部分，利用 <strong>poll</strong> 实现。</p><p><strong><font color="008F88">客户端</font></strong> 程序有 <strong>两个</strong> 功能：</p><p>:small_blue_diamond: 一是从标准输入终端读入用户数据，并将用户数据发送至服务器；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 splice 函数将用户输入内容直接定向到网络连接上以发送之</span></span><br><span class="line"><span class="comment">// 从而实现数据零拷贝，提高了程序执行效率   fds[0].fd = 0 标准输入</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">	ret = splice(<span class="number">0</span>, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);  <span class="comment">// 标准输入 --&gt; 管道写端</span></span><br><span class="line">	ret = splice(pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, sockfd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);  <span class="comment">// 管道读端 --&gt; socket</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 二是往标准输出终端打印服务器发送给它的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(read_buf, <span class="string">'\0'</span>, BUFFER_SIZE);</span><br><span class="line">    recv(fds[<span class="number">1</span>].fd, read_buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// 接收服务器数据</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; read_buf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="008F88">服务器</font></strong> 的功能时接收客户数据，并把客户数据发送给每一个登录到该服务器上的客户（发送数据者除外）。</p><p>:small_blue_diamond: 客户数据结构体，以及非阻塞设计：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户数据：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">    sockaddr_in address;     <span class="comment">// 客户端 socket 地址</span></span><br><span class="line">    <span class="keyword">char</span> *write_buf;		 <span class="comment">// 待写到客户端的数据的位置</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];	 <span class="comment">// 从客户端读入的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);        <span class="comment">// 记录之前 fd 的 flag</span></span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;	<span class="comment">// 添加非阻塞 flag</span></span><br><span class="line">    fcntl(fd, F_SETFL, new_option);			    <span class="comment">// 设置非阻塞</span></span><br><span class="line">    <span class="keyword">return</span> old_option;							<span class="comment">// 返回文件描述符旧的状态</span></span><br><span class="line">&#125;												<span class="comment">// 以便日后恢复该状态标志</span></span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 创建用户数组，poll 检测用户状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 users 数组，分配 FD_LIMIT 个 client_data 对象</span></span><br><span class="line"><span class="comment">// 每个可能的 socket 连接都可以获得一个这样的对象</span></span><br><span class="line"><span class="comment">// 并且 socket 的值可以直接用来索引 socket 连接对应的 client_data 对象</span></span><br><span class="line">client_data *users = <span class="keyword">new</span> client_data[FD_LIMIT];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽管分配了足够多的 client_data 对象，但为了提高poll的性能，仍然有必要限制用户数量</span></span><br><span class="line">pollfd fds[USER_LIMIT + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中 fds[0] 用来处理连接请求</span></span><br><span class="line">fds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN | POLLERR;</span><br><span class="line">fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>:small_blue_diamond: 处理各种情况：</p><p>连接请求、错误信息、客户端关闭连接、处理用户输入数据和发送用户数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理连接请求, 内部需要考虑用户数量</span></span><br><span class="line"><span class="keyword">if</span> (fds[i].fd == listenfd &amp;&amp; (fds[i].revents &amp; POLLIN)) &#123;...&#125;</span><br><span class="line"><span class="comment">// 处理错误信息，利用 getsocketopt 获取错误信息</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLERR) &#123;...&#125;</span><br><span class="line"><span class="comment">// 处理客户端关闭连接</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLRDHUP) &#123;...&#125;</span><br><span class="line"><span class="comment">// 处理用户输入数据: 接收用户数据，并写入到服务器连接的所有其他socket写缓存</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123;...&#125;</span><br><span class="line"><span class="comment">// 发送数据给客户: 发送 socket 写缓存中的数据</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLOUT) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>:star: 运行结果：</p><p>连接 5 个用户，超出连接数量，会导致服务器拒绝服务。</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_2_result_too_many_users 1.png" style="zoom:61%"></p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_2_result_too_many_users2.png" style="zoom:80%"></p><p>用户（ <code>fd = 4、5、8</code> ）分别发送消息</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_2_result_server.png" style="zoom:61%"></p><p>除了发送者，所有用户都会接收到信息，用户（ <code>fd = 6</code> ）终端结果如下：</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_2_result_client.png" style="zoom:61%"></p><p>服务器代码： <code>1_2_chat_server.cpp</code> 客户端代码： <code>1_2_chat_client.cpp</code></p><blockquote><p>详细代码见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h3 id="1-3-同时处理-TCP-和-UDP-服务"><a href="#1-3-同时处理-TCP-和-UDP-服务" class="headerlink" title="1.3 同时处理 TCP 和 UDP 服务"></a>1.3 同时处理 TCP 和 UDP 服务</h3><p>从 <strong>bind</strong> 系统调用的参数来看，一个 socket 只能与一个 socket 地址绑定，即一个 socket 只能用来监听一个端口。因此，服务器如果要同时监听多个端口，就必须创建多个 socket，并将它们分别绑定到各个端口上。这样一来，服务器程序就需要同时管理多个监听 socket，IO 复用技术就有了用武之地。另外，即使是同一个端口，如果服务器同时处理该端口上 TCP 和 UDP 请求，则也需要创建不同的 socket：一个流 socket，另一个是数据报 socket，并将它们都绑定到该端口上。</p><p><strong><font color="008F88">服务器</font></strong> 处理 TCP连接请求，接收 TCP 数据、接收 UDP 数据，并对它们做回声处理（回射服务器）；</p><p>:small_blue_diamond: 处理 TCP UDP 请求</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">addfd(epollfd, listenfd);</span><br><span class="line">addfd(epollfd, udpfd);</span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;  <span class="comment">// 读事件 | ET触发</span></span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    setnonblocking(fd);  <span class="comment">// 设置非阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 epoll 来监听 TCP / UDP</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (sockfd == listenfd) &#123;...&#125;        			<span class="comment">// 处理 TCP 连接   </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (sockfd == udpfd) &#123;...&#125;					<span class="comment">// 接收 UDP 数据</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;...&#125;;		<span class="comment">// 接收 TCP 数据	   </span></span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">注意</font></strong> :raising_hand: ：此时 UDP 与 TCP 连接可以绑定相同的 address ，同一个端口的 TCP UDP 服务。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时 address 设置已经完成 省略...</span></span><br><span class="line"><span class="keyword">int</span> udpfd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">assert(udpfd &gt;= <span class="number">0</span> );</span><br><span class="line">ret = bind(udpfd, (struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>:star: 运行结果：</p><p>两个客户端的发送数据都是 <code>const char *sendbuf = &quot;hello!\n&quot;;</code></p><p>TCP 回声结果：</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_3_result_tcp.png" style="zoom:80%"></p><p>udp 回声结果：</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_3_result_udp.png" style="zoom:80%"></p><p>服务器代码： <code>1_3_server.cpp</code> 客户端代码： <code>1_3_client_udp.cpp</code> 、 <code>1_3_client_udp.cpp</code></p><blockquote><p>详细代码见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h3 id="1-4-LT-和-ET-模式"><a href="#1-4-LT-和-ET-模式" class="headerlink" title="1.4 LT 和 ET 模式"></a>1.4 LT 和 ET 模式</h3><p>epoll 对文件描述符的操作有两种模式：LT 模式和 ET 模式。LT 模式是默认的工作模式，这种模式下 epoll 相当于一个效率较高的 epoll。当往 epoll 内核事件表中注册一个文件描述符上的 <strong>EPOLLET</strong> 事件时，epoll 将以 ET 模式来操作该文件描述符。ET 模式是 epoll 的高效工作模式。</p><p>对于采用 LT 工作模式的文件描述符，当 <strong>epoll_wait</strong> 检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用 <strong>epoll_wait</strong> 时，<strong>epoll_wait</strong> 还会再次向应用程序通知此事件，知道该事件被处理。而对于采用 ET 工作模式的文件描述符，当 <strong>epoll_wait</strong> 检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因此后续的 <strong>epoll_wait</strong> 调用将不再向应用程序通知这一事件。可见，ET 模式在很大程度上降低了同一个 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。</p><p>但是也正是因为内核只会向应用程序通知一次，所以对于连续的数据多次发送的情况下，需要通过其他的机制通知应用程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会通过 errno == EAGAIN 或者 EWOULDBLOCK 来判断接受是否完成</span></span><br><span class="line"><span class="keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"read later"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:star: 运行结果：（发送长度超过 <strong>BUFFFER_SIZE</strong> 长度的消息，见下）</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_4_result_lt.png" style="zoom:80%"></p><p>:small_blue_diamond: LT 模式：</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_4_result_lt1.png" style="zoom:75%"></p><p>可以发现随着每次的 <strong>epoll_wait</strong> 的调用，都会触发打印 <em>event trigger once</em> 语句。</p><p>:small_orange_diamond: ET 模式：</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_4_result_et.png" alt></p><p>可以发现后面的 <strong>epoll_wait</strong> 的调用，并不会触发打印 <em>event trigger once</em> 语句，最后会出现 <code>errno == EAGAIN</code> 打印 <strong>read later</strong> 语句</p><p>服务器代码： <code>1_4_server.cpp</code> 客户端代码： <code>1_2_chat_client.cpp</code></p><blockquote><p>详细代码见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h3 id="1-5-使用-EPOLLONESHOT-事件"><a href="#1-5-使用-EPOLLONESHOT-事件" class="headerlink" title="1.5 使用 EPOLLONESHOT 事件"></a>1.5 使用 EPOLLONESHOT 事件</h3><p>即使使用 ET 模式，一个 <strong>socket</strong> 上的某个事件还是可能被触发多次。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该 socket 上又有新数据可读（<strong>EPOLLIN</strong> 再次被触发），此时另一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个 socket 的局面。这当然不是被期望的，我们期待的是一个 socket 连接在任一时刻都只被一个线程处理。可以用 <strong>epoll</strong> 的 <strong>EPOLLONESHOT</strong> 事件实现。</p><p>对于注册了 <strong>EPOLLONESHOT</strong> 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用 <strong>epoll_ctl</strong> 函数重置该文件描述符上注册的 <strong>EPOLLONESHOT</strong> 事件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。</p><p>但是需要注意 :raising_hand_man: ：注册了 <strong>EPOLLONESHOT</strong> 事件的 socket 一旦被某个线程处理完毕，该线程就应该立即重置这个 socket 上的 <strong>EPOLLONESHOT</strong> 事件，以确保这个 socket 下一次可读时，其 <strong>EPOLLIN</strong> 事件能被触发，进而让其他工作线程有机会继续处理这个 socket。</p><p><strong><font color="008F88">服务器</font></strong> 工作线程函数处理完某个 socket 上的一次请求之后，又接收到该 socket 上新的客户请求，则该线程将继续为这个 socket 服务。并且因为该 socket 上注册了 <strong>EPOLLONESHOT</strong> 事件，其他线程没有机会接触这个 socket，如果工作线程等待 5s 后仍然没有收到该 socket 上的下一批客户数据，则它将放弃为该 socket 服务，同时调用 <code>reset_oneshot</code> 函数来重置该 socket 上的注册事件，这将使 epoll 有机会再次检测到该 socket 上的 <strong>EPOLLIN</strong> 事件，进而使得其他线程有机会为该 socket 服务。</p><p>:star: 运行结果：</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/1_5_result.png" style="zoom:61%"></p><p>服务器代码： <code>1_5_server.cpp</code> 客户端代码： <code>1_5_client.cpp</code></p><blockquote><p>详细代码见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h2 id="2-有限状态机"><a href="#2-有限状态机" class="headerlink" title="2 有限状态机"></a><strong>2 有限状态机</strong></h2><p>本节是一个有限状态机应用的一个实例：HTTP 请求的读取和分析。很多网络协议，包括 TCP 协议和 IP 协议，都在其头部中提供头部长度字段。程序根据该字段的值就可以知道是否接收到一个完整的协议头部。但 HTTP 协议并未提供这样的头部长度字段，并且其头部长度变化也很大，可以只有十几字节，也可以有上百字节。根据协议规定，判断 HTTP 头部结束的依据是遇到一个空行，该空行仅包含一对回车换行符（<code>&lt;CR&gt;&lt;LF&gt;</code>，或者 <code>\r\n</code>）。如果一次读操作没有读入 HTTP 请求的整个头部，即没有遇到空行，那么就必须等待客户继续写数据并再次读入。因此，每完成一次读操作，就要分析新读入的数据中是否有空行。不过在寻找空行的过程中，程序可以同时完成对整个 HTTP 请求头部的分析，以提高解析 HTTP 请求的效率。</p><p>以下代码使用主、从两个有限状态机实现了最简单的 HTTP 请求的读取和分析，为了表述简洁，直接称 HTTP 请求的一行（包括请求行和头部字段）为行。</p><p>:small_blue_diamond: 从状态机，用于解析出一行内容，从状态机的转换图如下所示：</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/2_result_line.png" style="zoom:50%"></p><p>:small_orange_diamond: HTTP 请求的入口函数（主状态机）</p><p>主状态机使用 <strong>checkstate</strong> 变量来记录当前状态。如果当前的状态是 <strong>CHECK_STATE_REQUESTLINE</strong>，则表示 <code>parse_line</code> 函数解析出的行是请求行，于是主机状态机调用 <code>parse_requestline</code> 来分析请求行；如果当前的状态时 <strong>CHECK_STATE_HEADER</strong>，则表示 <code>parse_line</code> 函数解析出的是头部字段，于是主机状态调用 <code>parse_headers</code> 来分析头部字段。<strong>checkstate</strong> 变量的初始值是 <strong>CHECK_STATE_REQUESTLINE</strong>，<code>parse_requestline</code> 函数在成功地分析完请求行之后将其设置为 <strong>CHECK_STATE_HEADER</strong>，从而实现状态转移。</p><p>:small_blue_diamond: 分析请求行</p><p>请求行主要分析：请求方法，URL，协议版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求方法分析</span></span><br><span class="line"><span class="keyword">if</span> (strcasecmp(method, <span class="string">"GET"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The request method is GET\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 协议版本分析</span></span><br><span class="line"><span class="keyword">if</span> (strcasecmp(version, <span class="string">"HTTP/1.1"</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// URL 分析</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strncasecmp(url, <span class="string">"http://"</span>, <span class="number">7</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    url += <span class="number">7</span>;</span><br><span class="line">    url = <span class="built_in">strchr</span>(url, <span class="string">'/'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!url || url[<span class="number">0</span>] != <span class="string">'/'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The request URL is : %s\n"</span>, url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以发现成功分析完请求行后会将主状态机 checkstate 设置为 CHECK_STATE_HEADER</span></span><br><span class="line">checkstate = CHECK_STATE_HEADER;</span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 分析头部字段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遇到一个空行，说明得到一个正确地 HTTP 请求</span></span><br><span class="line"><span class="keyword">if</span> (temp[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 处理 “HOST” 头部字段</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (strncasecmp(temp, <span class="string">"Host:"</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    temp += <span class="number">5</span>;</span><br><span class="line">    temp += <span class="built_in">strspn</span>(temp, <span class="string">" \t"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the request host is: %s\n"</span>, temp);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 其他头部字段都不处理</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I can not handle this header\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:star: 运行结果：</p><p>:small_blue_diamond: 客户端发送请求一：（支持 GET 操作）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *buf = <span class="string">"GET /http://example/hello.html HTTP/1.1\r\n\r\nHost:hostlocal"</span>;</span><br><span class="line">send(sock, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/2_result_get_server.png" style="zoom:80%"></p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/2_result_get_client.png" style="zoom:80%"></p><p>:small_orange_diamond: 客户端发送请求二： （不支持 POST 操作）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *buf = <span class="string">"POST /http://example/hello.html HTTP/1.1\r\n\r\nHost:hostlocal"</span>;</span><br><span class="line">send(sock, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/2_result_post_server.png" style="zoom:80%"></p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/2_result_post_server.png" style="zoom:80%"></p><p>服务器代码： <code>GET_HOST_test.cpp</code> ，客户端代码：<code>2_1_client.cpp</code></p><blockquote><p>详细代码见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h2 id="3-统一事件源"><a href="#3-统一事件源" class="headerlink" title="3 统一事件源"></a><strong>3 统一事件源</strong></h2><p>信号是一种 <strong>异步</strong> 事件：信号处理函数和程序的主循环是两条不同的执行路线。很显然，信号处理函数需要尽可能快地执行完毕，以确保该信号不被屏蔽太久。一种典型地解决方案是：把信号的主要处理逻辑放到程序地主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。信号处理函数通常使用 <strong>管道</strong> 来将信号“传递”给主循环：怎么知道管道上何时有数据可读？这很简单，只需要使用 IO 复用系统调用来监听管道的读端文件描述符上的可读事件。如此一来，信号事件就能和其他 IO 事件一样被处理，即统一事件源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~ 监听管道读端 读事件</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">    <span class="keyword">int</span> sig;</span><br><span class="line">    <span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">    ret = recv(pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// ~ 因为每个信号值占一个字符，所以按照字节逐个接收信号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> SIGCHLD:</span><br><span class="line">                <span class="keyword">case</span> SIGHUP: &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> SIGTERM: </span><br><span class="line">                <span class="keyword">case</span> SIGINT: &#123; </span><br><span class="line">                    stop_server = <span class="literal">true</span>; </span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"CTRL + C --&gt; close fds"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>:star: 运行结果：</p><p>服务器运行后，键入 CTRL + C 接收到中断信号。</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/3_1_result.png" style="zoom:61%"></p><p>服务器代码： <code>1_3_server.cpp</code></p><blockquote><p>详细代码见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h2 id="4-定时器"><a href="#4-定时器" class="headerlink" title="4 定时器"></a><strong>4 定时器</strong></h2><p>本节通过一个实例——处理非活动连接，来介绍如何使用 <strong>SIGALRM</strong> 信号定时。不过，需要先给出一种简单的定时器实现——基于升序链表的定时器，并把它应用到处理非活动连接这个实例中。</p><h3 id="4-1-基于升序链表的定时器"><a href="#4-1-基于升序链表的定时器" class="headerlink" title="4.1 基于升序链表的定时器"></a>4.1 基于升序链表的定时器</h3><p>定时器通常至少包含两个成员：一个超时时间和一个任务回调函数。有时候还可能包含回调函数被执行时需要传入的参数，以及是否重启定时器等信息。如果使用链表作为容器来串联所有的定时器，则每个定时器还要包含指向下一个定时器的指针成员。进一步，如果链表是双向的，则每个定时器还需要包含指向前一个定时器的指针成员。</p><p>:small_blue_diamond: 所需数据结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户数据结构: 客户端 socket 地址、socket 文件描述符、读缓存和定时器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span>...&#125;; </span><br><span class="line"><span class="comment">// 定时器类: 任务超时事件, 任务回调函数, 用户数据结构, 指向前一个定时器, 指向后一个定时器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="comment">// 定时器链表，它是一个升序、双向链表，且带有头结点和尾结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sort_timer_lst</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="comment">// 内部包含：构造函数，析构函数</span></span><br><span class="line"><span class="comment">// add_timer (将 timer 添加到链表)</span></span><br><span class="line"><span class="comment">// adjust_timer (调整对应的定时器在链表中的位置)</span></span><br><span class="line"><span class="comment">// del_timer (将 timer 从链表中删除)</span></span><br><span class="line"><span class="comment">// tick (心搏函数，已处理链表上到期的任务)</span></span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 定时器链表成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有序链表的插入、删除和调整操作都需要判断头尾节点。</span></span><br><span class="line"><span class="comment">// 有序链表插入操作，通过 timer-&gt;expire 来进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有序链表调整操作，通过 timer-&gt;expire 来进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有序链表删除操作，通过 timer-&gt;expire 来进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGALRM 信号每次被触发就在其信号处理函数(如果使用统一事件源，则是主函数)</span></span><br><span class="line"><span class="comment">// 中执行一次 tick 函数以处理链表上到期的任务</span></span><br><span class="line"><span class="comment">// 内部会使用回调函数, 以执行定时任务，执行完定时器中定时任务之后</span></span><br><span class="line"><span class="comment">// 就将它从链表中删除,并重置链表头结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>将所有实现包含在头文件中，其核心函数 <strong>tick</strong> 相当于一个心搏函数，它每隔一段固定的时间就执行一次，以检测并处理到期的任务。判断定时任务到期的依据是定时器的 <strong>expire</strong> 值小于当前的系统时间。从执行效率来看，添加定时器的时间复杂度是 $O(n)$ ，删除定时器的时间复杂度是 $O(1)$ ，执行定时任务的时间复杂度是 $O(1)$ 。</p><p>头文件： <code>lst_timer.h</code></p><blockquote><p>详细代码见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h3 id="4-2-处理非活动连接"><a href="#4-2-处理非活动连接" class="headerlink" title="4.2 处理非活动连接"></a>4.2 处理非活动连接</h3><p>服务器利用 <strong>alarm</strong> 函数周期性地触发 <strong>SIGALRM</strong> 信号，该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务——关闭非活动的连接。（利用管道通知主循环信号的方法，见统一事件源）；</p><p>服务器代码处理大于 <code>3 * TIMESLOT</code> 时间非活动的客户端。每个客户端都有一个定时器，定时器记录了最后一次客户端的活动时间，每次客户连接上有数据可读，则需要调整该连接对应的定时器，以延迟该连接被关闭的时间，但同时也可能是删除操作。</p><p>:small_blue_diamond: 服务器设置客户端定时器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端设置定时器</span></span><br><span class="line"> <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">     <span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">     <span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">     addfd(epollfd, connfd);</span><br><span class="line">     users[connfd].address = client_address;</span><br><span class="line">     users[connfd].sockfd = connfd;</span><br><span class="line">     util_timer *timer = <span class="keyword">new</span> util_timer;</span><br><span class="line">     timer-&gt;user_data = &amp;users[connfd];</span><br><span class="line">     timer-&gt;cb_func = cb_func;  <span class="comment">// 设置回调函数</span></span><br><span class="line">     <span class="keyword">time_t</span> cur = time(<span class="literal">NULL</span>);</span><br><span class="line">     timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;  <span class="comment">// 定时器设置</span></span><br><span class="line">     users[connfd].timer = timer;</span><br><span class="line">     timer_lst.add_timer(timer);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 有数据可读，调整定时器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有数据可读，调整定时器</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(users[sockfd].buf, <span class="string">'\0'</span>, BUFFER_SIZE);</span><br><span class="line">    ret = recv(sockfd, users[sockfd].buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"get "</span> &lt;&lt; ret &lt;&lt; <span class="string">" bytes of client data "</span> &lt;&lt; users[sockfd].buf &lt;&lt; <span class="string">" from "</span> &lt;&lt; sockfd &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    util_timer *timer = users[sockfd].timer;</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            cb_func(&amp;users[sockfd]);</span><br><span class="line">            <span class="keyword">if</span> (timer) timer_lst.del_timer(timer);  <span class="comment">// 删除定时器操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        cb_func(&amp;users[sockfd]);</span><br><span class="line">        <span class="keyword">if</span> (timer) timer_lst.del_timer(timer);      <span class="comment">// 删除定时器操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;  <span class="comment">// 调整定时器操作</span></span><br><span class="line">            <span class="keyword">time_t</span> cur = time(<span class="literal">NULL</span>);</span><br><span class="line">            timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"adjust timer once "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            timer_lst.add_timer(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:star: 运行结果：（ 关闭时间： <code>3 * TIMESLOT</code> ）</p><p>测试条件一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sendbuf = <span class="string">"hello\n"</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;        </span><br><span class="line">    send(sock, sendbuf, <span class="keyword">sizeof</span>(sendbuf), <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);   <span class="comment">// 设置 10 秒 活动一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试条件二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sendbuf = <span class="string">"hello\n"</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;        </span><br><span class="line">    send(sock, sendbuf, <span class="keyword">sizeof</span>(sendbuf), <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">20</span>);   <span class="comment">// 设置 20 秒 活动一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以测试条件一，该客户端可以一直保持连接。</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/4_2_result_10.png" style="zoom:61%"></p><p>所以测试条件二，由于客户端超过 15 s 没有活动，所以被客户端强制关闭连接。</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/4_2_result_20.png" style="zoom:75%"></p><p>头文件： <code>lst_timer.h</code> ，服务器代码：<code>4_2_server.cpp</code> ，客户端代码： <code>4_2_client.cpp</code></p><blockquote><p>详细代码见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h2 id="5-共享内存"><a href="#5-共享内存" class="headerlink" title="5 共享内存"></a>5 共享内存</h2><p>将之前的聊天室服务器程序，修改为一个多进程服务器：一个子进程处理一个客户连接。同时，我们将所有客户 socket 连接的都缓冲设计为一块共享内存。</p><p>整个 <strong><font color="008F88">通信建立流程</font></strong> 分为了三个部分：</p><p>:small_blue_diamond: 客户端发起连接请求，服务器处理连接请求，并完成连接建立</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;  <span class="comment">// ~ 监听连接时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line"><span class="comment">//    ...</span></span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 服务器为该连接创建子进程（继承 <strong>connfd</strong> ），并关闭父进程 <strong>connfd</strong> ，将与客户通信操作交给子进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123; <span class="comment">// 创建失败</span></span><br><span class="line">    <span class="built_in">close</span>(connfd);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// ~ 子进程</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 处理函数</span></span><br><span class="line">    run_child(user_count, users, share_mem);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// ~ 父进程</span></span><br><span class="line">     <span class="built_in">close</span>(connfd); <span class="comment">// 关闭</span></span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>:small_blue_diamond: 父子进程间通过管道连接，子进程通知父进程有数据传来需要被处理，父进程通知子进程发送处理后的数据。主要通过子进程来作为中转站，子进程需要同时监听客户端 socket，以及与父进程之间的管道。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==== 主循环中 ====</span></span><br><span class="line"><span class="comment">// 某个子进程通知父进程处理数据 (父进程接收到子进程的通知)</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">0</span>; </span><br><span class="line">    ret = recv(sockfd, (<span class="keyword">char</span>*)&amp;child, <span class="keyword">sizeof</span>(child), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"read data from child accross pipe"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ~ 向除负责处理第 child 个客户连接的子进程之外的其他子进程发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; user_count; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (users[j].pipefd[<span class="number">0</span>] != sockfd) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"send data to child accross pipe : "</span> &lt;&lt; child &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="comment">// 通知子进程</span></span><br><span class="line">                send(users[j].pipefd[<span class="number">0</span>], (<span class="keyword">char</span>*)&amp;child, <span class="keyword">sizeof</span>(child), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ==== run_child 循环中 ====</span></span><br><span class="line"><span class="comment">// 子进程负责的客户连接有数据到达</span></span><br><span class="line"><span class="keyword">if</span> ((sockfd == connfd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(share_mem + idx * BUFFER_SIZE, <span class="string">'\0'</span>, BUFFER_SIZE);</span><br><span class="line">    ret = recv(connfd, share_mem + idx * BUFFER_SIZE, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) stop_child = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) stop_child = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> send(pipefd, (<span class="keyword">char</span>*)&amp;idx, <span class="keyword">sizeof</span>(idx), <span class="number">0</span>); <span class="comment">// ~ 通知通知主进程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程通知子进程发送数据给客户端</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123; </span><br><span class="line">    <span class="keyword">int</span> client = <span class="number">0</span>;                                             </span><br><span class="line">    ret = recv(sockfd, (<span class="keyword">char</span>*)&amp;client, <span class="keyword">sizeof</span>(client), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) stop_child = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) stop_child = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> send(connfd, share_mem + client * BUFFER_SIZE, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">注意</font></strong> :raising_hand_man: ：还需要创建新的管道来通知主循环处理信号（统一事件源的处理方法）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == sig_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部添加了子进程退出的信号处理，回收资源</span></span><br><span class="line"><span class="keyword">case</span> SIGCHLD: <span class="comment">// 子进程退出</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> stat;</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> del_user = sub_process[pid];  <span class="comment">// 找到退出的客户</span></span><br><span class="line">        sub_process[pid] = <span class="number">-1</span>;  		  <span class="comment">// 重置索引表格</span></span><br><span class="line">        <span class="keyword">if</span> ((del_user &lt; <span class="number">0</span>) || (del_user &gt; USER_LIMIT)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 epollfd 中删除，客户的父子进程通信管道注册信息, 并关闭对应的文件描述符</span></span><br><span class="line">        epoll_ctl(epollfd, EPOLL_CTL_DEL, users[del_user].pipefd[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">close</span>(users[del_user].pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 更新 users 数组（一直保持，新来的客户端位于 users 数组最后）</span></span><br><span class="line">        users[del_user] = users[--user_count];</span><br><span class="line">        sub_process[users[del_user].pid] = del_user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">terminate</span> &amp;&amp; user_count == <span class="number">0</span>) stop_server = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="008F88">共享内存</font></strong> ：</p><p>:small_blue_diamond: 本服务器代码使用的是共享内存的 <strong>POSIX</strong> 方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shmfd = shm_open(shm_name, O_CREAT | O_RDWR, <span class="number">0666</span>); <span class="comment">// ~ 创建共享内存</span></span><br><span class="line">assert(shmfd != <span class="number">-1</span>);</span><br><span class="line">ret = ftruncate(shmfd, USER_LIMIT * BUFFER_SIZE);   <span class="comment">// ~ 修改文件大小</span></span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// ~ 申请一段内存空间，可以作为进程间通信的共享内存</span></span><br><span class="line">share_mem = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, USER_LIMIT * BUFFER_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, <span class="number">0</span>);</span><br><span class="line">assert(share_mem != MAP_FAILED);</span><br><span class="line"><span class="built_in">close</span>(shmfd);</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">注意</font></strong> :raising_hand: ：在编译的时候需要指定链接选项 -lrt</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o <span class="number">5</span>_2_server <span class="number">5</span>_2_server.cpp -lrt</span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 另外还可以使用 <code>sys/shm.h</code> 中的 <strong>shmget</strong> 、 <strong>shmat</strong> 、 <strong>shmdt</strong> 和 <strong>shmctl</strong> 系统调用。本人认为更简单一些 :metal: ，操作更方便。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *share_men;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line">key = ftok(<span class="string">"/a.c"</span>, <span class="string">'c'</span>);</span><br><span class="line">shmid = shmget(key, USER_LIMIT * BUFFER_SIZE, O_CREAT | O_RDWR | <span class="number">0666</span>);</span><br><span class="line">share_mem = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程结束前释放内存</span></span><br><span class="line">shmdt(share_mem);</span><br><span class="line"><span class="comment">// 程序结束前删除共享内存对象</span></span><br><span class="line">shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">注意</font></strong> :raising_hand:</p><p>:small_blue_diamond: 虽然使用了共享内存，但每个子进程都只会往自己所处理的客户链接对应的那一部分读缓存中写入数据，所以使用共享内存的目的只是为了“共享读”。所以，每个子进程在使用共享内存的时候都无需加锁，这样符合“聊天室服务器”的应用场景，同时提高了程序性能。</p><p>:small_orange_diamond: 服务器程序在启动的时候给数组 users 分配了足够多的空间，使得它可以存储所有可能的用户连接相关的数据。同样一次性给数组 sub_process 分配的空间也足以存储所有可能的子进程的相关数据。这是牺牲空间换取时间的又一例子。</p><p>:star: 运行结果：</p><p>:small_blue_diamond: 用户数超过上限：</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/5_1_result_too_many_users (1" alt>.png)</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/5_1_result_too_many_users (2" alt>.png)</p><p>:small_orange_diamond: 正常实现聊天室功能：（一个服务器，四个客户端）</p><p>前三个客户端分别键入一条语句，最后一个客户端仅仅查看聊天记录。</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/5_1_result_chat2.png" style="zoom:75%"></p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/5_1_result_chat.png" style="zoom:75%"></p><p>:small_blue_diamond: 服务器关闭连接</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/5_1_result_kill.png" alt></p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/5_1_result_too_many_users (2" alt>.png)</p><p>服务器代码：<code>5_1_server.cpp</code> ，客户端代码： <code>5_1_client.cpp</code></p><blockquote><p>详细代码见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h2 id="6-进程池与线程池"><a href="#6-进程池与线程池" class="headerlink" title="6 进程池与线程池"></a>6 进程池与线程池</h2><h3 id="6-1-半同步-半异步进程池"><a href="#6-1-半同步-半异步进程池" class="headerlink" title="6.1 半同步/半异步进程池"></a>6.1 半同步/半异步进程池</h3><p>为了避免在父、子进程之间传递文件描述符，将接收连接的操作放到子进程中。</p><p>:small_blue_diamond: 子进程的类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">process</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">process</span>() : m_pid(<span class="number">-1</span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">pid_t</span> m_pid;		<span class="comment">// m_pid 是目标子进程的 PID</span></span><br><span class="line">    <span class="keyword">int</span> m_pipefd[<span class="number">2</span>];	<span class="comment">// m_pipefd 是父子进程通信用的管道</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 进程池类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程池类，将它定义为模板类是为了代码复用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">processpool</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数私有，只可以通过 create 函数创建实例</span></span><br><span class="line">    processpool(<span class="keyword">int</span> listenfd, <span class="keyword">int</span> process_number = <span class="number">8</span>); <span class="comment">// ~ 单例模式</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 单例模式，以保证程序最多创建一个 processpool 实例</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> processpool&lt;T&gt;* <span class="title">create</span><span class="params">(<span class="keyword">int</span> listenfd, <span class="keyword">int</span> process_number = <span class="number">8</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_instance) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> processpool&lt;T&gt;(listenfd, process_number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    ~processpool() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_sub_process;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;  <span class="comment">// 启动线程池</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setup_sig_pipe</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run_parent</span><span class="params">()</span></span>;	    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run_child</span><span class="params">()</span></span>;		</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_PROCESS_NUMBER = <span class="number">16</span>;   <span class="comment">// 进程池允许的最大子进程数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> USER_PER_PROCESS = <span class="number">65536</span>;	<span class="comment">// 每个子进程最多能处理的客户数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_EVENT_NUMBER = <span class="number">10000</span>; </span><br><span class="line">    <span class="keyword">int</span> m_process_number;  		<span class="comment">// 进程池中的进程总数</span></span><br><span class="line">    <span class="keyword">int</span> m_idx;			   		<span class="comment">// 子进程在池中序号, 从 0 开始</span></span><br><span class="line">    <span class="keyword">int</span> m_epollfd;		   		<span class="comment">// 每个进程都有一个 epoll 内核时间表，用 m_epollfd 标志</span></span><br><span class="line">    <span class="keyword">int</span> m_listenfd;		   		<span class="comment">// 监听 socket</span></span><br><span class="line">    <span class="keyword">int</span> m_stop;			   		<span class="comment">// 子进程通过 m_stop 来决定是否停止运行</span></span><br><span class="line">    <span class="built_in">process</span> *m_sub_process;		<span class="comment">// 保存所有子进程的描述信息</span></span><br><span class="line">    <span class="keyword">static</span> processpool&lt;T&gt; *m_instance;  <span class="comment">// 进程池静态实例</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 饿汉模式，初始化进程池静态实例</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">processpool&lt;T&gt; *processpool&lt;T&gt;::m_instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>:small_blue_diamond: 进程池构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程池构造函数，参数 listenfd 是监听 socket, 它必须在创建进程池之前被创建，否则子进程无法直接引用它，参数 process_number 指定进程池中子进程的数量</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">processpool&lt;T&gt;::processpool(<span class="keyword">int</span> listenfd, <span class="keyword">int</span> process_number) </span><br><span class="line">    : m_listenfd(listenfd), m_process_number(process_number), m_idx(<span class="number">-1</span>), m_stop(<span class="literal">false</span>) &#123;</span><br><span class="line">    assert((process_number &gt; <span class="number">0</span>) &amp;&amp; (process_number &lt;= MAX_PROCESS_NUMBER));</span><br><span class="line">    m_sub_process = <span class="keyword">new</span> <span class="built_in">process</span>[process_number];</span><br><span class="line">    assert(m_sub_process);</span><br><span class="line">    <span class="comment">// 创建 process_number 个子进程，并建立它们和父进程之间的管道</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_number; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, m_sub_process[i].m_pipefd);</span><br><span class="line">        assert(ret == <span class="number">0</span>);</span><br><span class="line">        m_sub_process[i].m_pid = fork();</span><br><span class="line">        assert(m_sub_process[i].m_pid &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (m_sub_process[i].m_pid &gt; <span class="number">0</span>) &#123;  <span class="comment">// 父进程</span></span><br><span class="line">            <span class="built_in">close</span>(m_sub_process[i].m_pipefd[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 子进程</span></span><br><span class="line">            <span class="built_in">close</span>(m_sub_process[i].m_pipefd[<span class="number">0</span>]);</span><br><span class="line">            m_idx = i;   <span class="comment">// 可以发现子进程中 m_idx &gt;= 0</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 进程池运行程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父进程中 m_idx 值为 -1, 子进程中 m_idx 值大于等于 0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> processpool&lt;T&gt;::<span class="built_in">run</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">        run_child();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    run_parent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:small_blue_diamond: 父进程运行函数，主要用来监听 <strong>m_listenfd</strong>，并通过管道通知子进程与对应 socket 建立连接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sockfd == m_listenfd) &#123;</span><br><span class="line">    <span class="comment">// 如果有新连接到来, 就采用 Round Robin 方式将其分配给一个子进程处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = sub_process_counter;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 如果子进程没有退出, m_pid != -1, 会直接退出, 选择该子进程</span></span><br><span class="line">        <span class="keyword">if</span> (m_sub_process[i].m_pid != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 否则会在进程池中增序轮询</span></span><br><span class="line">        i = (i + <span class="number">1</span>) % m_process_number; <span class="comment">// i++</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (i != sub_process_counter);</span><br><span class="line">    <span class="comment">// 如果进程池中进程都退出</span></span><br><span class="line">    <span class="keyword">if</span> (m_sub_process[i].m_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">         m_stop = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_process_counter = (i + <span class="number">1</span>) % m_process_number; <span class="comment">// 子进程计数器递增</span></span><br><span class="line">    <span class="comment">// 通知子进程与对应 listenfd 建立连接 (子进程由于 fork 继承了 listenfd)</span></span><br><span class="line">    send(m_sub_process[i].m_pipefd[<span class="number">0</span>], (<span class="keyword">char</span> *)&amp;new_conn, <span class="keyword">sizeof</span>(new_conn), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"send request to child"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 子进程运行函数，主要用来监听 <strong>pipefd</strong>，通过父进程的通知，与对应客户端建立连接。后注册客户端 socket，同时监听客户端 socket，具体的处理方式交给对应的用户处理函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立连接</span></span><br><span class="line"><span class="keyword">if</span> ((sockfd == pipefd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">    <span class="keyword">int</span> client = <span class="number">0</span>;</span><br><span class="line">    ret = recv(sockfd, (<span class="keyword">char</span>*)&amp;client, <span class="keyword">sizeof</span>(client), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (((ret &lt; <span class="number">0</span>) &amp;&amp; (errno != EAGAIN)) || ret == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        struct sockaddr_in client_address;</span><br><span class="line">        <span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">        <span class="keyword">int</span> connfd = accept(m_listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">        <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"errno is : "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addfd(m_epollfd, connfd);</span><br><span class="line">        <span class="comment">// 模板类 T 必须实现 init 方法，已初始化一个客户连接</span></span><br><span class="line">        users[connfd].init(m_epollfd, connfd, client_address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收可读数据</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">	users[sockfd].<span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池头文件：<code>processpool.h</code></p><blockquote><p>详细代码见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h3 id="6-2-用进程池实现简单的-CGI-服务器"><a href="#6-2-用进程池实现简单的-CGI-服务器" class="headerlink" title="6.2 用进程池实现简单的 CGI 服务器"></a>6.2 用进程池实现简单的 CGI 服务器</h3><p>基于 <code>processpool.h</code> 实现简单的 CGI 服务器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于处理客户 CGI 请求的类，它可以作为 processpool 类的模板参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cgi_conn</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    cgi_conn() &#123;&#125;</span><br><span class="line">    ~cgi_conn() &#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化客户连接，清空读缓冲区</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in &amp;client_addr)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">// cgi 处理函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_epollfd;</span><br><span class="line">    <span class="keyword">int</span> m_sockfd;</span><br><span class="line">    sockaddr_in m_address;</span><br><span class="line">    <span class="keyword">char</span> m_buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">int</span> m_read_idx;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> cgi_conn::m_epollfd = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>:small_blue_diamond: <strong><em>cgi</em></strong> 处理函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 循环读取和分析客户数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        idx = m_read_idx; </span><br><span class="line">        ret = recv(m_sockfd, m_buf + idx, BUFFER_SIZE - <span class="number">1</span> - idx, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果该操作发生操作，则关闭客户端连接。但如果是暂时无数据可读，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EAGAIN) removefd(m_epollfd, m_sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果对方关闭连接，则服务器也关闭连接。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            removefd(m_epollfd, m_sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m_read_idx += ret;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"user content is : "</span> &lt;&lt; m_buf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span> (; idx &lt; m_read_idx; ++idx) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((idx &gt;= <span class="number">1</span>) &amp;&amp; (m_buf[idx - <span class="number">1</span>] == <span class="string">'\r'</span>) &amp;&amp; (m_buf[idx] == <span class="string">'\n'</span>)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (idx == m_read_idx) <span class="keyword">continue</span>;</span><br><span class="line">            m_buf[idx - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">char</span> *file_name = m_buf;</span><br><span class="line">            <span class="comment">// 判断客户要运行的 CGI 程序是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (access(file_name, F_OK) == <span class="number">-1</span>) &#123;</span><br><span class="line">                removefd(m_epollfd, m_sockfd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建子进程来执行 CGI 程序</span></span><br><span class="line">            ret = fork();</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                removefd(m_epollfd, m_sockfd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 父进程只需关闭连接</span></span><br><span class="line">                removefd(m_epollfd, m_sockfd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 子进程将标准输出定向到 m_sockfd，并执行 CGI 程序</span></span><br><span class="line">                <span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line">                dup(m_sockfd);</span><br><span class="line">                execl(m_buf, m_buf, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cgi 程序：（需要编译生成可执行文件）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cgi_hello"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:star: 运行结果：</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/6_1_result.png" style="zoom:61%"></p><p>进程池头文件：<code>processpool.h</code> 、服务器程序： <code>6_1_CGI_server.cpp</code>、客户端程序： <code>6_1_client.cpp</code> 、CGI 处理函数 <code>cgi.c</code></p><blockquote><p>详细代码见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h3 id="6-3-半同步-半反应堆线程池"><a href="#6-3-半同步-半反应堆线程池" class="headerlink" title="6.3 半同步/半反应堆线程池"></a>6.3 半同步/半反应堆线程池</h3><p>相比进程池实现，该线程池地通用性要高得多，因为它使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。但是与此同时，队列的 push、pop 操作需要用到线程同步机制，利用了书中第十四章介绍的线程同步机制的包装类。</p><p>操作工作队列需要加锁，如 <strong>append</strong> 、 <strong>run</strong> 操作。</p><p>:small_blue_diamond: <strong>append</strong> 操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> threadpool&lt;T&gt;::append(T* request) &#123;</span><br><span class="line">    m_queuelocker.lock();  		    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">if</span> (m_workqueue.<span class="built_in">size</span>() &gt; m_max_requests) &#123;</span><br><span class="line">        m_queuelocker.unlock();	    <span class="comment">// 解锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue.push_back(request);</span><br><span class="line">    m_queuelocker.unlock();         <span class="comment">// 解锁</span></span><br><span class="line">    m_queuestat.post();  			<span class="comment">// 通知 wait </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:small_orange_diamond: <strong>run</strong> 操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> threadpool&lt;T&gt;::<span class="built_in">run</span>() &#123;</span><br><span class="line">    <span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">        m_queuestat.wait();</span><br><span class="line">        m_queuelocker.lock();          <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">if</span> (m_workqueue.empty()) &#123;</span><br><span class="line">            m_queuelocker.unlock();    <span class="comment">// 解锁</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T* request = m_workqueue.front();</span><br><span class="line">        m_workqueue.pop_front();</span><br><span class="line">        m_queuelocker.unlock();        <span class="comment">// 解锁</span></span><br><span class="line">        <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        request-&gt;<span class="built_in">process</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="FF8888">注意</font></strong> :raising_hand_man:</p><p>在 C++ 程序中使用 <strong>pthread_create</strong> 函数时，该函数的第 3 个参数必须指向一个静态函数。而要在一个静态函数中使用类的动态成员（包括成员函数和成员变量），则只能通过如下两个方式来实现：</p><p>:white_medium_square: 通过类的静态对象来调用。比如单例模式，静态函数可以通过类的全局唯一实例来访问动态成员函数。</p><p>:white_medium_square: 将类的对象作为参数传递给该静态函数，然后再静态函数中引用这个对象，并调用其动态方法。</p><p>上面 :point_up_2: 代码使用的是 <strong>第二种</strong> 方式：将线程参数设置为 <strong><em>this</em></strong> 指针，然后在 <strong>worker</strong> 函数中获取该指针并调用其动态方法 <strong>run</strong> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_create(m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>线程池头文件：<code>threadpool.h</code> 、线程同步机制包装类： <code>locker.h</code></p><blockquote><p>详细代码见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h2 id="7-简单-Web-服务器"><a href="#7-简单-Web-服务器" class="headerlink" title="7 简单 Web 服务器"></a>7 简单 Web 服务器</h2><h3 id="7-1-http-conn-类"><a href="#7-1-http-conn-类" class="headerlink" title="7.1 http_conn 类"></a>7.1 http_conn 类</h3><p>基于第二节使用有限状态机实现的解析 HTTP 请求的服务器，利用线程池来重新实现一个并发的 Web 服务器。</p><p>首先需要准备一个线程池的模板参数类，用以封装逻辑的处理，这个类就是 http_conn 类。</p><blockquote><p>其头文件为： <code>http_conn.h</code> ，实现文件为： <code>http_conn.cpp</code></p></blockquote><p>:small_blue_diamond: 状态机的设定同第二节分析，基本相同。</p><p>:small_orange_diamond: HTTP 请求的入口函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池中 run 函数会阻塞等待任务, 如果被分配任务,就会执行任务的 process() 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HTTP_CODE read_ret = process_read();</span><br><span class="line">    <span class="keyword">if</span> (read_ret == NO_REQUEST) &#123;</span><br><span class="line">        modfd( m_epollfd, m_sockfd, EPOLLIN );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> write_ret = process_write( read_ret );</span><br><span class="line">    <span class="keyword">if</span> (!write_ret ) &#123;</span><br><span class="line">        close_conn();</span><br><span class="line">    &#125;</span><br><span class="line">    modfd(m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:small_blue_diamond: http 请求解析处理：有限状态机。 <code>process_read()</code></p><p>:small_orange_diamond: http 响应消息处理：根据状态码发送不同的信息。 <code>process_write()</code></p><blockquote><p>更多详细实现见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><hr><h3 id="7-2-main-函数"><a href="#7-2-main-函数" class="headerlink" title="7.2 main 函数"></a>7.2 main 函数</h3><p>main 函数主要负责 IO 读写。</p><p>:small_blue_diamond: 创建线程池</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板参数 T --&gt; http_conn</span></span><br><span class="line">threadpool&lt;http_conn&gt; *pool = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    pool = <span class="keyword">new</span> threadpool&lt;http_conn&gt;; <span class="comment">// 启动8个线程,并阻塞在 run</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 预先为每个可能的客户连接分配一个 http_conn 对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_conn *users = <span class="keyword">new</span> http_conn[MAX_FD];</span><br></pre></td></tr></table></figure><p>:small_blue_diamond: 主循环用来接收客户请求连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">    <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"errno is: %d\n"</span>, errno);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD) &#123;</span><br><span class="line">        show_error(connfd, <span class="string">"Internal server busy"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化客户连接</span></span><br><span class="line">    users[connfd].init(connfd, client_address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 根据读事件，决定将任务添加到线程池，还是关闭连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">    <span class="keyword">if</span> (users[sockfd].<span class="built_in">read</span>()) &#123;</span><br><span class="line">        pool-&gt;append(users + sockfd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        users[sockfd].close_conn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:small_blue_diamond: 异常事件，直接关闭客户连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) &#123;</span><br><span class="line">    users[sockfd].close_conn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 根据写的结果，决定是否关闭连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!users[sockfd].<span class="built_in">write</span>()) &#123;</span><br><span class="line">        users[sockfd].close_conn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本流程图：(图太大了，分成三个)</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/flowchart1.png" alt></p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/flowchart2.png" alt></p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/flowchart3.png" alt></p><blockquote><p>总流程图见最后，图片源见仓库图片文件夹。</p></blockquote><hr><h3 id="7-3-压力测试"><a href="#7-3-压力测试" class="headerlink" title="7.3 压力测试"></a>7.3 压力测试</h3><p>压力测试程序有很多种实现方式，比如 IO 复用方式，多线程、多进程并发编程方式，以及这些方式的结合使用。不过单纯的IO复用方式的施压程度最高，因为线程和进程的调到也是要占用一定CPU时间的。因此，下面将使用 epoll 来实现一个通用的服务器压力测试程序，恰好该程序作为 Web 服务器程序的客户端。</p><p>:small_blue_diamond: 向服务器发起 <strong>num</strong> 个 TCP 连接 （可以通过改变 num 来调整测试压力）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_conn</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> num, <span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create 1 sock\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) <span class="keyword">continue</span>; </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"build connection %d\n"</span>, i);</span><br><span class="line">            addfd(epoll_fd, sockfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 每个客户连接不停向服务器发送同样请求 (GET 请求)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *request = <span class="string">"GET http://localhost/index.html HTTP/1.1\r\nConnection: keep-alive\r\n\r\nxxxxxxxxxxxxxx"</span>;</span><br></pre></td></tr></table></figure><p>:small_blue_diamond: 向服务器写入 <strong>len</strong> 字节的数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">write_nbytes</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">buffer</span>, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bytes_write = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"write out %d bytes to socket %d\n"</span>, len, sockfd);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        bytes_write = send(sockfd, <span class="built_in">buffer</span>, len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes_write == <span class="number">-1</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bytes_write == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        len -= bytes_write;</span><br><span class="line">        <span class="built_in">buffer</span> = <span class="built_in">buffer</span> + bytes_write;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:small_orange_diamond: 从服务器读数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_once</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">char</span> *<span class="built_in">buffer</span>, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="string">'\0'</span>, len);</span><br><span class="line">    bytes_read = recv(sockfd, <span class="built_in">buffer</span>, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read in %d bytes from socket %d with content: %s\n"</span>, bytes_read, sockfd, <span class="built_in">buffer</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:small_blue_diamond: 通过 <strong>EPOLLIN</strong> 与 <strong>EPOLLOUT</strong> 之间的转换实现，反复发送请求，接收应答的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!read_once(sockfd, <span class="built_in">buffer</span>, <span class="number">2048</span>)) &#123;</span><br><span class="line">        close_conn(epoll_fd, sockfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.events = EPOLLOUT | EPOLLET | EPOLLERR;  <span class="comment">// 写完了后监听读</span></span><br><span class="line">    event.data.fd = sockfd;</span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_MOD, sockfd, &amp;event);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!write_nbytes(sockfd, request, <span class="built_in">strlen</span>(request))) &#123;</span><br><span class="line">        close_conn(epoll_fd, sockfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLERR;  <span class="comment">// 读完了后监听写</span></span><br><span class="line">    event.data.fd = sockfd;</span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_MOD, sockfd, &amp;event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:star: 测试结果：</p><p>:small_blue_diamond: 服务器启动八个线程：</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/7_3_result_websrv_start.png" style="zoom:61%"></p><p>:small_orange_diamond: 客户端启动，并开始与服务器建立连接 （1000 个，间隔时间 10 <em>ms</em> ）</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/7_3_result_client_start.png" style="zoom:61%"></p><p>:small_blue_diamond: 客户端建立连接后，发送 http 请求，并接收服务器返回的 http 应答消息。</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/7_3_result_client_write_and_read.png" style="zoom:61%"></p><p>:small_orange_diamond: 服务器接收 http 请求并解析，最后给客户端应答消息。</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/7_3_result_websrv_read_and_write.png" style="zoom:61%"></p><p>如果 Web 服务器程序足够稳定，那么 websrv 和 stress_test 这两个程序将一直运行下去，并不断交换数据。</p><p>线程池头文件：<code>threadpool.h</code> 、线程同步机制包装类： <code>locker.h</code> 、 <strong>http_conn</strong> 类头文件： <code>http_conn.h</code> 、 <strong>http_conn</strong> 类实现文件： <code>http_conn.cpp</code> 、服务器代码： <code>main.cpp</code> 、测试程序代码（客户端代码）： <code>stress_test.cpp</code> ，项目编译文件：Makefile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 清除 .o 文件</span></span><br><span class="line">make cleanO</span><br><span class="line"><span class="comment"># 清除可执行文件</span></span><br><span class="line">make cleanE</span><br></pre></td></tr></table></figure><blockquote><p>详细代码见仓库 :house_with_garden: : <a href="https://github.com/czGitAccount/Linux_Server_Programming_emamples" target="_blank" rel="noopener">Linux_Server_Programming_emamples</a></p></blockquote><p>项目流程 <strong>总图</strong> ： :star:</p><p><img src="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/WebSrv1_flowchart.png" alt></p></div><div><div><br><br><div style="text-align:center;color:#ccc;font-size:14px">----------- 本文结束 -----------</div><br><br><br><br></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Server-Programming/" rel="tag"><i class="fa fa-tag">Server_Programming</i></a></div><div class="post-widgets"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/Data_Structure_and_Algorithm/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" rel="next" title="背包问题"><i class="fa fa-chevron-left"></i> 背包问题</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/"><img class="site-author-image" itemprop="image" src="/images/logo.jpg" alt="从之丶"></a><p class="site-author-name" itemprop="name">从之丶</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/%7C%7C%20archive"><span class="site-state-item-count">38</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">33</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/czGitAccount" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:caoz326@163.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-history fa-" aria-hidden="true"></i> 近期文章</div><ul class="links-of-blogroll-list"><li class="recent_posts_li"><a href="/Server_Programming/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8Bexamples/" title="Linux 高性能服务器编程 examples" target="_blank">Linux 高性能服务器编程 examples</a></li><li class="recent_posts_li"><a href="/Data_Structure_and_Algorithm/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" title="背包问题" target="_blank">背包问题</a></li><li class="recent_posts_li"><a href="/Database/Skiplist-CPP/" title="基于跳表实现的键值型存储引擎" target="_blank">基于跳表实现的键值型存储引擎</a></li><li class="recent_posts_li"><a href="/Database/Redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/" title="Redis数据结构与对象" target="_blank">Redis数据结构与对象</a></li><li class="recent_posts_li"><a href="/C++_Language/STL/Algorithm/" title="STL_Algorithm" target="_blank">STL_Algorithm</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-高性能服务器编程-examples"><span class="nav-text">Linux 高性能服务器编程 examples</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#raising-hand-man-说明"><span class="nav-text">:raising_hand_man: 说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-IO-复用"><span class="nav-text">1 IO 复用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-同时接收普通数据和带外数据"><span class="nav-text">1.1 同时接收普通数据和带外数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-聊天室程序"><span class="nav-text">1.2 聊天室程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-同时处理-TCP-和-UDP-服务"><span class="nav-text">1.3 同时处理 TCP 和 UDP 服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-LT-和-ET-模式"><span class="nav-text">1.4 LT 和 ET 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-使用-EPOLLONESHOT-事件"><span class="nav-text">1.5 使用 EPOLLONESHOT 事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-有限状态机"><span class="nav-text">2 有限状态机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-统一事件源"><span class="nav-text">3 统一事件源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-定时器"><span class="nav-text">4 定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-基于升序链表的定时器"><span class="nav-text">4.1 基于升序链表的定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-处理非活动连接"><span class="nav-text">4.2 处理非活动连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-共享内存"><span class="nav-text">5 共享内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-进程池与线程池"><span class="nav-text">6 进程池与线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-半同步-半异步进程池"><span class="nav-text">6.1 半同步&#x2F;半异步进程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-用进程池实现简单的-CGI-服务器"><span class="nav-text">6.2 用进程池实现简单的 CGI 服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-半同步-半反应堆线程池"><span class="nav-text">6.3 半同步&#x2F;半反应堆线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-简单-Web-服务器"><span class="nav-text">7 简单 Web 服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-http-conn-类"><span class="nav-text">7.1 http_conn 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-main-函数"><span class="nav-text">7.2 main 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-压力测试"><span class="nav-text">7.3 压力测试</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">从之丶</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><i id="darkmode" class="fa fa-lightbulb-o" aria-hidden="true"></i><script>var body=$("body"),darkmode=$("#darkmode");(matchMedia("(prefers-color-scheme: dark)").matches||"1"===localStorage.getItem("darkmode"))&&"1"!==localStorage.getItem("noDark")&&body.addClass("dark"),body.hasClass("dark")?darkmode.removeClass("fa-moon-o").addClass("fa-lightbulb-o"):darkmode.removeClass("fa-lightbulb-o").addClass("fa-moon-o"),darkmode.click(function(){body.hasClass("dark")?(darkmode.removeClass("fa-lightbulb-o").addClass("fa-moon-o"),body.removeClass("dark"),localStorage.setItem("darkmode","0"),localStorage.setItem("noDark","1")):(darkmode.removeClass("fa-moon-o").addClass("fa-lightbulb-o"),body.addClass("dark"),localStorage.setItem("darkmode","1"),localStorage.setItem("noDark","0"))})</script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/clipboard.min.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/highlight-wrap.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css"><script src="/lib/needsharebutton/needsharebutton.js"></script><script>pbOptions={},pbOptions.iconStyle="box",pbOptions.boxForm="horizontal",pbOptions.position="bottomCenter",pbOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={},flOptions.iconStyle="box",flOptions.boxForm="horizontal",flOptions.position="middleRight",flOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-float",flOptions)</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:200,height:270},mobile:{show:!1},log:!1})</script></body></html><!-- rebuild by neat -->